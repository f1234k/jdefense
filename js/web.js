var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/pixi.js/lib/extensions/Extensions.mjs
var ExtensionType, normalizeExtension = (ext) => {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = { ...metadata, ref: ext };
  }
  if (typeof ext === "object") {
    ext = { ...ext };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
}, normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority, extensions;
var init_Extensions = __esm(() => {
  ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
    ExtensionType2["Application"] = "application";
    ExtensionType2["WebGLPipes"] = "webgl-pipes";
    ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
    ExtensionType2["WebGLSystem"] = "webgl-system";
    ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
    ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
    ExtensionType2["WebGPUSystem"] = "webgpu-system";
    ExtensionType2["CanvasSystem"] = "canvas-system";
    ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
    ExtensionType2["CanvasPipes"] = "canvas-pipes";
    ExtensionType2["Asset"] = "asset";
    ExtensionType2["LoadParser"] = "load-parser";
    ExtensionType2["ResolveParser"] = "resolve-parser";
    ExtensionType2["CacheParser"] = "cache-parser";
    ExtensionType2["DetectionParser"] = "detection-parser";
    ExtensionType2["MaskEffect"] = "mask-effect";
    ExtensionType2["BlendMode"] = "blend-mode";
    ExtensionType2["TextureSource"] = "texture-source";
    ExtensionType2["Environment"] = "environment";
    ExtensionType2["ShapeBuilder"] = "shape-builder";
    ExtensionType2["Batcher"] = "batcher";
    return ExtensionType2;
  })(ExtensionType || {});
  extensions = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...extensions2) {
      extensions2.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
      });
      return this;
    },
    add(...extensions2) {
      extensions2.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type) => {
          const handlers = this._addHandlers;
          const queue = this._queue;
          if (!handlers[type]) {
            queue[type] = queue[type] || [];
            queue[type]?.push(ext);
          } else {
            handlers[type]?.(ext);
          }
        });
      });
      return this;
    },
    handle(type, onAdd, onRemove) {
      const addHandlers = this._addHandlers;
      const removeHandlers = this._removeHandlers;
      if (addHandlers[type] || removeHandlers[type]) {
        throw new Error(`Extension type ${type} already has a handler`);
      }
      addHandlers[type] = onAdd;
      removeHandlers[type] = onRemove;
      const queue = this._queue;
      if (queue[type]) {
        queue[type]?.forEach((ext) => onAdd(ext));
        delete queue[type];
      }
      return this;
    },
    handleByMap(type, map) {
      return this.handle(type, (extension) => {
        if (extension.name) {
          map[extension.name] = extension.ref;
        }
      }, (extension) => {
        if (extension.name) {
          delete map[extension.name];
        }
      });
    },
    handleByNamedList(type, map, defaultPriority = -1) {
      return this.handle(type, (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index >= 0)
          return;
        map.push({ name: extension.name, value: extension.ref });
        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));
      }, (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index !== -1) {
          map.splice(index, 1);
        }
      });
    },
    handleByList(type, list, defaultPriority = -1) {
      return this.handle(type, (extension) => {
        if (list.includes(extension.ref)) {
          return;
        }
        list.push(extension.ref);
        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));
      }, (extension) => {
        const index = list.indexOf(extension.ref);
        if (index !== -1) {
          list.splice(index, 1);
        }
      });
    },
    mixin(Target, ...sources) {
      for (const source of sources) {
        Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));
      }
    }
  };
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/eventemitter3/index.mjs
var import__, eventemitter3_default;
var init_eventemitter3 = __esm(() => {
  import__ = __toESM(require_eventemitter3(), 1);
  eventemitter3_default = import__.default;
});

// node_modules/@pixi/colord/index.mjs
var r, t = function(r2) {
  return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
}, n = function(r2, t2, n2) {
  return t2 === undefined && (t2 = 0), n2 === undefined && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
}, e = function(r2, t2, n2) {
  return t2 === undefined && (t2 = 0), n2 === undefined && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
}, u = function(r2) {
  return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
}, a = function(r2) {
  return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
}, o = function(r2) {
  return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
}, i, s = function(r2) {
  var t2 = r2.toString(16);
  return t2.length < 2 ? "0" + t2 : t2;
}, h = function(r2) {
  var { r: t2, g: n2, b: e2, a: u2 } = r2, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
  return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
}, b = function(r2) {
  var { h: t2, s: n2, v: e2, a: u2 } = r2;
  t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
  var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
  return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
}, g = function(r2) {
  return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
}, d = function(r2) {
  return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
}, f = function(r2) {
  return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
  var t2, n2, e2;
}, c = function(r2) {
  return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
  var t2, n2, e2, u2;
}, l, p, v, m, y, N = function(r2, t2) {
  for (var n2 = 0;n2 < t2.length; n2++) {
    var e2 = t2[n2][0](r2);
    if (e2)
      return [e2, t2[n2][1]];
  }
  return [null, undefined];
}, x = function(r2) {
  return typeof r2 == "string" ? N(r2.trim(), y.string) : typeof r2 == "object" && r2 !== null ? N(r2, y.object) : [null, undefined];
}, M = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
}, H = function(r2) {
  return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1000 / 255;
}, $ = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
}, j, w = function(r2) {
  return r2 instanceof j ? r2 : new j(r2);
}, S, k = function(r2) {
  r2.forEach(function(r3) {
    S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
  });
};
var init_colord = __esm(() => {
  r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
  i = /^#([0-9a-f]{3,8})$/i;
  l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  y = { string: [[function(r2) {
    var t2 = i.exec(r2);
    return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: r2.length === 4 ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : r2.length === 6 || r2.length === 8 ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: r2.length === 8 ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
  }, "hex"], [function(r2) {
    var t2 = v.exec(r2) || m.exec(r2);
    return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: t2[7] === undefined ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
  }, "rgb"], [function(t2) {
    var n2 = l.exec(t2) || p.exec(t2);
    if (!n2)
      return null;
    var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], u2 === undefined && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: n2[5] === undefined ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
    return f(a2);
  }, "hsl"]], object: [[function(r2) {
    var { r: n2, g: e2, b: u2, a: o2 } = r2, i2 = o2 === undefined ? 1 : o2;
    return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
  }, "rgb"], [function(r2) {
    var { h: n2, s: e2, l: u2, a: a2 } = r2, o2 = a2 === undefined ? 1 : a2;
    if (!t(n2) || !t(e2) || !t(u2))
      return null;
    var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
    return f(i2);
  }, "hsl"], [function(r2) {
    var { h: n2, s: a2, v: o2, a: i2 } = r2, s2 = i2 === undefined ? 1 : i2;
    if (!t(n2) || !t(a2) || !t(o2))
      return null;
    var h2 = function(r3) {
      return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
    }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
    return b(h2);
  }, "hsv"]] };
  j = function() {
    function r2(r3) {
      this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
    }
    return r2.prototype.isValid = function() {
      return this.parsed !== null;
    }, r2.prototype.brightness = function() {
      return n(H(this.rgba), 2);
    }, r2.prototype.isDark = function() {
      return H(this.rgba) < 0.5;
    }, r2.prototype.isLight = function() {
      return H(this.rgba) >= 0.5;
    }, r2.prototype.toHex = function() {
      return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
      var r3, t2, e2, u2, a2, i2;
    }, r2.prototype.toRgb = function() {
      return o(this.rgba);
    }, r2.prototype.toRgbString = function() {
      return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
      var r3, t2, n2, e2, u2;
    }, r2.prototype.toHsl = function() {
      return d(c(this.rgba));
    }, r2.prototype.toHslString = function() {
      return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
      var r3, t2, n2, e2, u2;
    }, r2.prototype.toHsv = function() {
      return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
      var r3;
    }, r2.prototype.invert = function() {
      return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
      var r3;
    }, r2.prototype.saturate = function(r3) {
      return r3 === undefined && (r3 = 0.1), w(M(this.rgba, r3));
    }, r2.prototype.desaturate = function(r3) {
      return r3 === undefined && (r3 = 0.1), w(M(this.rgba, -r3));
    }, r2.prototype.grayscale = function() {
      return w(M(this.rgba, -1));
    }, r2.prototype.lighten = function(r3) {
      return r3 === undefined && (r3 = 0.1), w($(this.rgba, r3));
    }, r2.prototype.darken = function(r3) {
      return r3 === undefined && (r3 = 0.1), w($(this.rgba, -r3));
    }, r2.prototype.rotate = function(r3) {
      return r3 === undefined && (r3 = 15), this.hue(this.hue() + r3);
    }, r2.prototype.alpha = function(r3) {
      return typeof r3 == "number" ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
      var t2;
    }, r2.prototype.hue = function(r3) {
      var t2 = c(this.rgba);
      return typeof r3 == "number" ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
    }, r2.prototype.isEqual = function(r3) {
      return this.toHex() === w(r3).toHex();
    }, r2;
  }();
  S = [];
});

// node_modules/@pixi/colord/plugins/names.mjs
function names_default(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a2)
    r2[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2)
      return n2;
    if (f3 == null ? undefined : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length)
        for (var c2 in a2)
          l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d3 = r3 === "transparent" ? "#0000" : a2[r3];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}

// node_modules/pixi.js/lib/color/Color.mjs
var _Color = class _Color2 {
  constructor(value = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value;
  }
  get red() {
    return this._components[0];
  }
  get green() {
    return this._components[1];
  }
  get blue() {
    return this._components[2];
  }
  get alpha() {
    return this._components[3];
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  set value(value) {
    if (value instanceof _Color2) {
      this._value = this._cloneSource(value._value);
      this._int = value._int;
      this._components.set(value._components);
    } else if (value === null) {
      throw new Error("Cannot set Color#value to null");
    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
      this._value = this._cloneSource(value);
      this._normalize(this._value);
    }
  }
  get value() {
    return this._value;
  }
  _cloneSource(value) {
    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
      return value;
    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return value.slice(0);
    } else if (typeof value === "object" && value !== null) {
      return { ...value };
    }
    return value;
  }
  _isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v2, i2) => v2 === value2[i2]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  toRgba() {
    const [r2, g2, b2, a2] = this._components;
    return { r: r2, g: g2, b: b2, a: a2 };
  }
  toRgb() {
    const [r2, g2, b2] = this._components;
    return { r: r2, g: g2, b: b2 };
  }
  toRgbaString() {
    const [r2, g2, b2] = this.toUint8RgbArray();
    return `rgba(${r2},${g2},${b2},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r2, g2, b2] = this._components;
    if (!this._arrayRgb) {
      this._arrayRgb = [];
    }
    out || (out = this._arrayRgb);
    out[0] = Math.round(r2 * 255);
    out[1] = Math.round(g2 * 255);
    out[2] = Math.round(b2 * 255);
    return out;
  }
  toArray(out) {
    if (!this._arrayRgba) {
      this._arrayRgba = [];
    }
    out || (out = this._arrayRgba);
    const [r2, g2, b2, a2] = this._components;
    out[0] = r2;
    out[1] = g2;
    out[2] = b2;
    out[3] = a2;
    return out;
  }
  toRgbArray(out) {
    if (!this._arrayRgb) {
      this._arrayRgb = [];
    }
    out || (out = this._arrayRgb);
    const [r2, g2, b2] = this._components;
    out[0] = r2;
    out[1] = g2;
    out[2] = b2;
    return out;
  }
  toNumber() {
    return this._int;
  }
  toBgrNumber() {
    const [r2, g2, b2] = this.toUint8RgbArray();
    return (b2 << 16) + (g2 << 8) + r2;
  }
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  multiply(value) {
    const [r2, g2, b2, a2] = _Color2._temp.setValue(value)._components;
    this._components[0] *= r2;
    this._components[1] *= g2;
    this._components[2] *= b2;
    this._components[3] *= a2;
    this._refreshInt();
    this._value = null;
    return this;
  }
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this._refreshInt();
    this._value = null;
    return this;
  }
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r2 = this._int >> 16 & 255;
    let g2 = this._int >> 8 & 255;
    let b2 = this._int & 255;
    if (applyToRGB) {
      r2 = r2 * alpha + 0.5 | 0;
      g2 = g2 * alpha + 0.5 | 0;
      b2 = b2 * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
  }
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  _normalize(value) {
    let r2;
    let g2;
    let b2;
    let a2;
    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r2 = (int >> 16 & 255) / 255;
      g2 = (int >> 8 & 255) / 255;
      b2 = (int & 255) / 255;
      a2 = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value);
      [r2, g2, b2, a2 = 1] = value;
    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value, 0, 255);
      [r2, g2, b2, a2 = 255] = value;
      r2 /= 255;
      g2 /= 255;
      b2 /= 255;
      a2 /= 255;
    } else if (typeof value === "string" || typeof value === "object") {
      if (typeof value === "string") {
        const match = _Color2.HEX_PATTERN.exec(value);
        if (match) {
          value = `#${match[2]}`;
        }
      }
      const color = w(value);
      if (color.isValid()) {
        ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
        r2 /= 255;
        g2 /= 255;
        b2 /= 255;
      }
    }
    if (r2 !== undefined) {
      this._components[0] = r2;
      this._components[1] = g2;
      this._components[2] = b2;
      this._components[3] = a2;
      this._refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value}`);
    }
  }
  _refreshInt() {
    this._clamp(this._components);
    const [r2, g2, b2] = this._components;
    this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
  }
  _clamp(value, min = 0, max = 1) {
    if (typeof value === "number") {
      return Math.min(Math.max(value, min), max);
    }
    value.forEach((v2, i2) => {
      value[i2] = Math.min(Math.max(v2, min), max);
    });
    return value;
  }
  static isColorLike(value) {
    return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color2 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== undefined && value.g !== undefined && value.b !== undefined || value.r !== undefined && value.g !== undefined && value.b !== undefined && value.a !== undefined || value.h !== undefined && value.s !== undefined && value.l !== undefined || value.h !== undefined && value.s !== undefined && value.l !== undefined && value.a !== undefined || value.h !== undefined && value.s !== undefined && value.v !== undefined || value.h !== undefined && value.s !== undefined && value.v !== undefined && value.a !== undefined;
  }
}, Color;
var init_Color = __esm(() => {
  init_colord();
  k([names_default]);
  _Color.shared = new _Color;
  _Color._temp = new _Color;
  _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  Color = _Color;
});

// node_modules/pixi.js/lib/culling/cullingMixin.mjs
var cullingMixin;
var init_cullingMixin = __esm(() => {
  cullingMixin = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
  };
});

// node_modules/pixi.js/lib/maths/misc/const.mjs
var PI_2, RAD_TO_DEG, DEG_TO_RAD;
var init_const = __esm(() => {
  PI_2 = Math.PI * 2;
  RAD_TO_DEG = 180 / Math.PI;
  DEG_TO_RAD = Math.PI / 180;
});

// node_modules/pixi.js/lib/maths/point/Point.mjs
class Point {
  constructor(x2 = 0, y2 = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x2;
    this.y = y2;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  copyFrom(p2) {
    this.set(p2.x, p2.y);
    return this;
  }
  copyTo(p2) {
    p2.set(this.x, this.y);
    return p2;
  }
  equals(p2) {
    return p2.x === this.x && p2.y === this.y;
  }
  set(x2 = 0, y2 = x2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  static get shared() {
    tempPoint.x = 0;
    tempPoint.y = 0;
    return tempPoint;
  }
}
var tempPoint;
var init_Point = __esm(() => {
  tempPoint = new Point;
});

// node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
class Matrix {
  constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
    this.array = null;
    this.a = a2;
    this.b = b2;
    this.c = c2;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
  }
  fromArray(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  }
  set(a2, b2, c2, d2, tx, ty) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  apply(pos, newPos) {
    newPos = newPos || new Point;
    const x2 = pos.x;
    const y2 = pos.y;
    newPos.x = this.a * x2 + this.c * y2 + this.tx;
    newPos.y = this.b * x2 + this.d * y2 + this.ty;
    return newPos;
  }
  applyInverse(pos, newPos) {
    newPos = newPos || new Point;
    const a2 = this.a;
    const b2 = this.b;
    const c2 = this.c;
    const d2 = this.d;
    const tx = this.tx;
    const ty = this.ty;
    const id = 1 / (a2 * d2 + c2 * -b2);
    const x2 = pos.x;
    const y2 = pos.y;
    newPos.x = d2 * id * x2 + -c2 * id * y2 + (ty * c2 - tx * d2) * id;
    newPos.y = a2 * id * y2 + -b2 * id * x2 + (-ty * a2 + tx * b2) * id;
    return newPos;
  }
  translate(x2, y2) {
    this.tx += x2;
    this.ty += y2;
    return this;
  }
  scale(x2, y2) {
    this.a *= x2;
    this.d *= y2;
    this.c *= x2;
    this.b *= y2;
    this.tx *= x2;
    this.ty *= y2;
    return this;
  }
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  appendFrom(a2, b2) {
    const a1 = a2.a;
    const b1 = a2.b;
    const c1 = a2.c;
    const d1 = a2.d;
    const tx = a2.tx;
    const ty = a2.ty;
    const a22 = b2.a;
    const b22 = b2.b;
    const c2 = b2.c;
    const d2 = b2.d;
    this.a = a1 * a22 + b1 * c2;
    this.b = a1 * b22 + b1 * d2;
    this.c = c1 * a22 + d1 * c2;
    this.d = c1 * b22 + d1 * d2;
    this.tx = tx * a22 + ty * c2 + b2.tx;
    this.ty = tx * b22 + ty * d2 + b2.ty;
    return this;
  }
  setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x2 - (pivotX * this.a + pivotY * this.c);
    this.ty = y2 - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  decompose(transform) {
    const a2 = this.a;
    const b2 = this.b;
    const c2 = this.c;
    const d2 = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c2, d2);
    const skewY = Math.atan2(b2, a2);
    const delta = Math.abs(skewX + skewY);
    if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
    transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
    transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
    transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
    return transform;
  }
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n2 = a1 * d1 - b1 * c1;
    this.a = d1 / n2;
    this.b = -b1 / n2;
    this.c = -c1 / n2;
    this.d = a1 / n2;
    this.tx = (c1 * this.ty - d1 * tx1) / n2;
    this.ty = -(a1 * this.ty - b1 * tx1) / n2;
    return this;
  }
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  clone() {
    const matrix = new Matrix;
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  equals(matrix) {
    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
  }
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  static get IDENTITY() {
    return identityMatrix.identity();
  }
  static get shared() {
    return tempMatrix.identity();
  }
}
var tempMatrix, identityMatrix;
var init_Matrix = __esm(() => {
  init_const();
  init_Point();
  tempMatrix = new Matrix;
  identityMatrix = new Matrix;
});

// node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
class ObservablePoint {
  constructor(observer, x2, y2) {
    this._x = x2 || 0;
    this._y = y2 || 0;
    this._observer = observer;
  }
  clone(observer) {
    return new ObservablePoint(observer ?? this._observer, this._x, this._y);
  }
  set(x2 = 0, y2 = x2) {
    if (this._x !== x2 || this._y !== y2) {
      this._x = x2;
      this._y = y2;
      this._observer._onUpdate(this);
    }
    return this;
  }
  copyFrom(p2) {
    if (this._x !== p2.x || this._y !== p2.y) {
      this._x = p2.x;
      this._y = p2.y;
      this._observer._onUpdate(this);
    }
    return this;
  }
  copyTo(p2) {
    p2.set(this._x, this._y);
    return p2;
  }
  equals(p2) {
    return p2.x === this._x && p2.y === this._y;
  }
  toString() {
    return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this._observer._onUpdate(this);
    }
  }
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this._observer._onUpdate(this);
    }
  }
}
var init_ObservablePoint = () => {};

// node_modules/pixi.js/lib/utils/data/uid.mjs
function uid(name = "default") {
  if (uidCache[name] === undefined) {
    uidCache[name] = -1;
  }
  return ++uidCache[name];
}
var uidCache;
var init_uid = __esm(() => {
  uidCache = {
    default: -1
  };
});

// node_modules/pixi.js/lib/utils/logging/deprecation.mjs
var warnings, v8_0_0 = "8.0.0", v8_3_4 = "8.3.4", deprecationState, deprecation = (version, message, ignoreDepth = 3) => {
  if (deprecationState.quiet || warnings.has(message))
    return;
  let stack = new Error().stack;
  const deprecationMessage = `${message}
Deprecated since v${version}`;
  const useGroup = typeof console.groupCollapsed === "function" && !deprecationState.noColor;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
  } else {
    stack = stack.split(`
`).splice(ignoreDepth).join(`
`);
    if (useGroup) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", deprecationMessage);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
      console.warn(stack);
    }
  }
  warnings.add(message);
};
var init_deprecation = __esm(() => {
  warnings = /* @__PURE__ */ new Set;
  deprecationState = {
    quiet: false,
    noColor: false
  };
  Object.defineProperties(deprecation, {
    quiet: {
      get: () => deprecationState.quiet,
      set: (value) => {
        deprecationState.quiet = value;
      },
      enumerable: true,
      configurable: false
    },
    noColor: {
      get: () => deprecationState.noColor,
      set: (value) => {
        deprecationState.noColor = value;
      },
      enumerable: true,
      configurable: false
    }
  });
});

// node_modules/pixi.js/lib/utils/logging/warn.mjs
function warn(...args) {
  if (warnCount === maxWarnings)
    return;
  warnCount++;
  if (warnCount === maxWarnings) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}
var warnCount = 0, maxWarnings = 500;
var init_warn = () => {};

// node_modules/pixi.js/lib/utils/pool/GlobalResourceRegistry.mjs
var GlobalResourceRegistry;
var init_GlobalResourceRegistry = __esm(() => {
  GlobalResourceRegistry = {
    _registeredResources: /* @__PURE__ */ new Set,
    register(pool) {
      this._registeredResources.add(pool);
    },
    unregister(pool) {
      this._registeredResources.delete(pool);
    },
    release() {
      this._registeredResources.forEach((pool) => pool.clear());
    },
    get registeredCount() {
      return this._registeredResources.size;
    },
    isRegistered(pool) {
      return this._registeredResources.has(pool);
    },
    reset() {
      this._registeredResources.clear();
    }
  };
});

// node_modules/pixi.js/lib/utils/pool/Pool.mjs
class Pool {
  constructor(ClassType, initialSize) {
    this._pool = [];
    this._count = 0;
    this._index = 0;
    this._classType = ClassType;
    if (initialSize) {
      this.prepopulate(initialSize);
    }
  }
  prepopulate(total) {
    for (let i2 = 0;i2 < total; i2++) {
      this._pool[this._index++] = new this._classType;
    }
    this._count += total;
  }
  get(data) {
    let item;
    if (this._index > 0) {
      item = this._pool[--this._index];
    } else {
      item = new this._classType;
    }
    item.init?.(data);
    return item;
  }
  return(item) {
    item.reset?.();
    this._pool[this._index++] = item;
  }
  get totalSize() {
    return this._count;
  }
  get totalFree() {
    return this._index;
  }
  get totalUsed() {
    return this._count - this._index;
  }
  clear() {
    if (this._pool.length > 0 && this._pool[0].destroy) {
      for (let i2 = 0;i2 < this._index; i2++) {
        this._pool[i2].destroy();
      }
    }
    this._pool.length = 0;
    this._count = 0;
    this._index = 0;
  }
}
var init_Pool = () => {};

// node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
class PoolGroupClass {
  constructor() {
    this._poolsByClass = /* @__PURE__ */ new Map;
  }
  prepopulate(Class, total) {
    const classPool = this.getPool(Class);
    classPool.prepopulate(total);
  }
  get(Class, data) {
    const pool = this.getPool(Class);
    return pool.get(data);
  }
  return(item) {
    const pool = this.getPool(item.constructor);
    pool.return(item);
  }
  getPool(ClassType) {
    if (!this._poolsByClass.has(ClassType)) {
      this._poolsByClass.set(ClassType, new Pool(ClassType));
    }
    return this._poolsByClass.get(ClassType);
  }
  stats() {
    const stats = {};
    this._poolsByClass.forEach((pool) => {
      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
      stats[name] = {
        free: pool.totalFree,
        used: pool.totalUsed,
        size: pool.totalSize
      };
    });
    return stats;
  }
  clear() {
    this._poolsByClass.forEach((pool) => pool.clear());
    this._poolsByClass.clear();
  }
}
var BigPool;
var init_PoolGroup = __esm(() => {
  init_GlobalResourceRegistry();
  init_Pool();
  BigPool = new PoolGroupClass;
  GlobalResourceRegistry.register(BigPool);
});

// node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs
var cacheAsTextureMixin;
var init_cacheAsTextureMixin = __esm(() => {
  init_deprecation();
  cacheAsTextureMixin = {
    get isCachedAsTexture() {
      return !!this.renderGroup?.isCachedAsTexture;
    },
    cacheAsTexture(val) {
      if (typeof val === "boolean" && val === false) {
        this.disableRenderGroup();
      } else {
        this.enableRenderGroup();
        this.renderGroup.enableCacheAsTexture(val === true ? {} : val);
      }
    },
    updateCacheTexture() {
      this.renderGroup?.updateCacheTexture();
    },
    get cacheAsBitmap() {
      return this.isCachedAsTexture;
    },
    set cacheAsBitmap(val) {
      deprecation("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead.");
      this.cacheAsTexture(val);
    }
  };
});

// node_modules/pixi.js/lib/utils/data/removeItems.mjs
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i2;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i2 = startIdx;i2 < len; ++i2) {
    arr[i2] = arr[i2 + removeCount];
  }
  arr.length = len;
}
var init_removeItems = () => {};

// node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
var childrenHelperMixin;
var init_childrenHelperMixin = __esm(() => {
  init_removeItems();
  init_deprecation();
  childrenHelperMixin = {
    allowChildren: true,
    removeChildren(beginIndex = 0, endIndex) {
      const end = endIndex ?? this.children.length;
      const range = end - beginIndex;
      const removed = [];
      if (range > 0 && range <= end) {
        for (let i2 = end - 1;i2 >= beginIndex; i2--) {
          const child = this.children[i2];
          if (!child)
            continue;
          removed.push(child);
          child.parent = null;
        }
        removeItems(this.children, beginIndex, end);
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.removeChildren(removed);
        }
        for (let i2 = 0;i2 < removed.length; ++i2) {
          const child = removed[i2];
          child.parentRenderLayer?.detach(child);
          this.emit("childRemoved", child, this, i2);
          removed[i2].emit("removed", this);
        }
        if (removed.length > 0) {
          this._didViewChangeTick++;
        }
        return removed;
      } else if (range === 0 && this.children.length === 0) {
        return removed;
      }
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    removeChildAt(index) {
      const child = this.getChildAt(index);
      return this.removeChild(child);
    },
    getChildAt(index) {
      if (index < 0 || index >= this.children.length) {
        throw new Error(`getChildAt: Index (${index}) does not exist.`);
      }
      return this.children[index];
    },
    setChildIndex(child, index) {
      if (index < 0 || index >= this.children.length) {
        throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
      }
      this.getChildIndex(child);
      this.addChildAt(child, index);
    },
    getChildIndex(child) {
      const index = this.children.indexOf(child);
      if (index === -1) {
        throw new Error("The supplied Container must be a child of the caller");
      }
      return index;
    },
    addChildAt(child, index) {
      if (!this.allowChildren) {
        deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      }
      const { children } = this;
      if (index < 0 || index > children.length) {
        throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
      }
      if (child.parent) {
        const currentIndex = child.parent.children.indexOf(child);
        if (child.parent === this && currentIndex === index) {
          return child;
        }
        if (currentIndex !== -1) {
          child.parent.children.splice(currentIndex, 1);
        }
      }
      if (index === children.length) {
        children.push(child);
      } else {
        children.splice(index, 0, child);
      }
      child.parent = this;
      child.didChange = true;
      child._updateFlags = 15;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.addChild(child);
      }
      if (this.sortableChildren)
        this.sortDirty = true;
      this.emit("childAdded", child, this, index);
      child.emit("added", this);
      return child;
    },
    swapChildren(child, child2) {
      if (child === child2) {
        return;
      }
      const index1 = this.getChildIndex(child);
      const index2 = this.getChildIndex(child2);
      this.children[index1] = child2;
      this.children[index2] = child;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
      this._didContainerChangeTick++;
    },
    removeFromParent() {
      this.parent?.removeChild(this);
    },
    reparentChild(...child) {
      if (child.length === 1) {
        return this.reparentChildAt(child[0], this.children.length);
      }
      child.forEach((c2) => this.reparentChildAt(c2, this.children.length));
      return child[0];
    },
    reparentChildAt(child, index) {
      if (child.parent === this) {
        this.setChildIndex(child, index);
        return child;
      }
      const childMat = child.worldTransform.clone();
      child.removeFromParent();
      this.addChildAt(child, index);
      const newMatrix = this.worldTransform.clone();
      newMatrix.invert();
      childMat.prepend(newMatrix);
      child.setFromMatrix(childMat);
      return child;
    },
    replaceChild(oldChild, newChild) {
      oldChild.updateLocalTransform();
      this.addChildAt(newChild, this.getChildIndex(oldChild));
      newChild.setFromMatrix(oldChild.localTransform);
      newChild.updateLocalTransform();
      this.removeChild(oldChild);
    }
  };
});

// node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs
var collectRenderablesMixin;
var init_collectRenderablesMixin = __esm(() => {
  collectRenderablesMixin = {
    collectRenderables(instructionSet, renderer, currentLayer) {
      if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild)
        return;
      if (this.sortableChildren) {
        this.sortChildren();
      }
      if (this.isSimple) {
        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
      } else if (this.renderGroup) {
        renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
      } else {
        this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);
      }
    },
    collectRenderablesSimple(instructionSet, renderer, currentLayer) {
      const children = this.children;
      const length = children.length;
      for (let i2 = 0;i2 < length; i2++) {
        children[i2].collectRenderables(instructionSet, renderer, currentLayer);
      }
    },
    collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {
      const { renderPipes } = renderer;
      for (let i2 = 0;i2 < this.effects.length; i2++) {
        const effect = this.effects[i2];
        const pipe = renderPipes[effect.pipe];
        pipe.push(effect, this, instructionSet);
      }
      this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
      for (let i2 = this.effects.length - 1;i2 >= 0; i2--) {
        const effect = this.effects[i2];
        const pipe = renderPipes[effect.pipe];
        pipe.pop(effect, this, instructionSet);
      }
    }
  };
});

// node_modules/pixi.js/lib/filters/FilterEffect.mjs
class FilterEffect {
  constructor() {
    this.pipe = "filter";
    this.priority = 1;
  }
  destroy() {
    for (let i2 = 0;i2 < this.filters.length; i2++) {
      this.filters[i2].destroy();
    }
    this.filters = null;
    this.filterArea = null;
  }
}
var init_FilterEffect = () => {};

// node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
class MaskEffectManagerClass {
  constructor() {
    this._effectClasses = [];
    this._tests = [];
    this._initialized = false;
  }
  init() {
    if (this._initialized)
      return;
    this._initialized = true;
    this._effectClasses.forEach((test) => {
      this.add({
        test: test.test,
        maskClass: test
      });
    });
  }
  add(test) {
    this._tests.push(test);
  }
  getMaskEffect(item) {
    if (!this._initialized)
      this.init();
    for (let i2 = 0;i2 < this._tests.length; i2++) {
      const test = this._tests[i2];
      if (test.test(item)) {
        return BigPool.get(test.maskClass, item);
      }
    }
    return item;
  }
  returnMaskEffect(effect) {
    BigPool.return(effect);
  }
}
var MaskEffectManager;
var init_MaskEffectManager = __esm(() => {
  init_Extensions();
  init_PoolGroup();
  MaskEffectManager = new MaskEffectManagerClass;
  extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
});

// node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
var effectsMixin;
var init_effectsMixin = __esm(() => {
  init_FilterEffect();
  init_MaskEffectManager();
  effectsMixin = {
    _maskEffect: null,
    _maskOptions: {
      inverse: false
    },
    _filterEffect: null,
    effects: [],
    _markStructureAsChanged() {
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
    },
    addEffect(effect) {
      const index = this.effects.indexOf(effect);
      if (index !== -1)
        return;
      this.effects.push(effect);
      this.effects.sort((a2, b2) => a2.priority - b2.priority);
      this._markStructureAsChanged();
      this._updateIsSimple();
    },
    removeEffect(effect) {
      const index = this.effects.indexOf(effect);
      if (index === -1)
        return;
      this.effects.splice(index, 1);
      this._markStructureAsChanged();
      this._updateIsSimple();
    },
    set mask(value) {
      const effect = this._maskEffect;
      if (effect?.mask === value)
        return;
      if (effect) {
        this.removeEffect(effect);
        MaskEffectManager.returnMaskEffect(effect);
        this._maskEffect = null;
      }
      if (value === null || value === undefined)
        return;
      this._maskEffect = MaskEffectManager.getMaskEffect(value);
      this.addEffect(this._maskEffect);
    },
    get mask() {
      return this._maskEffect?.mask;
    },
    setMask(options) {
      this._maskOptions = {
        ...this._maskOptions,
        ...options
      };
      if (options.mask) {
        this.mask = options.mask;
      }
      this._markStructureAsChanged();
    },
    set filters(value) {
      if (!Array.isArray(value) && value)
        value = [value];
      const effect = this._filterEffect || (this._filterEffect = new FilterEffect);
      value = value;
      const hasFilters = value?.length > 0;
      const hadFilters = effect.filters?.length > 0;
      const didChange = hasFilters !== hadFilters;
      value = Array.isArray(value) ? value.slice(0) : value;
      effect.filters = Object.freeze(value);
      if (didChange) {
        if (hasFilters) {
          this.addEffect(effect);
        } else {
          this.removeEffect(effect);
          effect.filters = value ?? null;
        }
      }
    },
    get filters() {
      return this._filterEffect?.filters;
    },
    set filterArea(value) {
      this._filterEffect || (this._filterEffect = new FilterEffect);
      this._filterEffect.filterArea = value;
    },
    get filterArea() {
      return this._filterEffect?.filterArea;
    }
  };
});

// node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
var findMixin;
var init_findMixin = __esm(() => {
  init_deprecation();
  findMixin = {
    label: null,
    get name() {
      deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
      return this.label;
    },
    set name(value) {
      deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
      this.label = value;
    },
    getChildByName(name, deep = false) {
      return this.getChildByLabel(name, deep);
    },
    getChildByLabel(label, deep = false) {
      const children = this.children;
      for (let i2 = 0;i2 < children.length; i2++) {
        const child = children[i2];
        if (child.label === label || label instanceof RegExp && label.test(child.label))
          return child;
      }
      if (deep) {
        for (let i2 = 0;i2 < children.length; i2++) {
          const child = children[i2];
          const found = child.getChildByLabel(label, true);
          if (found) {
            return found;
          }
        }
      }
      return null;
    },
    getChildrenByLabel(label, deep = false, out = []) {
      const children = this.children;
      for (let i2 = 0;i2 < children.length; i2++) {
        const child = children[i2];
        if (child.label === label || label instanceof RegExp && label.test(child.label)) {
          out.push(child);
        }
      }
      if (deep) {
        for (let i2 = 0;i2 < children.length; i2++) {
          children[i2].getChildrenByLabel(label, true, out);
        }
      }
      return out;
    }
  };
});

// node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
class Rectangle {
  constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
    this.type = "rectangle";
    this.x = Number(x2);
    this.y = Number(y2);
    this.width = Number(width);
    this.height = Number(height);
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  copyFromBounds(bounds) {
    this.x = bounds.minX;
    this.y = bounds.minY;
    this.width = bounds.maxX - bounds.minX;
    this.height = bounds.maxY - bounds.minY;
    return this;
  }
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  copyTo(rectangle) {
    rectangle.copyFrom(this);
    return rectangle;
  }
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 < this.x + this.width) {
      if (y2 >= this.y && y2 < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
    const { width, height } = this;
    if (width <= 0 || height <= 0)
      return false;
    const _x = this.x;
    const _y = this.y;
    const strokeWidthOuter = strokeWidth * (1 - alignment);
    const strokeWidthInner = strokeWidth - strokeWidthOuter;
    const outerLeft = _x - strokeWidthOuter;
    const outerRight = _x + width + strokeWidthOuter;
    const outerTop = _y - strokeWidthOuter;
    const outerBottom = _y + height + strokeWidthOuter;
    const innerLeft = _x + strokeWidthInner;
    const innerRight = _x + width - strokeWidthInner;
    const innerTop = _y + strokeWidthInner;
    const innerBottom = _y + height - strokeWidthInner;
    return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
  }
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints[0].set(other.left, other.top);
    const lb = tempPoints[1].set(other.left, other.bottom);
    const rt = tempPoints[2].set(other.right, other.top);
    const rb = tempPoints[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s2 === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s2 * (lb.y - lt.y);
    const ny = s2 * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s2 * (lt.y - rt.y);
    const my = s2 * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  ceil(resolution = 1, eps = 0.001) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  scale(x2, y2 = x2) {
    this.x *= x2;
    this.y *= y2;
    this.width *= x2;
    this.height *= y2;
    return this;
  }
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  getBounds(out) {
    out || (out = new Rectangle);
    out.copyFrom(this);
    return out;
  }
  containsRect(other) {
    if (this.width <= 0 || this.height <= 0)
      return false;
    const x1 = other.x;
    const y1 = other.y;
    const x2 = other.x + other.width;
    const y2 = other.y + other.height;
    return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
  }
  set(x2, y2, width, height) {
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    return this;
  }
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
var tempPoints;
var init_Rectangle = __esm(() => {
  init_Point();
  tempPoints = [new Point, new Point, new Point, new Point];
});

// node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
class Bounds {
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.matrix = defaultMatrix;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  get rectangle() {
    if (!this._rectangle) {
      this._rectangle = new Rectangle;
    }
    const rectangle = this._rectangle;
    if (this.minX > this.maxX || this.minY > this.maxY) {
      rectangle.x = 0;
      rectangle.y = 0;
      rectangle.width = 0;
      rectangle.height = 0;
    } else {
      rectangle.copyFromBounds(this);
    }
    return rectangle;
  }
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.matrix = defaultMatrix;
    return this;
  }
  set(x0, y0, x1, y1) {
    this.minX = x0;
    this.minY = y0;
    this.maxX = x1;
    this.maxY = y1;
  }
  addFrame(x0, y0, x1, y1, matrix) {
    matrix || (matrix = this.matrix);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x2 = a2 * x0 + c2 * y0 + tx;
    let y2 = b2 * x0 + d2 * y0 + ty;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    x2 = a2 * x1 + c2 * y0 + tx;
    y2 = b2 * x1 + d2 * y0 + ty;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    x2 = a2 * x0 + c2 * y1 + tx;
    y2 = b2 * x0 + d2 * y1 + ty;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    x2 = a2 * x1 + c2 * y1 + tx;
    y2 = b2 * x1 + d2 * y1 + ty;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addRect(rect, matrix) {
    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
  }
  addBounds(bounds, matrix) {
    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
  }
  addBoundsMask(mask) {
    this.minX = this.minX > mask.minX ? this.minX : mask.minX;
    this.minY = this.minY > mask.minY ? this.minY : mask.minY;
    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
  }
  applyMatrix(matrix) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix;
    let x2 = a2 * minX + c2 * minY + tx;
    let y2 = b2 * minX + d2 * minY + ty;
    this.minX = x2;
    this.minY = y2;
    this.maxX = x2;
    this.maxY = y2;
    x2 = a2 * maxX + c2 * minY + tx;
    y2 = b2 * maxX + d2 * minY + ty;
    this.minX = x2 < this.minX ? x2 : this.minX;
    this.minY = y2 < this.minY ? y2 : this.minY;
    this.maxX = x2 > this.maxX ? x2 : this.maxX;
    this.maxY = y2 > this.maxY ? y2 : this.maxY;
    x2 = a2 * minX + c2 * maxY + tx;
    y2 = b2 * minX + d2 * maxY + ty;
    this.minX = x2 < this.minX ? x2 : this.minX;
    this.minY = y2 < this.minY ? y2 : this.minY;
    this.maxX = x2 > this.maxX ? x2 : this.maxX;
    this.maxY = y2 > this.maxY ? y2 : this.maxY;
    x2 = a2 * maxX + c2 * maxY + tx;
    y2 = b2 * maxX + d2 * maxY + ty;
    this.minX = x2 < this.minX ? x2 : this.minX;
    this.minY = y2 < this.minY ? y2 : this.minY;
    this.maxX = x2 > this.maxX ? x2 : this.maxX;
    this.maxY = y2 > this.maxY ? y2 : this.maxY;
  }
  fit(rect) {
    if (this.minX < rect.left)
      this.minX = rect.left;
    if (this.maxX > rect.right)
      this.maxX = rect.right;
    if (this.minY < rect.top)
      this.minY = rect.top;
    if (this.maxY > rect.bottom)
      this.maxY = rect.bottom;
    return this;
  }
  fitBounds(left, right, top, bottom) {
    if (this.minX < left)
      this.minX = left;
    if (this.maxX > right)
      this.maxX = right;
    if (this.minY < top)
      this.minY = top;
    if (this.maxY > bottom)
      this.maxY = bottom;
    return this;
  }
  pad(paddingX, paddingY = paddingX) {
    this.minX -= paddingX;
    this.maxX += paddingX;
    this.minY -= paddingY;
    this.maxY += paddingY;
    return this;
  }
  ceil() {
    this.minX = Math.floor(this.minX);
    this.minY = Math.floor(this.minY);
    this.maxX = Math.ceil(this.maxX);
    this.maxY = Math.ceil(this.maxY);
    return this;
  }
  clone() {
    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
  }
  scale(x2, y2 = x2) {
    this.minX *= x2;
    this.minY *= y2;
    this.maxX *= x2;
    this.maxY *= y2;
    return this;
  }
  get x() {
    return this.minX;
  }
  set x(value) {
    const width = this.maxX - this.minX;
    this.minX = value;
    this.maxX = value + width;
  }
  get y() {
    return this.minY;
  }
  set y(value) {
    const height = this.maxY - this.minY;
    this.minY = value;
    this.maxY = value + height;
  }
  get width() {
    return this.maxX - this.minX;
  }
  set width(value) {
    this.maxX = this.minX + value;
  }
  get height() {
    return this.maxY - this.minY;
  }
  set height(value) {
    this.maxY = this.minY + value;
  }
  get left() {
    return this.minX;
  }
  get right() {
    return this.maxX;
  }
  get top() {
    return this.minY;
  }
  get bottom() {
    return this.maxY;
  }
  get isPositive() {
    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
  }
  get isValid() {
    return this.minX + this.minY !== Infinity;
  }
  addVertexData(vertexData, beginOffset, endOffset, matrix) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    matrix || (matrix = this.matrix);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    for (let i2 = beginOffset;i2 < endOffset; i2 += 2) {
      const localX = vertexData[i2];
      const localY = vertexData[i2 + 1];
      const x2 = a2 * localX + c2 * localY + tx;
      const y2 = b2 * localX + d2 * localY + ty;
      minX = x2 < minX ? x2 : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x2 > maxX ? x2 : maxX;
      maxY = y2 > maxY ? y2 : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  containsPoint(x2, y2) {
    if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
      return true;
    }
    return false;
  }
  toString() {
    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
  }
  copyFrom(bounds) {
    this.minX = bounds.minX;
    this.minY = bounds.minY;
    this.maxX = bounds.maxX;
    this.maxY = bounds.maxY;
    return this;
  }
}
var defaultMatrix;
var init_Bounds = __esm(() => {
  init_Matrix();
  init_Rectangle();
  defaultMatrix = new Matrix;
});

// node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
var matrixPool, boundsPool;
var init_matrixAndBoundsPool = __esm(() => {
  init_Matrix();
  init_PoolGroup();
  init_Bounds();
  matrixPool = BigPool.getPool(Matrix);
  boundsPool = BigPool.getPool(Bounds);
});

// node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs
var tempMatrix2, getFastGlobalBoundsMixin;
var init_getFastGlobalBoundsMixin = __esm(() => {
  init_Matrix();
  init_Bounds();
  init_matrixAndBoundsPool();
  tempMatrix2 = new Matrix;
  getFastGlobalBoundsMixin = {
    getFastGlobalBounds(factorRenderLayers, bounds) {
      bounds || (bounds = new Bounds);
      bounds.clear();
      this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);
      if (!bounds.isValid) {
        bounds.set(0, 0, 0, 0);
      }
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      bounds.applyMatrix(renderGroup.worldTransform);
      return bounds;
    },
    _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {
      let localBounds = bounds;
      if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer)
        return;
      if (this.localDisplayStatus !== 7 || !this.measurable) {
        return;
      }
      const manageEffects = !!this.effects.length;
      if (this.renderGroup || manageEffects) {
        localBounds = boundsPool.get().clear();
      }
      if (this.boundsArea) {
        bounds.addRect(this.boundsArea, this.worldTransform);
      } else {
        if (this.renderPipeId) {
          const viewBounds = this.bounds;
          localBounds.addFrame(viewBounds.minX, viewBounds.minY, viewBounds.maxX, viewBounds.maxY, this.groupTransform);
        }
        const children = this.children;
        for (let i2 = 0;i2 < children.length; i2++) {
          children[i2]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);
        }
      }
      if (manageEffects) {
        let advanced = false;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        for (let i2 = 0;i2 < this.effects.length; i2++) {
          if (this.effects[i2].addBounds) {
            if (!advanced) {
              advanced = true;
              localBounds.applyMatrix(renderGroup.worldTransform);
            }
            this.effects[i2].addBounds(localBounds, true);
          }
        }
        if (advanced) {
          localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix2).invert());
        }
        bounds.addBounds(localBounds);
        boundsPool.return(localBounds);
      } else if (this.renderGroup) {
        bounds.addBounds(localBounds, this.relativeGroupTransform);
        boundsPool.return(localBounds);
      }
    }
  };
});

// node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  let pooledMatrix;
  if (target.parent) {
    if (!skipUpdateTransform) {
      pooledMatrix = matrixPool.get().identity();
      parentTransform = updateTransformBackwards(target, pooledMatrix);
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (pooledMatrix) {
    matrixPool.return(pooledMatrix);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    target.updateLocalTransform();
    worldTransform = matrixPool.get();
    worldTransform.appendFrom(target.localTransform, parentTransform);
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, worldTransform);
  } else {
    const renderableBounds = target.bounds;
    if (renderableBounds && !renderableBounds.isEmpty()) {
      bounds.matrix = worldTransform;
      bounds.addBounds(renderableBounds);
    }
    for (let i2 = 0;i2 < target.children.length; i2++) {
      _getGlobalBounds(target.children[i2], bounds, worldTransform, skipUpdateTransform);
    }
  }
  if (preserveBounds) {
    for (let i2 = 0;i2 < target.effects.length; i2++) {
      target.effects[i2].addBounds?.(bounds);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  if (!skipUpdateTransform) {
    matrixPool.return(worldTransform);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent = target.parent;
  if (parent) {
    updateTransformBackwards(parent, parentTransform);
    parent.updateLocalTransform();
    parentTransform.append(parent.localTransform);
  }
  return parentTransform;
}
var init_getGlobalBounds = __esm(() => {
  init_Matrix();
  init_matrixAndBoundsPool();
});

// node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs
function multiplyHexColors(color1, color2) {
  if (color1 === 16777215 || !color2)
    return color2;
  if (color2 === 16777215 || !color1)
    return color1;
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r3 = r1 * r2 / 255 | 0;
  const g3 = g1 * g2 / 255 | 0;
  const b3 = b1 * b2 / 255 | 0;
  return (r3 << 16) + (g3 << 8) + b3;
}
var init_multiplyHexColors = () => {};

// node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs
function multiplyColors(localBGRColor, parentBGRColor) {
  if (localBGRColor === WHITE_BGR) {
    return parentBGRColor;
  }
  if (parentBGRColor === WHITE_BGR) {
    return localBGRColor;
  }
  return multiplyHexColors(localBGRColor, parentBGRColor);
}
var WHITE_BGR = 16777215;
var init_multiplyColors = __esm(() => {
  init_multiplyHexColors();
});

// node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs
function bgr2rgb(color) {
  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);
}
var getGlobalMixin;
var init_getGlobalMixin = __esm(() => {
  init_Matrix();
  init_getGlobalBounds();
  init_matrixAndBoundsPool();
  init_multiplyColors();
  getGlobalMixin = {
    getGlobalAlpha(skipUpdate) {
      if (skipUpdate) {
        if (this.renderGroup) {
          return this.renderGroup.worldAlpha;
        }
        if (this.parentRenderGroup) {
          return this.parentRenderGroup.worldAlpha * this.alpha;
        }
        return this.alpha;
      }
      let alpha = this.alpha;
      let current = this.parent;
      while (current) {
        alpha *= current.alpha;
        current = current.parent;
      }
      return alpha;
    },
    getGlobalTransform(matrix = new Matrix, skipUpdate) {
      if (skipUpdate) {
        return matrix.copyFrom(this.worldTransform);
      }
      this.updateLocalTransform();
      const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());
      matrix.appendFrom(this.localTransform, parentTransform);
      matrixPool.return(parentTransform);
      return matrix;
    },
    getGlobalTint(skipUpdate) {
      if (skipUpdate) {
        if (this.renderGroup) {
          return bgr2rgb(this.renderGroup.worldColor);
        }
        if (this.parentRenderGroup) {
          return bgr2rgb(multiplyColors(this.localColor, this.parentRenderGroup.worldColor));
        }
        return this.tint;
      }
      let color = this.localColor;
      let parent = this.parent;
      while (parent) {
        color = multiplyColors(color, parent.localColor);
        parent = parent.parent;
      }
      return bgr2rgb(color);
    }
  };
});

// node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
  _getLocalBounds(target, bounds, relativeMatrix, target, true);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
  let relativeTransform;
  if (!isRoot) {
    if (!target.visible || !target.measurable)
      return;
    target.updateLocalTransform();
    const localTransform = target.localTransform;
    relativeTransform = matrixPool.get();
    relativeTransform.appendFrom(localTransform, parentTransform);
  } else {
    relativeTransform = matrixPool.get();
    relativeTransform = parentTransform.copyTo(relativeTransform);
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, relativeTransform);
  } else {
    if (target.renderPipeId) {
      bounds.matrix = relativeTransform;
      bounds.addBounds(target.bounds);
    }
    const children = target.children;
    for (let i2 = 0;i2 < children.length; i2++) {
      _getLocalBounds(children[i2], bounds, relativeTransform, rootContainer, false);
    }
  }
  if (preserveBounds) {
    for (let i2 = 0;i2 < target.effects.length; i2++) {
      target.effects[i2].addLocalBounds?.(bounds, rootContainer);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  matrixPool.return(relativeTransform);
}
var init_getLocalBounds = __esm(() => {
  init_Matrix();
  init_matrixAndBoundsPool();
});

// node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs
function checkChildrenDidChange(container, previousData) {
  const children = container.children;
  for (let i2 = 0;i2 < children.length; i2++) {
    const child = children[i2];
    const uid2 = child.uid;
    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
    const index = previousData.index;
    if (previousData.data[index] !== uid2 || previousData.data[index + 1] !== didChange) {
      previousData.data[previousData.index] = uid2;
      previousData.data[previousData.index + 1] = didChange;
      previousData.didChange = true;
    }
    previousData.index = index + 2;
    if (child.children.length) {
      checkChildrenDidChange(child, previousData);
    }
  }
  return previousData.didChange;
}
var init_checkChildrenDidChange = () => {};

// node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
var tempMatrix3, measureMixin;
var init_measureMixin = __esm(() => {
  init_Matrix();
  init_Bounds();
  init_getGlobalBounds();
  init_getLocalBounds();
  init_checkChildrenDidChange();
  tempMatrix3 = new Matrix;
  measureMixin = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth(value, localWidth) {
      const sign = Math.sign(this.scale.x) || 1;
      if (localWidth !== 0) {
        this.scale.x = value / localWidth * sign;
      } else {
        this.scale.x = sign;
      }
    },
    _setHeight(value, localHeight) {
      const sign = Math.sign(this.scale.y) || 1;
      if (localHeight !== 0) {
        this.scale.y = value / localHeight * sign;
      } else {
        this.scale.y = sign;
      }
    },
    getLocalBounds() {
      if (!this._localBoundsCacheData) {
        this._localBoundsCacheData = {
          data: [],
          index: 1,
          didChange: false,
          localBounds: new Bounds
        };
      }
      const localBoundsCacheData = this._localBoundsCacheData;
      localBoundsCacheData.index = 1;
      localBoundsCacheData.didChange = false;
      if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
        localBoundsCacheData.didChange = true;
        localBoundsCacheData.data[0] = this._didViewChangeTick;
      }
      checkChildrenDidChange(this, localBoundsCacheData);
      if (localBoundsCacheData.didChange) {
        getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix3);
      }
      return localBoundsCacheData.localBounds;
    },
    getBounds(skipUpdate, bounds) {
      return getGlobalBounds(this, skipUpdate, bounds || new Bounds);
    }
  };
});

// node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
var onRenderMixin;
var init_onRenderMixin = __esm(() => {
  onRenderMixin = {
    _onRender: null,
    set onRender(func) {
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (!func) {
        if (this._onRender) {
          renderGroup?.removeOnRender(this);
        }
        this._onRender = null;
        return;
      }
      if (!this._onRender) {
        renderGroup?.addOnRender(this);
      }
      this._onRender = func;
    },
    get onRender() {
      return this._onRender;
    }
  };
});

// node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
function sortChildren(a2, b2) {
  return a2._zIndex - b2._zIndex;
}
var sortMixin;
var init_sortMixin = __esm(() => {
  sortMixin = {
    _zIndex: 0,
    sortDirty: false,
    sortableChildren: false,
    get zIndex() {
      return this._zIndex;
    },
    set zIndex(value) {
      if (this._zIndex === value)
        return;
      this._zIndex = value;
      this.depthOfChildModified();
    },
    depthOfChildModified() {
      if (this.parent) {
        this.parent.sortableChildren = true;
        this.parent.sortDirty = true;
      }
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
    },
    sortChildren() {
      if (!this.sortDirty)
        return;
      this.sortDirty = false;
      this.children.sort(sortChildren);
    }
  };
});

// node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
var toLocalGlobalMixin;
var init_toLocalGlobalMixin = __esm(() => {
  init_Point();
  init_matrixAndBoundsPool();
  toLocalGlobalMixin = {
    getGlobalPosition(point = new Point, skipUpdate = false) {
      if (this.parent) {
        this.parent.toGlobal(this._position, point, skipUpdate);
      } else {
        point.x = this._position.x;
        point.y = this._position.y;
      }
      return point;
    },
    toGlobal(position, point, skipUpdate = false) {
      const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
      point = globalMatrix.apply(position, point);
      matrixPool.return(globalMatrix);
      return point;
    },
    toLocal(position, from, point, skipUpdate) {
      if (from) {
        position = from.toGlobal(position, point, skipUpdate);
      }
      const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
      point = globalMatrix.applyInverse(position, point);
      matrixPool.return(globalMatrix);
      return point;
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
class InstructionSet {
  constructor() {
    this.uid = uid("instructionSet");
    this.instructions = [];
    this.instructionSize = 0;
    this.renderables = [];
    this.gcTick = 0;
  }
  reset() {
    this.instructionSize = 0;
  }
  destroy() {
    this.instructions.length = 0;
    this.renderables.length = 0;
    this.renderPipes = null;
    this.gcTick = 0;
  }
  add(instruction) {
    this.instructions[this.instructionSize++] = instruction;
  }
  log() {
    this.instructions.length = this.instructionSize;
    console.table(this.instructions, ["type", "action"]);
  }
}
var init_InstructionSet = __esm(() => {
  init_uid();
});

// node_modules/pixi.js/lib/maths/misc/pow2.mjs
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
var init_pow2 = () => {};

// node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
function definedProps(obj) {
  const result = {};
  for (const key in obj) {
    if (obj[key] !== undefined) {
      result[key] = obj[key];
    }
  }
  return result;
}
var init_definedProps = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
function createResourceIdFromString(value) {
  const id = idHash[value];
  if (id === undefined) {
    idHash[value] = uid("resource");
  }
  return id;
}
var idHash, _TextureStyle, TextureStyle;
var init_TextureStyle = __esm(() => {
  init_eventemitter3();
  init_uid();
  init_deprecation();
  idHash = /* @__PURE__ */ Object.create(null);
  _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
    constructor(options = {}) {
      super();
      this._resourceType = "textureSampler";
      this._touched = 0;
      this._maxAnisotropy = 1;
      this.destroyed = false;
      options = { ..._TextureStyle2.defaultOptions, ...options };
      this.addressMode = options.addressMode;
      this.addressModeU = options.addressModeU ?? this.addressModeU;
      this.addressModeV = options.addressModeV ?? this.addressModeV;
      this.addressModeW = options.addressModeW ?? this.addressModeW;
      this.scaleMode = options.scaleMode;
      this.magFilter = options.magFilter ?? this.magFilter;
      this.minFilter = options.minFilter ?? this.minFilter;
      this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
      this.lodMinClamp = options.lodMinClamp;
      this.lodMaxClamp = options.lodMaxClamp;
      this.compare = options.compare;
      this.maxAnisotropy = options.maxAnisotropy ?? 1;
    }
    set addressMode(value) {
      this.addressModeU = value;
      this.addressModeV = value;
      this.addressModeW = value;
    }
    get addressMode() {
      return this.addressModeU;
    }
    set wrapMode(value) {
      deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
      this.addressMode = value;
    }
    get wrapMode() {
      return this.addressMode;
    }
    set scaleMode(value) {
      this.magFilter = value;
      this.minFilter = value;
      this.mipmapFilter = value;
    }
    get scaleMode() {
      return this.magFilter;
    }
    set maxAnisotropy(value) {
      this._maxAnisotropy = Math.min(value, 16);
      if (this._maxAnisotropy > 1) {
        this.scaleMode = "linear";
      }
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    get _resourceId() {
      return this._sharedResourceId || this._generateResourceId();
    }
    update() {
      this.emit("change", this);
      this._sharedResourceId = null;
    }
    _generateResourceId() {
      const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      this._sharedResourceId = createResourceIdFromString(bigKey);
      return this._resourceId;
    }
    destroy() {
      this.destroyed = true;
      this.emit("destroy", this);
      this.emit("change", this);
      this.removeAllListeners();
    }
  };
  _TextureStyle.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
  };
  TextureStyle = _TextureStyle;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
var _TextureSource, TextureSource;
var init_TextureSource = __esm(() => {
  init_eventemitter3();
  init_pow2();
  init_definedProps();
  init_uid();
  init_TextureStyle();
  _TextureSource = class _TextureSource2 extends eventemitter3_default {
    constructor(options = {}) {
      super();
      this.options = options;
      this.uid = uid("textureSource");
      this._resourceType = "textureSource";
      this._resourceId = uid("resource");
      this.uploadMethodId = "unknown";
      this._resolution = 1;
      this.pixelWidth = 1;
      this.pixelHeight = 1;
      this.width = 1;
      this.height = 1;
      this.sampleCount = 1;
      this.mipLevelCount = 1;
      this.autoGenerateMipmaps = false;
      this.format = "rgba8unorm";
      this.dimension = "2d";
      this.antialias = false;
      this._touched = 0;
      this._batchTick = -1;
      this._textureBindLocation = -1;
      options = { ..._TextureSource2.defaultOptions, ...options };
      this.label = options.label ?? "";
      this.resource = options.resource;
      this.autoGarbageCollect = options.autoGarbageCollect;
      this._resolution = options.resolution;
      if (options.width) {
        this.pixelWidth = options.width * this._resolution;
      } else {
        this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
      }
      if (options.height) {
        this.pixelHeight = options.height * this._resolution;
      } else {
        this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
      }
      this.width = this.pixelWidth / this._resolution;
      this.height = this.pixelHeight / this._resolution;
      this.format = options.format;
      this.dimension = options.dimensions;
      this.mipLevelCount = options.mipLevelCount;
      this.autoGenerateMipmaps = options.autoGenerateMipmaps;
      this.sampleCount = options.sampleCount;
      this.antialias = options.antialias;
      this.alphaMode = options.alphaMode;
      this.style = new TextureStyle(definedProps(options));
      this.destroyed = false;
      this._refreshPOT();
    }
    get source() {
      return this;
    }
    get style() {
      return this._style;
    }
    set style(value) {
      if (this.style === value)
        return;
      this._style?.off("change", this._onStyleChange, this);
      this._style = value;
      this._style?.on("change", this._onStyleChange, this);
      this._onStyleChange();
    }
    set maxAnisotropy(value) {
      this._style.maxAnisotropy = value;
    }
    get maxAnisotropy() {
      return this._style.maxAnisotropy;
    }
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(value) {
      this._style.addressMode = value;
    }
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(value) {
      this._style.addressMode = value;
    }
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(value) {
      this._style.magFilter = value;
    }
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(value) {
      this._style.minFilter = value;
    }
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(value) {
      this._style.mipmapFilter = value;
    }
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(value) {
      this._style.lodMinClamp = value;
    }
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(value) {
      this._style.lodMaxClamp = value;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    update() {
      if (this.resource) {
        const resolution = this._resolution;
        const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
        if (didResize)
          return;
      }
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true;
      this.emit("destroy", this);
      this.emit("change", this);
      if (this._style) {
        this._style.destroy();
        this._style = null;
      }
      this.uploadMethodId = null;
      this.resource = null;
      this.removeAllListeners();
    }
    unload() {
      this._resourceId = uid("resource");
      this.emit("change", this);
      this.emit("unload", this);
    }
    get resourceWidth() {
      const { resource } = this;
      return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
    }
    get resourceHeight() {
      const { resource } = this;
      return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(resolution) {
      if (this._resolution === resolution)
        return;
      this._resolution = resolution;
      this.width = this.pixelWidth / resolution;
      this.height = this.pixelHeight / resolution;
    }
    resize(width, height, resolution) {
      resolution || (resolution = this._resolution);
      width || (width = this.width);
      height || (height = this.height);
      const newPixelWidth = Math.round(width * resolution);
      const newPixelHeight = Math.round(height * resolution);
      this.width = newPixelWidth / resolution;
      this.height = newPixelHeight / resolution;
      this._resolution = resolution;
      if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
        return false;
      }
      this._refreshPOT();
      this.pixelWidth = newPixelWidth;
      this.pixelHeight = newPixelHeight;
      this.emit("resize", this);
      this._resourceId = uid("resource");
      this.emit("change", this);
      return true;
    }
    updateMipmaps() {
      if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
        this.emit("updateMipmaps", this);
      }
    }
    set wrapMode(value) {
      this._style.wrapMode = value;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(value) {
      this._style.scaleMode = value;
    }
    get scaleMode() {
      return this._style.scaleMode;
    }
    _refreshPOT() {
      this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
    }
    static test(_resource) {
      throw new Error("Unimplemented");
    }
  };
  _TextureSource.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: false,
    sampleCount: 1,
    antialias: false,
    autoGarbageCollect: false
  };
  TextureSource = _TextureSource;
});

// node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
function init() {
  for (let i2 = 0;i2 < 16; i2++) {
    const row = [];
    rotationCayley.push(row);
    for (let j2 = 0;j2 < 16; j2++) {
      const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
      const _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
      const _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
      const _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
      for (let k2 = 0;k2 < 16; k2++) {
        if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
          row.push(k2);
          break;
        }
      }
    }
  }
  for (let i2 = 0;i2 < 16; i2++) {
    const mat = new Matrix;
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
    rotationMatrices.push(mat);
  }
}
var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
var init_groupD8 = __esm(() => {
  init_Matrix();
  ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
  uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
  vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
  vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
  rotationCayley = [];
  rotationMatrices = [];
  signum = Math.sign;
  init();
  groupD8 = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (ind) => ux[ind],
    uY: (ind) => uy[ind],
    vX: (ind) => vx[ind],
    vY: (ind) => vy[ind],
    inv: (rotation) => {
      if (rotation & 8) {
        return rotation & 15;
      }
      return -rotation & 7;
    },
    add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
    sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
    rotate180: (rotation) => rotation ^ 4,
    isVertical: (rotation) => (rotation & 3) === 2,
    byDirection: (dx, dy) => {
      if (Math.abs(dx) * 2 <= Math.abs(dy)) {
        if (dy >= 0) {
          return groupD8.S;
        }
        return groupD8.N;
      } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
        if (dx > 0) {
          return groupD8.E;
        }
        return groupD8.W;
      } else if (dy > 0) {
        if (dx > 0) {
          return groupD8.SE;
        }
        return groupD8.SW;
      } else if (dx > 0) {
        return groupD8.NE;
      }
      return groupD8.NW;
    },
    matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
      const mat = rotationMatrices[groupD8.inv(rotation)];
      mat.tx = tx;
      mat.ty = ty;
      matrix.append(mat);
    },
    transformRectCoords: (rect, sourceFrame, rotation, out) => {
      const { x: x2, y: y2, width, height } = rect;
      const { x: frameX, y: frameY, width: frameWidth, height: frameHeight } = sourceFrame;
      if (rotation === groupD8.E) {
        out.set(x2 + frameX, y2 + frameY, width, height);
        return out;
      } else if (rotation === groupD8.S) {
        return out.set(frameWidth - y2 - height + frameX, x2 + frameY, height, width);
      } else if (rotation === groupD8.W) {
        return out.set(frameWidth - x2 - width + frameX, frameHeight - y2 - height + frameY, width, height);
      } else if (rotation === groupD8.N) {
        return out.set(y2 + frameX, frameHeight - x2 - width + frameY, height, width);
      }
      return out.set(x2 + frameX, y2 + frameY, width, height);
    }
  };
});

// node_modules/pixi.js/lib/utils/misc/NOOP.mjs
var NOOP = () => {};
var init_NOOP = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
var BufferImageSource;
var init_BufferImageSource = __esm(() => {
  init_Extensions();
  init_TextureSource();
  BufferImageSource = class BufferImageSource extends TextureSource {
    constructor(options) {
      const buffer = options.resource || new Float32Array(options.width * options.height * 4);
      let format = options.format;
      if (!format) {
        if (buffer instanceof Float32Array) {
          format = "rgba32float";
        } else if (buffer instanceof Int32Array) {
          format = "rgba32uint";
        } else if (buffer instanceof Uint32Array) {
          format = "rgba32uint";
        } else if (buffer instanceof Int16Array) {
          format = "rgba16uint";
        } else if (buffer instanceof Uint16Array) {
          format = "rgba16uint";
        } else if (buffer instanceof Int8Array) {
          format = "bgra8unorm";
        } else {
          format = "bgra8unorm";
        }
      }
      super({
        ...options,
        resource: buffer,
        format
      });
      this.uploadMethodId = "buffer";
    }
    static test(resource) {
      return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
    }
  };
  BufferImageSource.extension = ExtensionType.TextureSource;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
class TextureMatrix {
  constructor(texture, clampMargin) {
    this.mapCoord = new Matrix;
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    if (typeof clampMargin === "undefined") {
      this.clampMargin = texture.width < 10 ? 0 : 0.5;
    } else {
      this.clampMargin = clampMargin;
    }
    this.isSimple = false;
    this.texture = texture;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this.texture === value)
      return;
    this._texture?.removeListener("update", this.update, this);
    this._texture = value;
    this._texture.addListener("update", this.update, this);
    this.update();
  }
  multiplyUvs(uvs, out) {
    if (out === undefined) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i2 = 0;i2 < uvs.length; i2 += 2) {
      const x2 = uvs[i2];
      const y2 = uvs[i2 + 1];
      out[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
      out[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
    }
    return out;
  }
  update() {
    const tex = this._texture;
    this._updateID++;
    const uvs = tex.uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
      this.mapCoord.append(tempMat);
    }
    const texBase = tex.source;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase._resolution;
    const offset = this.clampOffset / texBase._resolution;
    frame[0] = (tex.frame.x + margin + offset) / texBase.width;
    frame[1] = (tex.frame.y + margin + offset) / texBase.height;
    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}
var tempMat;
var init_TextureMatrix = __esm(() => {
  init_Matrix();
  tempMat = new Matrix;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
var Texture;
var init_Texture = __esm(() => {
  init_eventemitter3();
  init_groupD8();
  init_Rectangle();
  init_uid();
  init_deprecation();
  init_NOOP();
  init_BufferImageSource();
  init_TextureSource();
  init_TextureMatrix();
  Texture = class Texture extends eventemitter3_default {
    constructor({
      source,
      label,
      frame,
      orig,
      trim,
      defaultAnchor,
      defaultBorders,
      rotate,
      dynamic
    } = {}) {
      super();
      this.uid = uid("texture");
      this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
      this.frame = new Rectangle;
      this.noFrame = false;
      this.dynamic = false;
      this.isTexture = true;
      this.label = label;
      this.source = source?.source ?? new TextureSource;
      this.noFrame = !frame;
      if (frame) {
        this.frame.copyFrom(frame);
      } else {
        const { width, height } = this._source;
        this.frame.width = width;
        this.frame.height = height;
      }
      this.orig = orig || this.frame;
      this.trim = trim;
      this.rotate = rotate ?? 0;
      this.defaultAnchor = defaultAnchor;
      this.defaultBorders = defaultBorders;
      this.destroyed = false;
      this.dynamic = dynamic || false;
      this.updateUvs();
    }
    set source(value) {
      if (this._source) {
        this._source.off("resize", this.update, this);
      }
      this._source = value;
      value.on("resize", this.update, this);
      this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      if (!this._textureMatrix) {
        this._textureMatrix = new TextureMatrix(this);
      }
      return this._textureMatrix;
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const { uvs, frame } = this;
      const { width, height } = this._source;
      const nX = frame.x / width;
      const nY = frame.y / height;
      const nW = frame.width / width;
      const nH = frame.height / height;
      let rotate = this.rotate;
      if (rotate) {
        const w2 = nW / 2;
        const h2 = nH / 2;
        const cX = nX + w2;
        const cY = nY + h2;
        rotate = groupD8.add(rotate, groupD8.NW);
        uvs.x0 = cX + w2 * groupD8.uX(rotate);
        uvs.y0 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        uvs.x1 = cX + w2 * groupD8.uX(rotate);
        uvs.y1 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        uvs.x2 = cX + w2 * groupD8.uX(rotate);
        uvs.y2 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        uvs.x3 = cX + w2 * groupD8.uX(rotate);
        uvs.y3 = cY + h2 * groupD8.uY(rotate);
      } else {
        uvs.x0 = nX;
        uvs.y0 = nY;
        uvs.x1 = nX + nW;
        uvs.y1 = nY;
        uvs.x2 = nX + nW;
        uvs.y2 = nY + nH;
        uvs.x3 = nX;
        uvs.y3 = nY + nH;
      }
    }
    destroy(destroySource = false) {
      if (this._source) {
        if (destroySource) {
          this._source.destroy();
          this._source = null;
        }
      }
      this._textureMatrix = null;
      this.destroyed = true;
      this.emit("destroy", this);
      this.removeAllListeners();
    }
    update() {
      if (this.noFrame) {
        this.frame.width = this._source.width;
        this.frame.height = this._source.height;
      }
      this.updateUvs();
      this.emit("update", this);
    }
    get baseTexture() {
      deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
      return this._source;
    }
  };
  Texture.EMPTY = new Texture({
    label: "EMPTY",
    source: new TextureSource({
      label: "EMPTY"
    })
  });
  Texture.EMPTY.destroy = NOOP;
  Texture.WHITE = new Texture({
    source: new BufferImageSource({
      resource: new Uint8Array([255, 255, 255, 255]),
      width: 1,
      height: 1,
      alphaMode: "premultiply-alpha-on-upload",
      label: "WHITE"
    }),
    label: "WHITE"
  });
  Texture.WHITE.destroy = NOOP;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
class TexturePoolClass {
  constructor(textureOptions) {
    this._poolKeyHash = /* @__PURE__ */ Object.create(null);
    this._texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this.textureStyle = new TextureStyle(this.textureOptions);
  }
  createTexture(pixelWidth, pixelHeight, antialias) {
    const textureSource = new TextureSource({
      ...this.textureOptions,
      width: pixelWidth,
      height: pixelHeight,
      resolution: 1,
      antialias,
      autoGarbageCollect: false
    });
    return new Texture({
      source: textureSource,
      label: `texturePool_${count++}`
    });
  }
  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
    let po2Width = Math.ceil(frameWidth * resolution - 0.000001);
    let po2Height = Math.ceil(frameHeight * resolution - 0.000001);
    po2Width = nextPow2(po2Width);
    po2Height = nextPow2(po2Height);
    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
    if (!this._texturePool[key]) {
      this._texturePool[key] = [];
    }
    let texture = this._texturePool[key].pop();
    if (!texture) {
      texture = this.createTexture(po2Width, po2Height, antialias);
    }
    texture.source._resolution = resolution;
    texture.source.width = po2Width / resolution;
    texture.source.height = po2Height / resolution;
    texture.source.pixelWidth = po2Width;
    texture.source.pixelHeight = po2Height;
    texture.frame.x = 0;
    texture.frame.y = 0;
    texture.frame.width = frameWidth;
    texture.frame.height = frameHeight;
    texture.updateUvs();
    this._poolKeyHash[texture.uid] = key;
    return texture;
  }
  getSameSizeTexture(texture, antialias = false) {
    const source = texture.source;
    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);
  }
  returnTexture(renderTexture, resetStyle = false) {
    const key = this._poolKeyHash[renderTexture.uid];
    if (resetStyle) {
      renderTexture.source.style = this.textureStyle;
    }
    this._texturePool[key].push(renderTexture);
  }
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i2 in this._texturePool) {
        const textures = this._texturePool[i2];
        if (textures) {
          for (let j2 = 0;j2 < textures.length; j2++) {
            textures[j2].destroy(true);
          }
        }
      }
    }
    this._texturePool = {};
  }
}
var count = 0, TexturePool;
var init_TexturePool = __esm(() => {
  init_pow2();
  init_GlobalResourceRegistry();
  init_TextureSource();
  init_Texture();
  init_TextureStyle();
  TexturePool = new TexturePoolClass;
  GlobalResourceRegistry.register(TexturePool);
});

// node_modules/pixi.js/lib/scene/container/RenderGroup.mjs
class RenderGroup {
  constructor() {
    this.renderPipeId = "renderGroup";
    this.root = null;
    this.canBundle = false;
    this.renderGroupParent = null;
    this.renderGroupChildren = [];
    this.worldTransform = new Matrix;
    this.worldColorAlpha = 4294967295;
    this.worldColor = 16777215;
    this.worldAlpha = 1;
    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
    this.updateTick = 0;
    this.gcTick = 0;
    this.childrenRenderablesToUpdate = { list: [], index: 0 };
    this.structureDidChange = true;
    this.instructionSet = new InstructionSet;
    this._onRenderContainers = [];
    this.textureNeedsUpdate = true;
    this.isCachedAsTexture = false;
    this._matrixDirty = 7;
  }
  init(root) {
    this.root = root;
    if (root._onRender)
      this.addOnRender(root);
    root.didChange = true;
    const children = root.children;
    for (let i2 = 0;i2 < children.length; i2++) {
      const child = children[i2];
      child._updateFlags = 15;
      this.addChild(child);
    }
  }
  enableCacheAsTexture(options = {}) {
    this.textureOptions = options;
    this.isCachedAsTexture = true;
    this.textureNeedsUpdate = true;
  }
  disableCacheAsTexture() {
    this.isCachedAsTexture = false;
    if (this.texture) {
      TexturePool.returnTexture(this.texture, true);
      this.texture = null;
    }
  }
  updateCacheTexture() {
    this.textureNeedsUpdate = true;
    const cachedParent = this._parentCacheAsTextureRenderGroup;
    if (cachedParent && !cachedParent.textureNeedsUpdate) {
      cachedParent.updateCacheTexture();
    }
  }
  reset() {
    this.renderGroupChildren.length = 0;
    for (const i2 in this.childrenToUpdate) {
      const childrenAtDepth = this.childrenToUpdate[i2];
      childrenAtDepth.list.fill(null);
      childrenAtDepth.index = 0;
    }
    this.childrenRenderablesToUpdate.index = 0;
    this.childrenRenderablesToUpdate.list.fill(null);
    this.root = null;
    this.updateTick = 0;
    this.structureDidChange = true;
    this._onRenderContainers.length = 0;
    this.renderGroupParent = null;
    this.disableCacheAsTexture();
  }
  get localTransform() {
    return this.root.localTransform;
  }
  addRenderGroupChild(renderGroupChild) {
    if (renderGroupChild.renderGroupParent) {
      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
    }
    renderGroupChild.renderGroupParent = this;
    this.renderGroupChildren.push(renderGroupChild);
  }
  _removeRenderGroupChild(renderGroupChild) {
    const index = this.renderGroupChildren.indexOf(renderGroupChild);
    if (index > -1) {
      this.renderGroupChildren.splice(index, 1);
    }
    renderGroupChild.renderGroupParent = null;
  }
  addChild(child) {
    this.structureDidChange = true;
    child.parentRenderGroup = this;
    child.updateTick = -1;
    if (child.parent === this.root) {
      child.relativeRenderGroupDepth = 1;
    } else {
      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
    }
    child.didChange = true;
    this.onChildUpdate(child);
    if (child.renderGroup) {
      this.addRenderGroupChild(child.renderGroup);
      return;
    }
    if (child._onRender)
      this.addOnRender(child);
    const children = child.children;
    for (let i2 = 0;i2 < children.length; i2++) {
      this.addChild(children[i2]);
    }
  }
  removeChild(child) {
    this.structureDidChange = true;
    if (child._onRender) {
      if (!child.renderGroup) {
        this.removeOnRender(child);
      }
    }
    child.parentRenderGroup = null;
    if (child.renderGroup) {
      this._removeRenderGroupChild(child.renderGroup);
      return;
    }
    const children = child.children;
    for (let i2 = 0;i2 < children.length; i2++) {
      this.removeChild(children[i2]);
    }
  }
  removeChildren(children) {
    for (let i2 = 0;i2 < children.length; i2++) {
      this.removeChild(children[i2]);
    }
  }
  onChildUpdate(child) {
    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
    if (!childrenToUpdate) {
      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      };
    }
    childrenToUpdate.list[childrenToUpdate.index++] = child;
  }
  updateRenderable(renderable) {
    if (renderable.globalDisplayStatus < 7)
      return;
    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
    renderable.didViewUpdate = false;
  }
  onChildViewUpdate(child) {
    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
  }
  get isRenderable() {
    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
  }
  addOnRender(container) {
    this._onRenderContainers.push(container);
  }
  removeOnRender(container) {
    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
  }
  runOnRender(renderer) {
    for (let i2 = 0;i2 < this._onRenderContainers.length; i2++) {
      this._onRenderContainers[i2]._onRender(renderer);
    }
  }
  destroy() {
    this.disableCacheAsTexture();
    this.renderGroupParent = null;
    this.root = null;
    this.childrenRenderablesToUpdate = null;
    this.childrenToUpdate = null;
    this.renderGroupChildren = null;
    this._onRenderContainers = null;
    this.instructionSet = null;
  }
  getChildren(out = []) {
    const children = this.root.children;
    for (let i2 = 0;i2 < children.length; i2++) {
      this._getChildren(children[i2], out);
    }
    return out;
  }
  _getChildren(container, out = []) {
    out.push(container);
    if (container.renderGroup)
      return out;
    const children = container.children;
    for (let i2 = 0;i2 < children.length; i2++) {
      this._getChildren(children[i2], out);
    }
    return out;
  }
  invalidateMatrices() {
    this._matrixDirty = 7;
  }
  get inverseWorldTransform() {
    if ((this._matrixDirty & 1) === 0)
      return this._inverseWorldTransform;
    this._matrixDirty &= ~1;
    this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix);
    return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
  }
  get textureOffsetInverseTransform() {
    if ((this._matrixDirty & 2) === 0)
      return this._textureOffsetInverseTransform;
    this._matrixDirty &= ~2;
    this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix);
    return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y);
  }
  get inverseParentTextureTransform() {
    if ((this._matrixDirty & 4) === 0)
      return this._inverseParentTextureTransform;
    this._matrixDirty &= ~4;
    const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
    if (parentCacheAsTexture) {
      this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix);
      return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(-parentCacheAsTexture._textureBounds.x, -parentCacheAsTexture._textureBounds.y);
    }
    return this.worldTransform;
  }
  get cacheToLocalTransform() {
    if (this.isCachedAsTexture) {
      return this.textureOffsetInverseTransform;
    }
    if (!this._parentCacheAsTextureRenderGroup)
      return null;
    return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;
  }
}
var init_RenderGroup = __esm(() => {
  init_Matrix();
  init_InstructionSet();
  init_TexturePool();
});

// node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs
function assignWithIgnore(target, options, ignore = {}) {
  for (const key in options) {
    if (!ignore[key] && options[key] !== undefined) {
      target[key] = options[key];
    }
  }
}
var init_assignWithIgnore = () => {};

// node_modules/pixi.js/lib/scene/container/Container.mjs
var defaultSkew, defaultPivot, defaultScale, defaultOrigin, UPDATE_COLOR = 1, UPDATE_BLEND = 2, UPDATE_VISIBLE = 4, Container;
var init_Container = __esm(() => {
  init_eventemitter3();
  init_Color();
  init_cullingMixin();
  init_Extensions();
  init_Matrix();
  init_const();
  init_ObservablePoint();
  init_uid();
  init_deprecation();
  init_warn();
  init_PoolGroup();
  init_cacheAsTextureMixin();
  init_childrenHelperMixin();
  init_collectRenderablesMixin();
  init_effectsMixin();
  init_findMixin();
  init_getFastGlobalBoundsMixin();
  init_getGlobalMixin();
  init_measureMixin();
  init_onRenderMixin();
  init_sortMixin();
  init_toLocalGlobalMixin();
  init_RenderGroup();
  init_assignWithIgnore();
  defaultSkew = new ObservablePoint(null);
  defaultPivot = new ObservablePoint(null);
  defaultScale = new ObservablePoint(null, 1, 1);
  defaultOrigin = new ObservablePoint(null);
  Container = class Container extends eventemitter3_default {
    constructor(options = {}) {
      super();
      this.uid = uid("renderable");
      this._updateFlags = 15;
      this.renderGroup = null;
      this.parentRenderGroup = null;
      this.parentRenderGroupIndex = 0;
      this.didChange = false;
      this.didViewUpdate = false;
      this.relativeRenderGroupDepth = 0;
      this.children = [];
      this.parent = null;
      this.includeInBuild = true;
      this.measurable = true;
      this.isSimple = true;
      this.updateTick = -1;
      this.localTransform = new Matrix;
      this.relativeGroupTransform = new Matrix;
      this.groupTransform = this.relativeGroupTransform;
      this.destroyed = false;
      this._position = new ObservablePoint(this, 0, 0);
      this._scale = defaultScale;
      this._pivot = defaultPivot;
      this._origin = defaultOrigin;
      this._skew = defaultSkew;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this._rotation = 0;
      this.localColor = 16777215;
      this.localAlpha = 1;
      this.groupAlpha = 1;
      this.groupColor = 16777215;
      this.groupColorAlpha = 4294967295;
      this.localBlendMode = "inherit";
      this.groupBlendMode = "normal";
      this.localDisplayStatus = 7;
      this.globalDisplayStatus = 7;
      this._didContainerChangeTick = 0;
      this._didViewChangeTick = 0;
      this._didLocalTransformChangeId = -1;
      this.effects = [];
      assignWithIgnore(this, options, {
        children: true,
        parent: true,
        effects: true
      });
      options.children?.forEach((child) => this.addChild(child));
      options.parent?.addChild(this);
    }
    static mixin(source) {
      deprecation("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead.");
      extensions.mixin(Container, source);
    }
    set _didChangeId(value) {
      this._didViewChangeTick = value >> 12 & 4095;
      this._didContainerChangeTick = value & 4095;
    }
    get _didChangeId() {
      return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
    }
    addChild(...children) {
      if (!this.allowChildren) {
        deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
      }
      if (children.length > 1) {
        for (let i2 = 0;i2 < children.length; i2++) {
          this.addChild(children[i2]);
        }
        return children[0];
      }
      const child = children[0];
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (child.parent === this) {
        this.children.splice(this.children.indexOf(child), 1);
        this.children.push(child);
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
        return child;
      }
      if (child.parent) {
        child.parent.removeChild(child);
      }
      this.children.push(child);
      if (this.sortableChildren)
        this.sortDirty = true;
      child.parent = this;
      child.didChange = true;
      child._updateFlags = 15;
      if (renderGroup) {
        renderGroup.addChild(child);
      }
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
      this._didViewChangeTick++;
      if (child._zIndex !== 0) {
        child.depthOfChildModified();
      }
      return child;
    }
    removeChild(...children) {
      if (children.length > 1) {
        for (let i2 = 0;i2 < children.length; i2++) {
          this.removeChild(children[i2]);
        }
        return children[0];
      }
      const child = children[0];
      const index = this.children.indexOf(child);
      if (index > -1) {
        this._didViewChangeTick++;
        this.children.splice(index, 1);
        if (this.renderGroup) {
          this.renderGroup.removeChild(child);
        } else if (this.parentRenderGroup) {
          this.parentRenderGroup.removeChild(child);
        }
        if (child.parentRenderLayer) {
          child.parentRenderLayer.detach(child);
        }
        child.parent = null;
        this.emit("childRemoved", child, this, index);
        child.emit("removed", this);
      }
      return child;
    }
    _onUpdate(point) {
      if (point) {
        if (point === this._skew) {
          this._updateSkew();
        }
      }
      this._didContainerChangeTick++;
      if (this.didChange)
        return;
      this.didChange = true;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.onChildUpdate(this);
      }
    }
    set isRenderGroup(value) {
      if (!!this.renderGroup === value)
        return;
      if (value) {
        this.enableRenderGroup();
      } else {
        this.disableRenderGroup();
      }
    }
    get isRenderGroup() {
      return !!this.renderGroup;
    }
    enableRenderGroup() {
      if (this.renderGroup)
        return;
      const parentRenderGroup = this.parentRenderGroup;
      parentRenderGroup?.removeChild(this);
      this.renderGroup = BigPool.get(RenderGroup, this);
      this.groupTransform = Matrix.IDENTITY;
      parentRenderGroup?.addChild(this);
      this._updateIsSimple();
    }
    disableRenderGroup() {
      if (!this.renderGroup)
        return;
      const parentRenderGroup = this.parentRenderGroup;
      parentRenderGroup?.removeChild(this);
      BigPool.return(this.renderGroup);
      this.renderGroup = null;
      this.groupTransform = this.relativeGroupTransform;
      parentRenderGroup?.addChild(this);
      this._updateIsSimple();
    }
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
      this._worldTransform || (this._worldTransform = new Matrix);
      if (this.renderGroup) {
        this._worldTransform.copyFrom(this.renderGroup.worldTransform);
      } else if (this.parentRenderGroup) {
        this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
      }
      return this._worldTransform;
    }
    get x() {
      return this._position.x;
    }
    set x(value) {
      this._position.x = value;
    }
    get y() {
      return this._position.y;
    }
    set y(value) {
      this._position.y = value;
    }
    get position() {
      return this._position;
    }
    set position(value) {
      this._position.copyFrom(value);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this._onUpdate(this._skew);
      }
    }
    get angle() {
      return this.rotation * RAD_TO_DEG;
    }
    set angle(value) {
      this.rotation = value * DEG_TO_RAD;
    }
    get pivot() {
      if (this._pivot === defaultPivot) {
        this._pivot = new ObservablePoint(this, 0, 0);
      }
      return this._pivot;
    }
    set pivot(value) {
      if (this._pivot === defaultPivot) {
        this._pivot = new ObservablePoint(this, 0, 0);
        if (this._origin !== defaultOrigin) {
          warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
        }
      }
      typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
    }
    get skew() {
      if (this._skew === defaultSkew) {
        this._skew = new ObservablePoint(this, 0, 0);
      }
      return this._skew;
    }
    set skew(value) {
      if (this._skew === defaultSkew) {
        this._skew = new ObservablePoint(this, 0, 0);
      }
      this._skew.copyFrom(value);
    }
    get scale() {
      if (this._scale === defaultScale) {
        this._scale = new ObservablePoint(this, 1, 1);
      }
      return this._scale;
    }
    set scale(value) {
      if (this._scale === defaultScale) {
        this._scale = new ObservablePoint(this, 0, 0);
      }
      if (typeof value === "string") {
        value = parseFloat(value);
      }
      typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
    }
    get origin() {
      if (this._origin === defaultOrigin) {
        this._origin = new ObservablePoint(this, 0, 0);
      }
      return this._origin;
    }
    set origin(value) {
      if (this._origin === defaultOrigin) {
        this._origin = new ObservablePoint(this, 0, 0);
        if (this._pivot !== defaultPivot) {
          warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
        }
      }
      typeof value === "number" ? this._origin.set(value) : this._origin.copyFrom(value);
    }
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(value) {
      const localWidth = this.getLocalBounds().width;
      this._setWidth(value, localWidth);
    }
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(value) {
      const localHeight = this.getLocalBounds().height;
      this._setHeight(value, localHeight);
    }
    getSize(out) {
      if (!out) {
        out = {};
      }
      const bounds = this.getLocalBounds();
      out.width = Math.abs(this.scale.x * bounds.width);
      out.height = Math.abs(this.scale.y * bounds.height);
      return out;
    }
    setSize(value, height) {
      const size = this.getLocalBounds();
      if (typeof value === "object") {
        height = value.height ?? value.width;
        value = value.width;
      } else {
        height ?? (height = value);
      }
      value !== undefined && this._setWidth(value, size.width);
      height !== undefined && this._setHeight(height, size.height);
    }
    _updateSkew() {
      const rotation = this._rotation;
      const skew = this._skew;
      this._cx = Math.cos(rotation + skew._y);
      this._sx = Math.sin(rotation + skew._y);
      this._cy = -Math.sin(rotation - skew._x);
      this._sy = Math.cos(rotation - skew._x);
    }
    updateTransform(opts) {
      this.position.set(typeof opts.x === "number" ? opts.x : this.position.x, typeof opts.y === "number" ? opts.y : this.position.y);
      this.scale.set(typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x, typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y);
      this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
      this.skew.set(typeof opts.skewX === "number" ? opts.skewX : this.skew.x, typeof opts.skewY === "number" ? opts.skewY : this.skew.y);
      this.pivot.set(typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x, typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y);
      this.origin.set(typeof opts.originX === "number" ? opts.originX : this.origin.x, typeof opts.originY === "number" ? opts.originY : this.origin.y);
      return this;
    }
    setFromMatrix(matrix) {
      matrix.decompose(this);
    }
    updateLocalTransform() {
      const localTransformChangeId = this._didContainerChangeTick;
      if (this._didLocalTransformChangeId === localTransformChangeId)
        return;
      this._didLocalTransformChangeId = localTransformChangeId;
      const lt = this.localTransform;
      const scale = this._scale;
      const pivot = this._pivot;
      const origin = this._origin;
      const position = this._position;
      const sx = scale._x;
      const sy = scale._y;
      const px = pivot._x;
      const py = pivot._y;
      const ox = -origin._x;
      const oy = -origin._y;
      lt.a = this._cx * sx;
      lt.b = this._sx * sx;
      lt.c = this._cy * sy;
      lt.d = this._sy * sy;
      lt.tx = position._x - (px * lt.a + py * lt.c) + (ox * lt.a + oy * lt.c) - ox;
      lt.ty = position._y - (px * lt.b + py * lt.d) + (ox * lt.b + oy * lt.d) - oy;
    }
    set alpha(value) {
      if (value === this.localAlpha)
        return;
      this.localAlpha = value;
      this._updateFlags |= UPDATE_COLOR;
      this._onUpdate();
    }
    get alpha() {
      return this.localAlpha;
    }
    set tint(value) {
      const tempColor = Color.shared.setValue(value ?? 16777215);
      const bgr = tempColor.toBgrNumber();
      if (bgr === this.localColor)
        return;
      this.localColor = bgr;
      this._updateFlags |= UPDATE_COLOR;
      this._onUpdate();
    }
    get tint() {
      return bgr2rgb(this.localColor);
    }
    set blendMode(value) {
      if (this.localBlendMode === value)
        return;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._updateFlags |= UPDATE_BLEND;
      this.localBlendMode = value;
      this._onUpdate();
    }
    get blendMode() {
      return this.localBlendMode;
    }
    get visible() {
      return !!(this.localDisplayStatus & 2);
    }
    set visible(value) {
      const valueNumber = value ? 2 : 0;
      if ((this.localDisplayStatus & 2) === valueNumber)
        return;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._updateFlags |= UPDATE_VISIBLE;
      this.localDisplayStatus ^= 2;
      this._onUpdate();
    }
    get culled() {
      return !(this.localDisplayStatus & 4);
    }
    set culled(value) {
      const valueNumber = value ? 0 : 4;
      if ((this.localDisplayStatus & 4) === valueNumber)
        return;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._updateFlags |= UPDATE_VISIBLE;
      this.localDisplayStatus ^= 4;
      this._onUpdate();
    }
    get renderable() {
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(value) {
      const valueNumber = value ? 1 : 0;
      if ((this.localDisplayStatus & 1) === valueNumber)
        return;
      this._updateFlags |= UPDATE_VISIBLE;
      this.localDisplayStatus ^= 1;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._onUpdate();
    }
    get isRenderable() {
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(options = false) {
      if (this.destroyed)
        return;
      this.destroyed = true;
      let oldChildren;
      if (this.children.length) {
        oldChildren = this.removeChildren(0, this.children.length);
      }
      this.removeFromParent();
      this.parent = null;
      this._maskEffect = null;
      this._filterEffect = null;
      this.effects = null;
      this._position = null;
      this._scale = null;
      this._pivot = null;
      this._origin = null;
      this._skew = null;
      this.emit("destroyed", this);
      this.removeAllListeners();
      const destroyChildren = typeof options === "boolean" ? options : options?.children;
      if (destroyChildren && oldChildren) {
        for (let i2 = 0;i2 < oldChildren.length; ++i2) {
          oldChildren[i2].destroy(options);
        }
      }
      this.renderGroup?.destroy();
      this.renderGroup = null;
    }
  };
  extensions.mixin(Container, childrenHelperMixin, getFastGlobalBoundsMixin, toLocalGlobalMixin, onRenderMixin, measureMixin, effectsMixin, findMixin, sortMixin, cullingMixin, cacheAsTextureMixin, getGlobalMixin, collectRenderablesMixin);
});

// node_modules/pixi.js/lib/ticker/const.mjs
var UPDATE_PRIORITY;
var init_const2 = __esm(() => {
  UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
    return UPDATE_PRIORITY2;
  })(UPDATE_PRIORITY || {});
});

// node_modules/pixi.js/lib/ticker/TickerListener.mjs
class TickerListener {
  constructor(fn, context = null, priority = 0, once = false) {
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this._fn = fn;
    this._context = context;
    this.priority = priority;
    this._once = once;
  }
  match(fn, context = null) {
    return this._fn === fn && this._context === context;
  }
  emit(ticker) {
    if (this._fn) {
      if (this._context) {
        this._fn.call(this._context, ticker);
      } else {
        this._fn(ticker);
      }
    }
    const redirect = this.next;
    if (this._once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  destroy(hard = false) {
    this._destroyed = true;
    this._fn = null;
    this._context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}
var init_TickerListener = () => {};

// node_modules/pixi.js/lib/ticker/Ticker.mjs
var _Ticker = class _Ticker2 {
  constructor() {
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker2.targetFPMS;
    this.elapsedMS = 1 / _Ticker2.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context, priority));
  }
  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context, priority, true));
  }
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  remove(fn, context) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  get count() {
    if (!this._head) {
      return 0;
    }
    let count2 = 0;
    let current = this._head;
    while (current = current.next) {
      count2++;
    }
    return count2;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  get FPS() {
    return 1000 / this.elapsedMS;
  }
  get minFPS() {
    return 1000 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1000, _Ticker2.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1000 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1000);
    }
  }
  static get shared() {
    if (!_Ticker2._shared) {
      const shared = _Ticker2._shared = new _Ticker2;
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker2._shared;
  }
  static get system() {
    if (!_Ticker2._system) {
      const system = _Ticker2._system = new _Ticker2;
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker2._system;
  }
}, Ticker;
var init_Ticker = __esm(() => {
  init_const2();
  init_TickerListener();
  _Ticker.targetFPMS = 0.06;
  Ticker = _Ticker;
});

// node_modules/pixi.js/lib/dom/CanvasObserver.mjs
class CanvasObserver {
  constructor(options) {
    this._lastTransform = "";
    this._observer = null;
    this._tickerAttached = false;
    this.updateTranslation = () => {
      if (!this._canvas)
        return;
      const rect = this._canvas.getBoundingClientRect();
      const contentWidth = this._canvas.width;
      const contentHeight = this._canvas.height;
      const sx = rect.width / contentWidth * this._renderer.resolution;
      const sy = rect.height / contentHeight * this._renderer.resolution;
      const tx = rect.left;
      const ty = rect.top;
      const newTransform = `translate(${tx}px, ${ty}px) scale(${sx}, ${sy})`;
      if (newTransform !== this._lastTransform) {
        this._domElement.style.transform = newTransform;
        this._lastTransform = newTransform;
      }
    };
    this._domElement = options.domElement;
    this._renderer = options.renderer;
    if (globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas)
      return;
    this._canvas = this._renderer.canvas;
    this._attachObserver();
  }
  get canvas() {
    return this._canvas;
  }
  ensureAttached() {
    if (!this._domElement.parentNode && this._canvas.parentNode) {
      this._canvas.parentNode.appendChild(this._domElement);
      this.updateTranslation();
    }
  }
  _attachObserver() {
    if ("ResizeObserver" in globalThis) {
      if (this._observer) {
        this._observer.disconnect();
        this._observer = null;
      }
      this._observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.target !== this._canvas) {
            continue;
          }
          const contentWidth = this.canvas.width;
          const contentHeight = this.canvas.height;
          const sx = entry.contentRect.width / contentWidth * this._renderer.resolution;
          const sy = entry.contentRect.height / contentHeight * this._renderer.resolution;
          const needsUpdate = this._lastScaleX !== sx || this._lastScaleY !== sy;
          if (needsUpdate) {
            this.updateTranslation();
            this._lastScaleX = sx;
            this._lastScaleY = sy;
          }
        }
      });
      this._observer.observe(this._canvas);
    } else if (!this._tickerAttached) {
      Ticker.shared.add(this.updateTranslation, this, UPDATE_PRIORITY.HIGH);
    }
  }
  destroy() {
    if (this._observer) {
      this._observer.disconnect();
      this._observer = null;
    } else if (this._tickerAttached) {
      Ticker.shared.remove(this.updateTranslation);
    }
    this._domElement = null;
    this._renderer = null;
    this._canvas = null;
    this._tickerAttached = false;
    this._lastTransform = "";
    this._lastScaleX = null;
    this._lastScaleY = null;
  }
}
var init_CanvasObserver = __esm(() => {
  init_const2();
  init_Ticker();
});

// node_modules/pixi.js/lib/events/FederatedEvent.mjs
class FederatedEvent {
  constructor(manager) {
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.composed = false;
    this.defaultPrevented = false;
    this.eventPhase = FederatedEvent.prototype.NONE;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new Point;
    this.page = new Point;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get data() {
    return this;
  }
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
}
var init_FederatedEvent = __esm(() => {
  init_Point();
});

// node_modules/ismobilejs/esm/isMobile.js
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
var init_isMobile = __esm(() => {
  appleIphone = /iPhone/i;
  appleIpod = /iPod/i;
  appleTablet = /iPad/i;
  appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
  androidPhone = /\bAndroid(?:.+)Mobile\b/i;
  androidTablet = /Android/i;
  amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
  amazonTablet = /Silk/i;
  windowsPhone = /Windows Phone/i;
  windowsTablet = /\bWindows(?:.+)ARM\b/i;
  otherBlackBerry = /BlackBerry/i;
  otherBlackBerry10 = /BB10/i;
  otherOpera = /Opera Mini/i;
  otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
  otherFirefox = /Mobile(?:.+)Firefox\b/i;
});

// node_modules/ismobilejs/esm/index.js
var init_esm = __esm(() => {
  init_isMobile();
  init_isMobile();
});

// node_modules/pixi.js/lib/utils/browser/isMobile.mjs
var isMobileCall, isMobile3;
var init_isMobile2 = __esm(() => {
  init_esm();
  isMobileCall = isMobile.default ?? isMobile;
  isMobile3 = isMobileCall(globalThis.navigator);
});

// node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
var KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1000, DIV_HOOK_POS_Y = -1000, DIV_HOOK_ZINDEX = 2, _AccessibilitySystem = class _AccessibilitySystem2 {
  constructor(renderer, _mobileInfo = isMobile3) {
    this._mobileInfo = _mobileInfo;
    this.debug = false;
    this._activateOnTab = true;
    this._deactivateOnMouseMove = true;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this._div = null;
    this._pool = [];
    this._renderId = 0;
    this._children = [];
    this._androidUpdateCount = 0;
    this._androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (_mobileInfo.tablet || _mobileInfo.phone) {
      this._createTouchHook();
    }
    this._renderer = renderer;
  }
  get isActive() {
    return this._isActive;
  }
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  get hookDiv() {
    return this._hookDiv;
  }
  _createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this._activate();
      this._destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  _destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  _activate() {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    if (!this._div) {
      this._div = document.createElement("div");
      this._div.style.position = "absolute";
      this._div.style.top = `${DIV_TOUCH_POS_X}px`;
      this._div.style.left = `${DIV_TOUCH_POS_Y}px`;
      this._div.style.pointerEvents = "none";
      this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      this._canvasObserver = new CanvasObserver({
        domElement: this._div,
        renderer: this._renderer
      });
    }
    if (this._activateOnTab) {
      this._onKeyDown = this._onKeyDown.bind(this);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    if (this._deactivateOnMouseMove) {
      this._onMouseMove = this._onMouseMove.bind(this);
      globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    }
    const canvas = this._renderer.view.canvas;
    if (!canvas.parentNode) {
      const observer = new MutationObserver(() => {
        if (canvas.parentNode) {
          observer.disconnect();
          this._canvasObserver.ensureAttached();
          this._initAccessibilitySetup();
        }
      });
      observer.observe(document.body, { childList: true, subtree: true });
    } else {
      this._canvasObserver.ensureAttached();
      this._initAccessibilitySetup();
    }
  }
  _initAccessibilitySetup() {
    this._renderer.runners.postrender.add(this);
    if (this._renderer.lastObjectRendered) {
      this._updateAccessibleObjects(this._renderer.lastObjectRendered);
    }
  }
  _deactivate() {
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    if (this._activateOnTab) {
      globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    this._renderer.runners.postrender.remove(this);
    for (const child of this._children) {
      if (child._accessibleDiv && child._accessibleDiv.parentNode) {
        child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
        child._accessibleDiv = null;
      }
      child._accessibleActive = false;
    }
    this._pool.forEach((div) => {
      if (div.parentNode) {
        div.parentNode.removeChild(div);
      }
    });
    if (this._div && this._div.parentNode) {
      this._div.parentNode.removeChild(this._div);
    }
    this._pool = [];
    this._children = [];
  }
  _updateAccessibleObjects(container) {
    if (!container.visible || !container.accessibleChildren) {
      return;
    }
    if (container.accessible) {
      if (!container._accessibleActive) {
        this._addChild(container);
      }
      container._renderId = this._renderId;
    }
    const children = container.children;
    if (children) {
      for (let i2 = 0;i2 < children.length; i2++) {
        this._updateAccessibleObjects(children[i2]);
      }
    }
  }
  init(options) {
    const defaultOpts = _AccessibilitySystem2.defaultOptions;
    const mergedOptions = {
      accessibilityOptions: {
        ...defaultOpts,
        ...options?.accessibilityOptions || {}
      }
    };
    this.debug = mergedOptions.accessibilityOptions.debug;
    this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;
    this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;
    if (mergedOptions.accessibilityOptions.enabledByDefault) {
      this._activate();
    } else if (this._activateOnTab) {
      this._onKeyDown = this._onKeyDown.bind(this);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    this._renderer.runners.postrender.remove(this);
  }
  postrender() {
    const now = performance.now();
    if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
      return;
    }
    this._androidUpdateCount = now + this._androidUpdateFrequency;
    if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
      return;
    }
    const activeIds = /* @__PURE__ */ new Set;
    if (this._renderer.lastObjectRendered) {
      this._updateAccessibleObjects(this._renderer.lastObjectRendered);
      for (const child of this._children) {
        if (child._renderId === this._renderId) {
          activeIds.add(this._children.indexOf(child));
        }
      }
    }
    for (let i2 = this._children.length - 1;i2 >= 0; i2--) {
      const child = this._children[i2];
      if (!activeIds.has(i2)) {
        if (child._accessibleDiv && child._accessibleDiv.parentNode) {
          child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
          this._pool.push(child._accessibleDiv);
          child._accessibleDiv = null;
        }
        child._accessibleActive = false;
        removeItems(this._children, i2, 1);
      }
    }
    if (this._renderer.renderingToScreen) {
      this._canvasObserver.ensureAttached();
    }
    for (let i2 = 0;i2 < this._children.length; i2++) {
      const child = this._children[i2];
      if (!child._accessibleActive || !child._accessibleDiv) {
        continue;
      }
      const div = child._accessibleDiv;
      const hitArea = child.hitArea || child.getBounds().rectangle;
      if (child.hitArea) {
        const wt = child.worldTransform;
        div.style.left = `${wt.tx + hitArea.x * wt.a}px`;
        div.style.top = `${wt.ty + hitArea.y * wt.d}px`;
        div.style.width = `${hitArea.width * wt.a}px`;
        div.style.height = `${hitArea.height * wt.d}px`;
      } else {
        this._capHitArea(hitArea);
        div.style.left = `${hitArea.x}px`;
        div.style.top = `${hitArea.y}px`;
        div.style.width = `${hitArea.width}px`;
        div.style.height = `${hitArea.height}px`;
      }
    }
    this._renderId++;
  }
  _updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  _capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this._renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  _addChild(container) {
    let div = this._pool.pop();
    if (!div) {
      if (container.accessibleType === "button") {
        div = document.createElement("button");
      } else {
        div = document.createElement(container.accessibleType);
        div.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `;
        if (container.accessibleText) {
          div.innerText = container.accessibleText;
        }
      }
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = container.accessiblePointerEvents;
    div.type = container.accessibleType;
    if (container.accessibleTitle && container.accessibleTitle !== null) {
      div.title = container.accessibleTitle;
    } else if (!container.accessibleHint || container.accessibleHint === null) {
      div.title = `container ${container.tabIndex}`;
    }
    if (container.accessibleHint && container.accessibleHint !== null) {
      div.setAttribute("aria-label", container.accessibleHint);
    }
    if (container.interactive) {
      div.tabIndex = container.tabIndex;
    } else {
      div.tabIndex = 0;
    }
    if (this.debug) {
      this._updateDebugHTML(div);
    }
    container._accessibleActive = true;
    container._accessibleDiv = div;
    div.container = container;
    this._children.push(container);
    this._div.appendChild(container._accessibleDiv);
  }
  _dispatchEvent(e2, type) {
    const { container: target } = e2.target;
    const boundary = this._renderer.events.rootBoundary;
    const event = Object.assign(new FederatedEvent(boundary), { target });
    boundary.rootTarget = this._renderer.lastObjectRendered;
    type.forEach((type2) => boundary.dispatchEvent(event, type2));
  }
  _onClick(e2) {
    this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
  }
  _onFocus(e2) {
    if (!e2.target.getAttribute("aria-live")) {
      e2.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e2, ["mouseover"]);
  }
  _onFocusOut(e2) {
    if (!e2.target.getAttribute("aria-live")) {
      e2.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e2, ["mouseout"]);
  }
  _onKeyDown(e2) {
    if (e2.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {
      return;
    }
    this._activate();
  }
  _onMouseMove(e2) {
    if (e2.movementX === 0 && e2.movementY === 0) {
      return;
    }
    this._deactivate();
  }
  destroy() {
    this._deactivate();
    this._destroyTouchHook();
    this._canvasObserver?.destroy();
    this._canvasObserver = null;
    this._div = null;
    this._pool = null;
    this._children = null;
    this._renderer = null;
    if (this._activateOnTab) {
      globalThis.removeEventListener("keydown", this._onKeyDown);
    }
  }
  setAccessibilityEnabled(enabled) {
    if (enabled) {
      this._activate();
    } else {
      this._deactivate();
    }
  }
}, AccessibilitySystem;
var init_AccessibilitySystem = __esm(() => {
  init_CanvasObserver();
  init_FederatedEvent();
  init_Extensions();
  init_isMobile2();
  init_removeItems();
  _AccessibilitySystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "accessibility"
  };
  _AccessibilitySystem.defaultOptions = {
    enabledByDefault: false,
    debug: false,
    activateOnTab: true,
    deactivateOnMouseMove: true
  };
  AccessibilitySystem = _AccessibilitySystem;
});

// node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
var accessibilityTarget;
var init_accessibilityTarget = __esm(() => {
  accessibilityTarget = {
    accessible: false,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    accessibleType: "button",
    accessibleText: null,
    accessiblePointerEvents: "auto",
    accessibleChildren: true,
    _accessibleActive: false,
    _accessibleDiv: null,
    _renderId: -1
  };
});

// node_modules/pixi.js/lib/accessibility/init.mjs
var init_init = __esm(() => {
  init_Extensions();
  init_Container();
  init_AccessibilitySystem();
  init_accessibilityTarget();
  extensions.add(AccessibilitySystem);
  extensions.mixin(Container, accessibilityTarget);
});

// node_modules/pixi.js/lib/app/ResizePlugin.mjs
class ResizePlugin {
  static init(options) {
    Object.defineProperty(this, "resizeTo", {
      set(dom) {
        globalThis.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          globalThis.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get() {
        return this._resizeTo;
      }
    });
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this._cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this._cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this._cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  }
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this._cancelResize();
    this._cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
var init_ResizePlugin = __esm(() => {
  init_Extensions();
  ResizePlugin.extension = ExtensionType.Application;
});

// node_modules/pixi.js/lib/app/TickerPlugin.mjs
class TickerPlugin {
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
        }
      },
      get() {
        return this._ticker;
      }
    });
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker;
    if (options.autoStart) {
      this.start();
    }
  }
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
var init_TickerPlugin = __esm(() => {
  init_Extensions();
  init_const2();
  init_Ticker();
  TickerPlugin.extension = ExtensionType.Application;
});

// node_modules/pixi.js/lib/app/init.mjs
var init_init2 = __esm(() => {
  init_Extensions();
  init_ResizePlugin();
  init_TickerPlugin();
  extensions.add(ResizePlugin);
  extensions.add(TickerPlugin);
});

// node_modules/pixi.js/lib/events/EventTicker.mjs
class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this._tickerAdded = false;
    this._pauseUpdate = true;
  }
  init(events) {
    this.removeTickerListener();
    this.events = events;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this._tickerAdded = false;
    this._pauseUpdate = true;
  }
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  addTickerListener() {
    if (this._tickerAdded || !this.domElement) {
      return;
    }
    Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this._tickerAdded = true;
  }
  removeTickerListener() {
    if (!this._tickerAdded) {
      return;
    }
    Ticker.system.remove(this._tickerUpdate, this);
    this._tickerAdded = false;
  }
  pointerMoved() {
    this._didMove = true;
  }
  _update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["_rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY,
      pointerType: rootPointerEvent.pointerType,
      pointerId: rootPointerEvent.pointerId
    }) : new MouseEvent("mousemove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  _tickerUpdate(ticker) {
    this._deltaTime += ticker.deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this._update();
  }
  destroy() {
    this.removeTickerListener();
    this.events = null;
    this.domElement = null;
    this._deltaTime = 0;
    this._didMove = false;
    this._tickerAdded = false;
    this._pauseUpdate = true;
  }
}
var EventsTicker;
var init_EventTicker = __esm(() => {
  init_const2();
  init_Ticker();
  EventsTicker = new EventsTickerClass;
});

// node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
var FederatedMouseEvent;
var init_FederatedMouseEvent = __esm(() => {
  init_Point();
  init_FederatedEvent();
  FederatedMouseEvent = class FederatedMouseEvent extends FederatedEvent {
    constructor() {
      super(...arguments);
      this.client = new Point;
      this.movement = new Point;
      this.offset = new Point;
      this.global = new Point;
      this.screen = new Point;
    }
    get clientX() {
      return this.client.x;
    }
    get clientY() {
      return this.client.y;
    }
    get x() {
      return this.clientX;
    }
    get y() {
      return this.clientY;
    }
    get movementX() {
      return this.movement.x;
    }
    get movementY() {
      return this.movement.y;
    }
    get offsetX() {
      return this.offset.x;
    }
    get offsetY() {
      return this.offset.y;
    }
    get globalX() {
      return this.global.x;
    }
    get globalY() {
      return this.global.y;
    }
    get screenX() {
      return this.screen.x;
    }
    get screenY() {
      return this.screen.y;
    }
    getLocalPosition(container, point, globalPos) {
      return container.worldTransform.applyInverse(globalPos || this.global, point);
    }
    getModifierState(key) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
    initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
      throw new Error("Method not implemented.");
    }
  };
});

// node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
var FederatedPointerEvent;
var init_FederatedPointerEvent = __esm(() => {
  init_FederatedMouseEvent();
  FederatedPointerEvent = class FederatedPointerEvent extends FederatedMouseEvent {
    constructor() {
      super(...arguments);
      this.width = 0;
      this.height = 0;
      this.isPrimary = false;
    }
    getCoalescedEvents() {
      if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
        return [this];
      }
      return [];
    }
    getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
  };
});

// node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
var FederatedWheelEvent;
var init_FederatedWheelEvent = __esm(() => {
  init_FederatedMouseEvent();
  FederatedWheelEvent = class FederatedWheelEvent extends FederatedMouseEvent {
    constructor() {
      super(...arguments);
      this.DOM_DELTA_PIXEL = 0;
      this.DOM_DELTA_LINE = 1;
      this.DOM_DELTA_PAGE = 2;
    }
  };
  FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
  FederatedWheelEvent.DOM_DELTA_LINE = 1;
  FederatedWheelEvent.DOM_DELTA_PAGE = 2;
});

// node_modules/pixi.js/lib/events/EventBoundary.mjs
class EventBoundary {
  constructor(rootTarget) {
    this.dispatch = new eventemitter3_default;
    this.moveOnAll = false;
    this.enableGlobalMoveEvents = true;
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map;
    this._allInteractiveElements = [];
    this._hitElements = [];
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
  }
  dispatchEvent(e2, type) {
    e2.propagationStopped = false;
    e2.propagationImmediatelyStopped = false;
    this.propagate(e2, type);
    this.dispatch.emit(type || e2.type, e2);
  }
  mapEvent(e2) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e2.type];
    if (mappers) {
      for (let i2 = 0, j2 = mappers.length;i2 < j2; i2++) {
        mappers[i2].fn(e2);
      }
    } else {
      warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
    }
  }
  hitTest(x2, y2) {
    EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x2, y2), this.hitTestFn, this.hitPruneFn);
    return invertedPath && invertedPath[0];
  }
  propagate(e2, type) {
    if (!e2.target) {
      return;
    }
    const composedPath = e2.composedPath();
    e2.eventPhase = e2.CAPTURING_PHASE;
    for (let i2 = 0, j2 = composedPath.length - 1;i2 < j2; i2++) {
      e2.currentTarget = composedPath[i2];
      this.notifyTarget(e2, type);
      if (e2.propagationStopped || e2.propagationImmediatelyStopped)
        return;
    }
    e2.eventPhase = e2.AT_TARGET;
    e2.currentTarget = e2.target;
    this.notifyTarget(e2, type);
    if (e2.propagationStopped || e2.propagationImmediatelyStopped)
      return;
    e2.eventPhase = e2.BUBBLING_PHASE;
    for (let i2 = composedPath.length - 2;i2 >= 0; i2--) {
      e2.currentTarget = composedPath[i2];
      this.notifyTarget(e2, type);
      if (e2.propagationStopped || e2.propagationImmediatelyStopped)
        return;
    }
  }
  all(e2, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e2.eventPhase = e2.BUBBLING_PHASE;
    const events = Array.isArray(type) ? type : [type];
    for (let i2 = targets.length - 1;i2 >= 0; i2--) {
      events.forEach((event) => {
        e2.currentTarget = targets[i2];
        this.notifyTarget(e2, event);
      });
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i2 = 0;i2 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i2++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location2, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i2 = children.length - 1;i2 >= 0; i2--) {
        const child = children[i2];
        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location2, testFn, pruneFn, ignore || pruneFn(currentTarget, location2));
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive)
              this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0)
            this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget)
      this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0)
      return null;
    if (shouldReturn)
      return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location2) && testFn(currentTarget, location2))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  hitTestRecursive(currentTarget, eventMode, location2, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location2)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      const relativeLocation = location2;
      for (let i2 = children.length - 1;i2 >= 0; i2--) {
        const child = children[i2];
        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, relativeLocation, testFn, pruneFn);
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive)
            nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location2)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(container) {
    if (!container || !container.visible || !container.renderable || !container.measurable) {
      return true;
    }
    if (container.eventMode === "none") {
      return true;
    }
    if (container.eventMode === "passive" && !container.interactiveChildren) {
      return true;
    }
    return false;
  }
  hitPruneFn(container, location2) {
    if (container.hitArea) {
      container.worldTransform.applyInverse(location2, tempLocalMapping);
      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (container.effects && container.effects.length) {
      for (let i2 = 0;i2 < container.effects.length; i2++) {
        const effect = container.effects[i2];
        if (effect.containsPoint) {
          const effectContainsPoint = effect.containsPoint(location2, this.hitTestFn);
          if (!effectContainsPoint) {
            return true;
          }
        }
      }
    }
    return false;
  }
  hitTestFn(container, location2) {
    if (container.hitArea) {
      return true;
    }
    if (container?.containsPoint) {
      container.worldTransform.applyInverse(location2, tempLocalMapping);
      return container.containsPoint(tempLocalMapping);
    }
    return false;
  }
  notifyTarget(e2, type) {
    if (!e2.currentTarget.isInteractive()) {
      return;
    }
    type ?? (type = e2.type);
    const handlerKey = `on${type}`;
    e2.currentTarget[handlerKey]?.(e2);
    const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
    this._notifyListeners(e2, key);
    if (e2.eventPhase === e2.AT_TARGET) {
      this._notifyListeners(e2, type);
    }
  }
  mapPointerDown(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e2 = this.createPointerEvent(from);
    this.dispatchEvent(e2, "pointerdown");
    if (e2.pointerType === "touch") {
      this.dispatchEvent(e2, "touchstart");
    } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
      const isRightButton = e2.button === 2;
      this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from.pointerId);
    trackingData.pressTargetsByButton[from.button] = e2.composedPath();
    this.freeEvent(e2);
  }
  mapPointerMove(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e2 = this.createPointerEvent(from);
    this._isPointerMoveEvent = false;
    const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
    const trackingData = this.trackingData(from.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      if (!e2.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e2.target) {
      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e2, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse)
        this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e2.target)
          break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e2, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e2.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = e2.target?.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e2, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e2.composedPath();
    this.freeEvent(e2);
  }
  mapPointerOver(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const e2 = this.createPointerEvent(from);
    const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
    this.dispatchEvent(e2, "pointerover");
    if (isMouse)
      this.dispatchEvent(e2, "mouseover");
    if (e2.pointerType === "mouse")
      this.cursor = e2.target?.cursor;
    const enterEvent = this.clonePointerEvent(e2, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse)
        this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e2.composedPath();
    this.freeEvent(e2);
    this.freeEvent(enterEvent);
  }
  mapPointerOut(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse)
          this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  mapPointerUp(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e2 = this.createPointerEvent(from);
    this.dispatchEvent(e2, "pointerup");
    if (e2.pointerType === "touch") {
      this.dispatchEvent(e2, "touchend");
    } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
      const isRightButton = e2.button === 2;
      this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e2.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e2.composedPath().includes(currentTarget)) {
        e2.currentTarget = currentTarget;
        this.notifyTarget(e2, "pointerupoutside");
        if (e2.pointerType === "touch") {
          this.notifyTarget(e2, "touchendoutside");
        } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
          const isRightButton = e2.button === 2;
          this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e2, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from.button]) {
        trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e2);
  }
  mapPointerUpOutside(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    const e2 = this.createPointerEvent(from);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e2.currentTarget = currentTarget;
        this.notifyTarget(e2, "pointerupoutside");
        if (e2.pointerType === "touch") {
          this.notifyTarget(e2, "touchendoutside");
        } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
          this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
    }
    this.freeEvent(e2);
  }
  mapWheel(from) {
    if (!(from instanceof FederatedWheelEvent)) {
      warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i2 = 1;i2 < propagationPath.length; i2++) {
      if (propagationPath[i2].parent === currentTarget) {
        currentTarget = propagationPath[i2];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent);
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  createWheelEvent(from) {
    const event = this.allocateEvent(FederatedWheelEvent);
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
      return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  }
  copyMouseData(from, to) {
    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
      return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.client.copyFrom(from.client);
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.movement.copyFrom(from.movement);
    to.screen.copyFrom(from.screen);
    to.shiftKey = from.shiftKey;
    to.global.copyFrom(from.global);
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.srcElement = from.srcElement;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.which = from.which;
    to.layer.copyFrom(from.layer);
    to.page.copyFrom(from.page);
  }
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.defaultPrevented = false;
    event.path = null;
    event.target = null;
    return event;
  }
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  _notifyListeners(e2, type) {
    const listeners = e2.currentTarget._events[type];
    if (!listeners)
      return;
    if ("fn" in listeners) {
      if (listeners.once)
        e2.currentTarget.removeListener(type, listeners.fn, undefined, true);
      listeners.fn.call(listeners.context, e2);
    } else {
      for (let i2 = 0, j2 = listeners.length;i2 < j2 && !e2.propagationImmediatelyStopped; i2++) {
        if (listeners[i2].once)
          e2.currentTarget.removeListener(type, listeners[i2].fn, undefined, true);
        listeners[i2].fn.call(listeners[i2].context, e2);
      }
    }
  }
}
var PROPAGATION_LIMIT = 2048, tempHitLocation, tempLocalMapping;
var init_EventBoundary = __esm(() => {
  init_eventemitter3();
  init_Point();
  init_warn();
  init_EventTicker();
  init_FederatedMouseEvent();
  init_FederatedPointerEvent();
  init_FederatedWheelEvent();
  tempHitLocation = new Point;
  tempLocalMapping = new Point;
});

// node_modules/pixi.js/lib/events/EventSystem.mjs
var MOUSE_POINTER_ID = 1, TOUCH_TO_POINTER, _EventSystem = class _EventSystem2 {
  constructor(renderer) {
    this.supportsTouchEvents = "ontouchstart" in globalThis;
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    this.domElement = null;
    this.resolution = 1;
    this.renderer = renderer;
    this.rootBoundary = new EventBoundary(null);
    EventsTicker.init(this);
    this.autoPreventDefault = true;
    this._eventsAdded = false;
    this._rootPointerEvent = new FederatedPointerEvent(null);
    this._rootWheelEvent = new FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
      set: (target, key, value) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value;
        }
        target[key] = value;
        return true;
      }
    });
    this._onPointerDown = this._onPointerDown.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerUp = this._onPointerUp.bind(this);
    this._onPointerOverOut = this._onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  init(options) {
    const { canvas, resolution } = this.renderer;
    this.setTargetElement(canvas);
    this.resolution = resolution;
    _EventSystem2._defaultEventMode = options.eventMode ?? "passive";
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  destroy() {
    EventsTicker.destroy();
    this.setTargetElement(null);
    this.renderer = null;
    this._currentCursor = null;
  }
  setCursor(mode) {
    mode || (mode = "default");
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this._currentCursor === mode) {
      return;
    }
    this._currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  get pointer() {
    return this._rootPointerEvent;
  }
  _onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const events = this._normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i2 = 0, j2 = events.length;i2 < j2; i2++) {
      const nativeEvent2 = events[i2];
      const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  _onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    EventsTicker.pointerMoved();
    const normalizedEvents = this._normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length;i2 < j2; i2++) {
      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  _onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this._normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length;i2 < j2; i2++) {
      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  _onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const normalizedEvents = this._normalizeToPointerData(nativeEvent);
    for (let i2 = 0, j2 = normalizedEvents.length;i2 < j2; i2++) {
      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  setTargetElement(element) {
    this._removeEvents();
    this.domElement = element;
    EventsTicker.domElement = element;
    this._addEvents();
  }
  _addEvents() {
    if (this._eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this._onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
      this.domElement.addEventListener("mousedown", this._onPointerDown, true);
      this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this._onPointerUp, true);
      if (this.supportsTouchEvents) {
        this.domElement.addEventListener("touchstart", this._onPointerDown, true);
        this.domElement.addEventListener("touchend", this._onPointerUp, true);
        this.domElement.addEventListener("touchmove", this._onPointerMove, true);
      }
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this._eventsAdded = true;
  }
  _removeEvents() {
    if (!this._eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "";
        style.msTouchAction = "";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this._onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this._onPointerUp, true);
      if (this.supportsTouchEvents) {
        this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
        this.domElement.removeEventListener("touchend", this._onPointerUp, true);
        this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
      }
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this._eventsAdded = false;
  }
  mapPositionToPoint(point, x2, y2) {
    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
      x: 0,
      y: 0,
      width: this.domElement.width,
      height: this.domElement.height,
      left: 0,
      top: 0
    };
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  _normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i2 = 0, li = event.changedTouches.length;i2 < li; i2++) {
        const touch = event.changedTouches[i2];
        if (typeof touch.button === "undefined")
          touch.button = 0;
        if (typeof touch.buttons === "undefined")
          touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined")
          touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined")
          touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined")
          touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined")
          touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined")
          touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined")
          touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined")
          touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined")
          touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined")
          touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined")
          touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined")
          touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined")
        tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined")
        tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined")
        tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined")
        tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined")
        tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined")
        tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined")
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined")
        tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined")
        tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined")
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this._rootWheelEvent;
    this._transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  _bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this._transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  _transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
}, EventSystem;
var init_EventSystem = __esm(() => {
  init_Extensions();
  init_EventBoundary();
  init_EventTicker();
  init_FederatedPointerEvent();
  init_FederatedWheelEvent();
  TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
  };
  _EventSystem.extension = {
    name: "events",
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.CanvasSystem,
      ExtensionType.WebGPUSystem
    ],
    priority: -1
  };
  _EventSystem.defaultEventFeatures = {
    move: true,
    globalMove: true,
    click: true,
    wheel: true
  };
  EventSystem = _EventSystem;
});

// node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
var FederatedContainer;
var init_FederatedEventTarget = __esm(() => {
  init_EventSystem();
  init_FederatedEvent();
  FederatedContainer = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    get interactive() {
      return this.eventMode === "dynamic" || this.eventMode === "static";
    },
    set interactive(value) {
      this.eventMode = value ? "static" : "passive";
    },
    _internalEventMode: undefined,
    get eventMode() {
      return this._internalEventMode ?? EventSystem.defaultEventMode;
    },
    set eventMode(value) {
      this._internalEventMode = value;
    },
    isInteractive() {
      return this.eventMode === "static" || this.eventMode === "dynamic";
    },
    interactiveChildren: true,
    hitArea: null,
    addEventListener(type, listener, options) {
      const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
      const signal = typeof options === "object" ? options.signal : undefined;
      const once = typeof options === "object" ? options.once === true : false;
      const context = typeof listener === "function" ? undefined : listener;
      type = capture ? `${type}capture` : type;
      const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
      const emitter = this;
      if (signal) {
        signal.addEventListener("abort", () => {
          emitter.off(type, listenerFn, context);
        });
      }
      if (once) {
        emitter.once(type, listenerFn, context);
      } else {
        emitter.on(type, listenerFn, context);
      }
    },
    removeEventListener(type, listener, options) {
      const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
      const context = typeof listener === "function" ? undefined : listener;
      type = capture ? `${type}capture` : type;
      listener = typeof listener === "function" ? listener : listener.handleEvent;
      this.off(type, listener, context);
    },
    dispatchEvent(e2) {
      if (!(e2 instanceof FederatedEvent)) {
        throw new Error("Container cannot propagate events outside of the Federated Events API");
      }
      e2.defaultPrevented = false;
      e2.path = null;
      e2.target = this;
      e2.manager.dispatchEvent(e2);
      return !e2.defaultPrevented;
    }
  };
});

// node_modules/pixi.js/lib/events/init.mjs
var init_init3 = __esm(() => {
  init_Extensions();
  init_Container();
  init_EventSystem();
  init_FederatedEventTarget();
  extensions.add(EventSystem);
  extensions.mixin(Container, FederatedContainer);
});

// node_modules/pixi.js/lib/dom/DOMPipe.mjs
class DOMPipe {
  constructor(renderer) {
    this._attachedDomElements = [];
    this._renderer = renderer;
    this._renderer.runners.postrender.add(this);
    this._renderer.runners.init.add(this);
    this._domElement = document.createElement("div");
    this._domElement.style.position = "absolute";
    this._domElement.style.top = "0";
    this._domElement.style.left = "0";
    this._domElement.style.pointerEvents = "none";
    this._domElement.style.zIndex = "1000";
  }
  init() {
    this._canvasObserver = new CanvasObserver({
      domElement: this._domElement,
      renderer: this._renderer
    });
  }
  addRenderable(domContainer, _instructionSet) {
    if (!this._attachedDomElements.includes(domContainer)) {
      this._attachedDomElements.push(domContainer);
    }
  }
  updateRenderable(_domContainer) {}
  validateRenderable(_domContainer) {
    return true;
  }
  postrender() {
    const attachedDomElements = this._attachedDomElements;
    if (attachedDomElements.length === 0) {
      this._domElement.remove();
      return;
    }
    this._canvasObserver.ensureAttached();
    for (let i2 = 0;i2 < attachedDomElements.length; i2++) {
      const domContainer = attachedDomElements[i2];
      const element = domContainer.element;
      if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {
        element?.remove();
        attachedDomElements.splice(i2, 1);
        i2--;
      } else {
        if (!this._domElement.contains(element)) {
          element.style.position = "absolute";
          element.style.pointerEvents = "auto";
          this._domElement.appendChild(element);
        }
        const wt = domContainer.worldTransform;
        const anchor = domContainer._anchor;
        const ax = domContainer.width * anchor.x;
        const ay = domContainer.height * anchor.y;
        element.style.transformOrigin = `${ax}px ${ay}px`;
        element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;
        element.style.opacity = domContainer.groupAlpha.toString();
      }
    }
  }
  destroy() {
    this._renderer.runners.postrender.remove(this);
    for (let i2 = 0;i2 < this._attachedDomElements.length; i2++) {
      const domContainer = this._attachedDomElements[i2];
      domContainer.element?.remove();
    }
    this._attachedDomElements.length = 0;
    this._domElement.remove();
    this._canvasObserver.destroy();
    this._renderer = null;
  }
}
var init_DOMPipe = __esm(() => {
  init_Extensions();
  init_CanvasObserver();
  DOMPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "dom"
  };
});

// node_modules/pixi.js/lib/scene/view/ViewContainer.mjs
var ViewContainer;
var init_ViewContainer = __esm(() => {
  init_Bounds();
  init_Container();
  ViewContainer = class ViewContainer extends Container {
    constructor(options) {
      super(options);
      this.canBundle = true;
      this.allowChildren = false;
      this._roundPixels = 0;
      this._lastUsed = -1;
      this._gpuData = /* @__PURE__ */ Object.create(null);
      this._bounds = new Bounds(0, 1, 0, 0);
      this._boundsDirty = true;
    }
    get bounds() {
      if (!this._boundsDirty)
        return this._bounds;
      this.updateBounds();
      this._boundsDirty = false;
      return this._bounds;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(value) {
      this._roundPixels = value ? 1 : 0;
    }
    containsPoint(point) {
      const bounds = this.bounds;
      const { x: x2, y: y2 } = point;
      return x2 >= bounds.minX && x2 <= bounds.maxX && y2 >= bounds.minY && y2 <= bounds.maxY;
    }
    onViewUpdate() {
      this._didViewChangeTick++;
      this._boundsDirty = true;
      if (this.didViewUpdate)
        return;
      this.didViewUpdate = true;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.onChildViewUpdate(this);
      }
    }
    destroy(options) {
      super.destroy(options);
      this._bounds = null;
      for (const key in this._gpuData) {
        this._gpuData[key].destroy?.();
      }
      this._gpuData = null;
    }
    collectRenderablesSimple(instructionSet, renderer, currentLayer) {
      const { renderPipes } = renderer;
      renderPipes.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);
      const rp = renderPipes;
      rp[this.renderPipeId].addRenderable(this, instructionSet);
      this.didViewUpdate = false;
      const children = this.children;
      const length = children.length;
      for (let i2 = 0;i2 < length; i2++) {
        children[i2].collectRenderables(instructionSet, renderer, currentLayer);
      }
      renderPipes.blendMode.popBlendMode(instructionSet);
    }
  };
});

// node_modules/pixi.js/lib/dom/init.mjs
var init_init4 = __esm(() => {
  init_Extensions();
  init_DOMPipe();
  extensions.add(DOMPipe);
});

// node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
var LoaderParserPriority;
var init_LoaderParser = __esm(() => {
  LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
    LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
    LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
    LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
    return LoaderParserPriority2;
  })(LoaderParserPriority || {});
});

// node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs
var BrowserAdapter;
var init_BrowserAdapter = __esm(() => {
  BrowserAdapter = {
    createCanvas: (width, height) => {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      return canvas;
    },
    createImage: () => new Image,
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (url, options) => fetch(url, options),
    parseXML: (xml) => {
      const parser = new DOMParser;
      return parser.parseFromString(xml, "text/xml");
    }
  };
});

// node_modules/pixi.js/lib/environment/adapter.mjs
var currentAdapter, DOMAdapter;
var init_adapter = __esm(() => {
  init_BrowserAdapter();
  currentAdapter = BrowserAdapter;
  DOMAdapter = {
    get() {
      return currentAdapter;
    },
    set(adapter) {
      currentAdapter = adapter;
    }
  };
});

// node_modules/pixi.js/lib/utils/path.mjs
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i2 = 0;i2 <= path2.length; ++i2) {
    if (i2 < path2.length) {
      code = path2.charCodeAt(i2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i2 - 1 || dots === 1) {} else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i2)}`;
        } else {
          res = path2.slice(lastSlash + 1, i2);
        }
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var path;
var init_path = __esm(() => {
  init_adapter();
  path = {
    toPosix(path2) {
      return replaceAll(path2, "\\", "/");
    },
    isUrl(path2) {
      return /^https?:/.test(this.toPosix(path2));
    },
    isDataUrl(path2) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
    },
    isBlobUrl(path2) {
      return path2.startsWith("blob:");
    },
    hasProtocol(path2) {
      return /^[^/:]+:/.test(this.toPosix(path2));
    },
    getProtocol(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      const matchFile = /^file:\/\/\//.exec(path2);
      if (matchFile) {
        return matchFile[0];
      }
      const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
      if (matchProtocol) {
        return matchProtocol[0];
      }
      return "";
    },
    toAbsolute(url, customBaseUrl, customRootUrl) {
      assertPath(url);
      if (this.isDataUrl(url) || this.isBlobUrl(url))
        return url;
      const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
      const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
      url = this.toPosix(url);
      if (url.startsWith("/")) {
        return path.join(rootUrl, url.slice(1));
      }
      const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
      return absolutePath;
    },
    normalize(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      if (this.isDataUrl(path2) || this.isBlobUrl(path2))
        return path2;
      path2 = this.toPosix(path2);
      let protocol = "";
      const isAbsolute = path2.startsWith("/");
      if (this.hasProtocol(path2)) {
        protocol = this.rootname(path2);
        path2 = path2.slice(protocol.length);
      }
      const trailingSeparator = path2.endsWith("/");
      path2 = normalizeStringPosix(path2, false);
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute)
        return `/${path2}`;
      return protocol + path2;
    },
    isAbsolute(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      if (this.hasProtocol(path2))
        return true;
      return path2.startsWith("/");
    },
    join(...segments) {
      if (segments.length === 0) {
        return ".";
      }
      let joined;
      for (let i2 = 0;i2 < segments.length; ++i2) {
        const arg = segments[i2];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === undefined)
            joined = arg;
          else {
            const prevArg = segments[i2 - 1] ?? "";
            if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
              joined += `/../${arg}`;
            } else {
              joined += `/${arg}`;
            }
          }
        }
      }
      if (joined === undefined) {
        return ".";
      }
      return this.normalize(joined);
    },
    dirname(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      path2 = this.toPosix(path2);
      let code = path2.charCodeAt(0);
      const hasRoot = code === 47;
      let end = -1;
      let matchedSlash = true;
      const proto = this.getProtocol(path2);
      const origpath = path2;
      path2 = path2.slice(proto.length);
      for (let i2 = path2.length - 1;i2 >= 1; --i2) {
        code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            end = i2;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
      if (hasRoot && end === 1)
        return "//";
      return proto + path2.slice(0, end);
    },
    rootname(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      let root = "";
      if (path2.startsWith("/"))
        root = "/";
      else {
        root = this.getProtocol(path2);
      }
      if (this.isUrl(path2)) {
        const index = path2.indexOf("/", root.length);
        if (index !== -1) {
          root = path2.slice(0, index);
        } else
          root = path2;
        if (!root.endsWith("/"))
          root += "/";
      }
      return root;
    },
    basename(path2, ext) {
      assertPath(path2);
      if (ext)
        assertPath(ext);
      path2 = removeUrlParams(this.toPosix(path2));
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i2;
      if (ext !== undefined && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i2 = path2.length - 1;i2 >= 0; --i2) {
          const code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i2 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i2;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      }
      for (i2 = path2.length - 1;i2 >= 0; --i2) {
        if (path2.charCodeAt(i2) === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
      }
      if (end === -1)
        return "";
      return path2.slice(start, end);
    },
    extname(path2) {
      assertPath(path2);
      path2 = removeUrlParams(this.toPosix(path2));
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i2 = path2.length - 1;i2 >= 0; --i2) {
        const code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i2;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    parse(path2) {
      assertPath(path2);
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path2.length === 0)
        return ret;
      path2 = removeUrlParams(this.toPosix(path2));
      let code = path2.charCodeAt(0);
      const isAbsolute = this.isAbsolute(path2);
      let start;
      const protocol = "";
      ret.root = this.rootname(path2);
      if (isAbsolute || this.hasProtocol(path2)) {
        start = 1;
      } else {
        start = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i2 = path2.length - 1;
      let preDotState = 0;
      for (;i2 >= start; --i2) {
        code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i2;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      ret.dir = this.dirname(path2);
      if (protocol)
        ret.dir = protocol + ret.dir;
      return ret;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"]
  };
});

// node_modules/pixi.js/lib/assets/utils/convertToList.mjs
var convertToList = (input, transform, forceTransform = false) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string" || forceTransform) {
      return transform(item);
    }
    return item;
  });
};
var init_convertToList = () => {};

// node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i2 = 0;i2 < id.length; i2++) {
    const value = id[i2];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}
var init_createStringVariations = () => {};

// node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
var isSingleItem = (item) => !Array.isArray(item);
var init_isSingleItem = () => {};

// node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  get parsers() {
    return this._parsers;
  }
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  getAlias(asset) {
    const { alias, src } = asset;
    const aliasesToUse = convertToList(alias || src, (value) => {
      if (typeof value === "string")
        return value;
      if (Array.isArray(value))
        return value.map((v2) => v2?.src ?? v2);
      if (value?.src)
        return value.src;
      return value;
    }, true);
    return aliasesToUse;
  }
  addManifest(manifest) {
    if (this._manifest) {
      warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  addBundle(bundleId, assets) {
    const assetNames = [];
    let convertedAssets = assets;
    if (!Array.isArray(assets)) {
      convertedAssets = Object.entries(assets).map(([alias, src]) => {
        if (typeof src === "string" || Array.isArray(src)) {
          return { alias, src };
        }
        return { alias, ...src };
      });
    }
    convertedAssets.forEach((asset) => {
      const srcs = asset.src;
      const aliases = asset.alias;
      let ids;
      if (typeof aliases === "string") {
        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
        assetNames.push(bundleAssetId);
        ids = [aliases, bundleAssetId];
      } else {
        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
        assetNames.push(...bundleIds);
        ids = [...aliases, ...bundleIds];
      }
      this.add({
        ...asset,
        ...{
          alias: ids,
          src: srcs
        }
      });
    });
    this._bundles[bundleId] = assetNames;
  }
  add(aliases) {
    const assets = [];
    if (Array.isArray(aliases)) {
      assets.push(...aliases);
    } else {
      assets.push(aliases);
    }
    let keyCheck;
    keyCheck = (key) => {
      if (this.hasKey(key)) {
        warn(`[Resolver] already has key: ${key} overwriting`);
      }
    };
    const assetArray = convertToList(assets);
    assetArray.forEach((asset) => {
      const { src } = asset;
      let { data, format, loadParser: userDefinedLoadParser, parser: userDefinedParser } = asset;
      const srcsToUse = convertToList(src).map((src2) => {
        if (typeof src2 === "string") {
          return createStringVariations(src2);
        }
        return Array.isArray(src2) ? src2 : [src2];
      });
      const aliasesToUse = this.getAlias(asset);
      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
      const resolvedAssets = [];
      srcsToUse.forEach((srcs) => {
        srcs.forEach((src2) => {
          let formattedAsset = {};
          if (typeof src2 !== "object") {
            formattedAsset.src = src2;
            for (let i2 = 0;i2 < this._parsers.length; i2++) {
              const parser = this._parsers[i2];
              if (parser.test(src2)) {
                formattedAsset = parser.parse(src2);
                break;
              }
            }
          } else {
            data = src2.data ?? data;
            format = src2.format ?? format;
            if (src2.loadParser || src2.parser) {
              userDefinedLoadParser = src2.loadParser ?? userDefinedLoadParser;
              userDefinedParser = src2.parser ?? userDefinedParser;
            }
            formattedAsset = {
              ...formattedAsset,
              ...src2
            };
          }
          if (!aliasesToUse) {
            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
          }
          formattedAsset = this._buildResolvedAsset(formattedAsset, {
            aliases: aliasesToUse,
            data,
            format,
            loadParser: userDefinedLoadParser,
            parser: userDefinedParser
          });
          resolvedAssets.push(formattedAsset);
        });
      });
      aliasesToUse.forEach((alias) => {
        this._assetMap[alias] = resolvedAssets;
      });
    });
  }
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i2 in result) {
        out[i2] = result[i2].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem(keys);
    keys = convertToList(keys);
    const result = {};
    keys.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0];
        } else {
          this._resolverHash[key] = this._buildResolvedAsset({
            alias: [key],
            src: key
          }, {});
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  hasKey(key) {
    return !!this._assetMap[key];
  }
  hasBundle(key) {
    return !!this._bundles[key];
  }
  _getPreferredOrder(assets) {
    for (let i2 = 0;i2 < assets.length; i2++) {
      const asset = assets[i2];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams)
      return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(formattedAsset, data) {
    const { aliases, data: assetData, loadParser, parser, format } = data;
    if (this._basePath || this._rootPath) {
      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
    }
    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
    formattedAsset.parser = parser ?? formattedAsset.parser;
    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
    return formattedAsset;
  }
}
function getUrlExtension(url) {
  return url.split(".").pop().split("?").shift().split("#").shift();
}
var init_Resolver = __esm(() => {
  init_warn();
  init_path();
  init_convertToList();
  init_createStringVariations();
  init_isSingleItem();
  Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
});

// node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
var copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};
var init_copySearchParams = () => {};

// node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
var _Spritesheet = class _Spritesheet2 {
  constructor(optionsOrTexture, arg1) {
    this.linkedSheets = [];
    let options = optionsOrTexture;
    if (optionsOrTexture?.source instanceof TextureSource) {
      options = {
        texture: optionsOrTexture,
        data: arg1
      };
    }
    const { texture, data, cachePrefix = "" } = options;
    this.cachePrefix = cachePrefix;
    this._texture = texture instanceof Texture ? texture : null;
    this.textureSource = texture.source;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const metaResolution = parseFloat(data.meta.scale);
    if (metaResolution) {
      this.resolution = metaResolution;
      texture.source.resolution = this.resolution;
    } else {
      this.resolution = texture.source._resolution;
    }
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet2.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i2 = this._frameKeys[frameIndex];
      const data = this._frames[i2];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i2] = new Texture({
          source: this.textureSource,
          frame,
          orig,
          trim,
          rotate: data.rotated ? 2 : 0,
          defaultAnchor: data.anchor,
          defaultBorders: data.borders,
          label: i2.toString()
        });
      }
      frameIndex++;
    }
  }
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i2 = 0;i2 < animations[animName].length; i2++) {
        const frameName = animations[animName][i2];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  destroy(destroyBase = false) {
    for (const i2 in this.textures) {
      this.textures[i2].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      this._texture?.destroy();
      this.textureSource.destroy();
    }
    this._texture = null;
    this.textureSource = null;
    this.linkedSheets = [];
  }
}, Spritesheet;
var init_Spritesheet = __esm(() => {
  init_Rectangle();
  init_TextureSource();
  init_Texture();
  _Spritesheet.BATCH_SIZE = 1000;
  Spritesheet = _Spritesheet;
});

// node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out = {};
  keys.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[`${asset.cachePrefix}${key}`] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i2) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
}
var validImages, spritesheetAsset;
var init_spritesheetAsset = __esm(() => {
  init_LoaderParser();
  init_Resolver();
  init_copySearchParams();
  init_Extensions();
  init_Texture();
  init_path();
  init_Spritesheet();
  validImages = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
  ];
  spritesheetAsset = {
    extension: ExtensionType.Asset,
    cache: {
      test: (asset) => asset instanceof Spritesheet,
      getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
    },
    resolver: {
      extension: {
        type: ExtensionType.ResolveParser,
        name: "resolveSpritesheet"
      },
      test: (value) => {
        const tempURL = value.split("?")[0];
        const split = tempURL.split(".");
        const extension = split.pop();
        const format = split.pop();
        return extension === "json" && validImages.includes(format);
      },
      parse: (value) => {
        const split = value.split(".");
        return {
          resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: split[split.length - 2],
          src: value
        };
      }
    },
    loader: {
      name: "spritesheetLoader",
      id: "spritesheet",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal,
        name: "spritesheetLoader"
      },
      async testParse(asset, options) {
        return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
      },
      async parse(asset, options, loader) {
        const {
          texture: imageTexture,
          imageFilename,
          textureOptions,
          cachePrefix
        } = options?.data ?? {};
        let basePath = path.dirname(options.src);
        if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
          basePath += "/";
        }
        let texture;
        if (imageTexture instanceof Texture) {
          texture = imageTexture;
        } else {
          const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);
          const assets = await loader.load([{ src: imagePath, data: textureOptions }]);
          texture = assets[imagePath];
        }
        const spritesheet = new Spritesheet({
          texture: texture.source,
          data: asset,
          cachePrefix
        });
        await spritesheet.parse();
        const multiPacks = asset?.meta?.related_multi_packs;
        if (Array.isArray(multiPacks)) {
          const promises = [];
          for (const item of multiPacks) {
            if (typeof item !== "string") {
              continue;
            }
            let itemUrl = basePath + item;
            if (options.data?.ignoreMultiPack) {
              continue;
            }
            itemUrl = copySearchParams(itemUrl, options.src);
            promises.push(loader.load({
              src: itemUrl,
              data: {
                textureOptions,
                ignoreMultiPack: true
              }
            }));
          }
          const res = await Promise.all(promises);
          spritesheet.linkedSheets = res;
          res.forEach((item) => {
            item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
          });
        }
        return spritesheet;
      },
      async unload(spritesheet, _resolvedAsset, loader) {
        await loader.unload(spritesheet.textureSource._sourceOrigin);
        spritesheet.destroy(false);
      }
    }
  };
});

// node_modules/pixi.js/lib/spritesheet/init.mjs
var init_init5 = __esm(() => {
  init_Extensions();
  init_spritesheetAsset();
  extensions.add(spritesheetAsset);
});

// node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs
function updateQuadBounds(bounds, anchor, texture) {
  const { width, height } = texture.orig;
  const trim = texture.trim;
  if (trim) {
    const sourceWidth = trim.width;
    const sourceHeight = trim.height;
    bounds.minX = trim.x - anchor._x * width;
    bounds.maxX = bounds.minX + sourceWidth;
    bounds.minY = trim.y - anchor._y * height;
    bounds.maxY = bounds.minY + sourceHeight;
  } else {
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
}
var init_updateQuadBounds = () => {};

// node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
var Sprite;
var init_Sprite = __esm(() => {
  init_ObservablePoint();
  init_Texture();
  init_updateQuadBounds();
  init_deprecation();
  init_ViewContainer();
  Sprite = class Sprite extends ViewContainer {
    constructor(options = Texture.EMPTY) {
      if (options instanceof Texture) {
        options = { texture: options };
      }
      const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;
      super({
        label: "Sprite",
        ...rest
      });
      this.renderPipeId = "sprite";
      this.batched = true;
      this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
      this._anchor = new ObservablePoint({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      });
      if (anchor) {
        this.anchor = anchor;
      } else if (texture.defaultAnchor) {
        this.anchor = texture.defaultAnchor;
      }
      this.texture = texture;
      this.allowChildren = false;
      this.roundPixels = roundPixels ?? false;
      if (width !== undefined)
        this.width = width;
      if (height !== undefined)
        this.height = height;
    }
    static from(source, skipCache = false) {
      if (source instanceof Texture) {
        return new Sprite(source);
      }
      return new Sprite(Texture.from(source, skipCache));
    }
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value)
        return;
      if (currentTexture && currentTexture.dynamic)
        currentTexture.off("update", this.onViewUpdate, this);
      if (value.dynamic)
        value.on("update", this.onViewUpdate, this);
      this._texture = value;
      if (this._width) {
        this._setWidth(this._width, this._texture.orig.width);
      }
      if (this._height) {
        this._setHeight(this._height, this._texture.orig.height);
      }
      this.onViewUpdate();
    }
    get texture() {
      return this._texture;
    }
    get visualBounds() {
      updateQuadBounds(this._visualBounds, this._anchor, this._texture);
      return this._visualBounds;
    }
    get sourceBounds() {
      deprecation("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead.");
      return this.visualBounds;
    }
    updateBounds() {
      const anchor = this._anchor;
      const texture = this._texture;
      const bounds = this._bounds;
      const { width, height } = texture.orig;
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
    destroy(options = false) {
      super.destroy(options);
      const destroyTexture = typeof options === "boolean" ? options : options?.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      this._texture = null;
      this._visualBounds = null;
      this._bounds = null;
      this._anchor = null;
      this._gpuData = null;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(value) {
      this._setWidth(value, this._texture.orig.width);
      this._width = value;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(value) {
      this._setHeight(value, this._texture.orig.height);
      this._height = value;
    }
    getSize(out) {
      out || (out = {});
      out.width = Math.abs(this.scale.x) * this._texture.orig.width;
      out.height = Math.abs(this.scale.y) * this._texture.orig.height;
      return out;
    }
    setSize(value, height) {
      if (typeof value === "object") {
        height = value.height ?? value.width;
        value = value.width;
      } else {
        height ?? (height = value);
      }
      value !== undefined && this._setWidth(value, this._texture.orig.width);
      height !== undefined && this._setHeight(height, this._texture.orig.height);
    }
  };
});

// node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
function addMaskBounds(mask, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds;
  mask.measurable = true;
  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask.measurable = false;
}
var tempBounds;
var init_addMaskBounds = __esm(() => {
  init_Bounds();
  init_getGlobalBounds();
  tempBounds = new Bounds;
});

// node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
function addMaskLocalBounds(mask, bounds, localRoot) {
  const boundsToMask = boundsPool.get();
  mask.measurable = true;
  const tempMatrix4 = matrixPool.get().identity();
  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix4);
  getLocalBounds(mask, boundsToMask, relativeMask);
  mask.measurable = false;
  bounds.addBoundsMask(boundsToMask);
  matrixPool.return(tempMatrix4);
  boundsPool.return(boundsToMask);
}
function getMatrixRelativeToParent(target, root, matrix) {
  if (!target) {
    warn("Mask bounds, renderable is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent(target.parent, root, matrix);
    target.updateLocalTransform();
    matrix.append(target.localTransform);
  }
  return matrix;
}
var init_addMaskLocalBounds = __esm(() => {
  init_getLocalBounds();
  init_matrixAndBoundsPool();
  init_warn();
});

// node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
class AlphaMask {
  constructor(options) {
    this.priority = 0;
    this.inverse = false;
    this.pipe = "alphaMask";
    if (options?.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
    this.renderMaskToTexture = !(mask instanceof Sprite);
    this.mask.renderable = this.renderMaskToTexture;
    this.mask.includeInBuild = !this.renderMaskToTexture;
    this.mask.measurable = false;
  }
  reset() {
    this.mask.measurable = true;
    this.mask = null;
  }
  addBounds(bounds, skipUpdateTransform) {
    if (!this.inverse) {
      addMaskBounds(this.mask, bounds, skipUpdateTransform);
    }
  }
  addLocalBounds(bounds, localRoot) {
    addMaskLocalBounds(this.mask, bounds, localRoot);
  }
  containsPoint(point, hitTestFn) {
    const mask = this.mask;
    return hitTestFn(mask, point);
  }
  destroy() {
    this.reset();
  }
  static test(mask) {
    return mask instanceof Sprite;
  }
}
var init_AlphaMask = __esm(() => {
  init_Extensions();
  init_Sprite();
  init_addMaskBounds();
  init_addMaskLocalBounds();
  AlphaMask.extension = ExtensionType.MaskEffect;
});

// node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
class ColorMask {
  constructor(options) {
    this.priority = 0;
    this.pipe = "colorMask";
    if (options?.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
  }
  destroy() {}
  static test(mask) {
    return typeof mask === "number";
  }
}
var init_ColorMask = __esm(() => {
  init_Extensions();
  ColorMask.extension = ExtensionType.MaskEffect;
});

// node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
class StencilMask {
  constructor(options) {
    this.priority = 0;
    this.pipe = "stencilMask";
    if (options?.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
    this.mask.includeInBuild = false;
    this.mask.measurable = false;
  }
  reset() {
    this.mask.measurable = true;
    this.mask.includeInBuild = true;
    this.mask = null;
  }
  addBounds(bounds, skipUpdateTransform) {
    addMaskBounds(this.mask, bounds, skipUpdateTransform);
  }
  addLocalBounds(bounds, localRoot) {
    addMaskLocalBounds(this.mask, bounds, localRoot);
  }
  containsPoint(point, hitTestFn) {
    const mask = this.mask;
    return hitTestFn(mask, point);
  }
  destroy() {
    this.reset();
  }
  static test(mask) {
    return mask instanceof Container;
  }
}
var init_StencilMask = __esm(() => {
  init_Extensions();
  init_Container();
  init_addMaskBounds();
  init_addMaskLocalBounds();
  StencilMask.extension = ExtensionType.MaskEffect;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
var CanvasSource;
var init_CanvasSource = __esm(() => {
  init_adapter();
  init_Extensions();
  init_TextureSource();
  CanvasSource = class CanvasSource extends TextureSource {
    constructor(options) {
      if (!options.resource) {
        options.resource = DOMAdapter.get().createCanvas();
      }
      if (!options.width) {
        options.width = options.resource.width;
        if (!options.autoDensity) {
          options.width /= options.resolution;
        }
      }
      if (!options.height) {
        options.height = options.resource.height;
        if (!options.autoDensity) {
          options.height /= options.resolution;
        }
      }
      super(options);
      this.uploadMethodId = "image";
      this.autoDensity = options.autoDensity;
      this.resizeCanvas();
      this.transparent = !!options.transparent;
    }
    resizeCanvas() {
      if (this.autoDensity && "style" in this.resource) {
        this.resource.style.width = `${this.width}px`;
        this.resource.style.height = `${this.height}px`;
      }
      if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
        this.resource.width = this.pixelWidth;
        this.resource.height = this.pixelHeight;
      }
    }
    resize(width = this.width, height = this.height, resolution = this._resolution) {
      const didResize = super.resize(width, height, resolution);
      if (didResize) {
        this.resizeCanvas();
      }
      return didResize;
    }
    static test(resource) {
      return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
    }
    get context2D() {
      return this._context2D || (this._context2D = this.resource.getContext("2d"));
    }
  };
  CanvasSource.extension = ExtensionType.TextureSource;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
var ImageSource;
var init_ImageSource = __esm(() => {
  init_Extensions();
  init_TextureSource();
  ImageSource = class ImageSource extends TextureSource {
    constructor(options) {
      super(options);
      this.uploadMethodId = "image";
      this.autoGarbageCollect = true;
    }
    static test(resource) {
      return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
    }
  };
  ImageSource.extension = ExtensionType.TextureSource;
});

// node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
async function detectVideoAlphaMode() {
  promise ?? (promise = (async () => {
    const canvas = DOMAdapter.get().createCanvas(1, 1);
    const gl = canvas.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve(video2);
      video2.onerror = () => resolve(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise;
}
var promise;
var init_detectVideoAlphaMode = __esm(() => {
  init_adapter();
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
var _VideoSource, VideoSource;
var init_VideoSource = __esm(() => {
  init_Extensions();
  init_Ticker();
  init_detectVideoAlphaMode();
  init_TextureSource();
  _VideoSource = class _VideoSource2 extends TextureSource {
    constructor(options) {
      super(options);
      this.isReady = false;
      this.uploadMethodId = "video";
      options = {
        ..._VideoSource2.defaultOptions,
        ...options
      };
      this._autoUpdate = true;
      this._isConnectedToTicker = false;
      this._updateFPS = options.updateFPS || 0;
      this._msToNextUpdate = 0;
      this.autoPlay = options.autoPlay !== false;
      this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
      this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
      this._videoFrameRequestCallbackHandle = null;
      this._load = null;
      this._resolve = null;
      this._reject = null;
      this._onCanPlay = this._onCanPlay.bind(this);
      this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
      this._onError = this._onError.bind(this);
      this._onPlayStart = this._onPlayStart.bind(this);
      this._onPlayStop = this._onPlayStop.bind(this);
      this._onSeeked = this._onSeeked.bind(this);
      if (options.autoLoad !== false) {
        this.load();
      }
    }
    updateFrame() {
      if (this.destroyed) {
        return;
      }
      if (this._updateFPS) {
        const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      }
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;
      }
      if (this.isValid) {
        this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame();
      if (this.destroyed) {
        this._videoFrameRequestCallbackHandle = null;
      } else {
        this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
      }
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) {
        return this._load;
      }
      const source = this.resource;
      const options = this.options;
      if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
        source.complete = true;
      }
      source.addEventListener("play", this._onPlayStart);
      source.addEventListener("pause", this._onPlayStop);
      source.addEventListener("seeked", this._onSeeked);
      if (!this._isSourceReady()) {
        if (!options.preload) {
          source.addEventListener("canplay", this._onCanPlay);
        }
        source.addEventListener("canplaythrough", this._onCanPlayThrough);
        source.addEventListener("error", this._onError, true);
      } else {
        this._mediaReady();
      }
      this.alphaMode = await detectVideoAlphaMode();
      this._load = new Promise((resolve, reject) => {
        if (this.isValid) {
          resolve(this);
        } else {
          this._resolve = resolve;
          this._reject = reject;
          if (options.preloadTimeoutMs !== undefined) {
            this._preloadTimeout = setTimeout(() => {
              this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
            });
          }
          source.load();
        }
      });
      return this._load;
    }
    _onError(event) {
      this.resource.removeEventListener("error", this._onError, true);
      this.emit("error", event);
      if (this._reject) {
        this._reject(event);
        this._reject = null;
        this._resolve = null;
      }
    }
    _isSourcePlaying() {
      const source = this.resource;
      return !source.paused && !source.ended;
    }
    _isSourceReady() {
      const source = this.resource;
      return source.readyState > 2;
    }
    _onPlayStart() {
      if (!this.isValid) {
        this._mediaReady();
      }
      this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      if (this._autoUpdate && !this._isSourcePlaying()) {
        this._msToNextUpdate = 0;
        this.updateFrame();
        this._msToNextUpdate = 0;
      }
    }
    _onCanPlay() {
      const source = this.resource;
      source.removeEventListener("canplay", this._onCanPlay);
      this._mediaReady();
    }
    _onCanPlayThrough() {
      const source = this.resource;
      source.removeEventListener("canplaythrough", this._onCanPlay);
      if (this._preloadTimeout) {
        clearTimeout(this._preloadTimeout);
        this._preloadTimeout = undefined;
      }
      this._mediaReady();
    }
    _mediaReady() {
      const source = this.resource;
      if (this.isValid) {
        this.isReady = true;
        this.resize(source.videoWidth, source.videoHeight);
      }
      this._msToNextUpdate = 0;
      this.updateFrame();
      this._msToNextUpdate = 0;
      if (this._resolve) {
        this._resolve(this);
        this._resolve = null;
        this._reject = null;
      }
      if (this._isSourcePlaying()) {
        this._onPlayStart();
      } else if (this.autoPlay) {
        this.resource.play();
      }
    }
    destroy() {
      this._configureAutoUpdate();
      const source = this.resource;
      if (source) {
        source.removeEventListener("play", this._onPlayStart);
        source.removeEventListener("pause", this._onPlayStop);
        source.removeEventListener("seeked", this._onSeeked);
        source.removeEventListener("canplay", this._onCanPlay);
        source.removeEventListener("canplaythrough", this._onCanPlayThrough);
        source.removeEventListener("error", this._onError, true);
        source.pause();
        source.src = "";
        source.load();
      }
      super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        this._configureAutoUpdate();
      }
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(value) {
      if (value !== this._updateFPS) {
        this._updateFPS = value;
        this._configureAutoUpdate();
      }
    }
    _configureAutoUpdate() {
      if (this._autoUpdate && this._isSourcePlaying()) {
        if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
          if (this._isConnectedToTicker) {
            Ticker.shared.remove(this.updateFrame, this);
            this._isConnectedToTicker = false;
            this._msToNextUpdate = 0;
          }
          if (this._videoFrameRequestCallbackHandle === null) {
            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
          }
        } else {
          if (this._videoFrameRequestCallbackHandle !== null) {
            this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
            this._videoFrameRequestCallbackHandle = null;
          }
          if (!this._isConnectedToTicker) {
            Ticker.shared.add(this.updateFrame, this);
            this._isConnectedToTicker = true;
            this._msToNextUpdate = 0;
          }
        }
      } else {
        if (this._videoFrameRequestCallbackHandle !== null) {
          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
          this._videoFrameRequestCallbackHandle = null;
        }
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.updateFrame, this);
          this._isConnectedToTicker = false;
          this._msToNextUpdate = 0;
        }
      }
    }
    static test(resource) {
      return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
    }
  };
  _VideoSource.extension = ExtensionType.TextureSource;
  _VideoSource.defaultOptions = {
    ...TextureSource.defaultOptions,
    autoLoad: true,
    autoPlay: true,
    updateFPS: 0,
    crossorigin: true,
    loop: false,
    muted: true,
    playsinline: true,
    preload: false
  };
  _VideoSource.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  VideoSource = _VideoSource;
});

// node_modules/pixi.js/lib/assets/cache/Cache.mjs
class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map;
    this._cacheMap = /* @__PURE__ */ new Map;
  }
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  has(key) {
    return this._cache.has(key);
  }
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      warn(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  set(key, value) {
    const keys = convertToList(key);
    let cacheableAssets;
    for (let i2 = 0;i2 < this.parsers.length; i2++) {
      const parser = this.parsers[i2];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
    if (!cacheableAssets) {
      keys.forEach((key2) => {
        cacheableMap.set(key2, value);
      });
    }
    const cacheKeys = [...cacheableMap.keys()];
    const cachedAssets = {
      cacheKeys,
      keys
    };
    keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      const val = cacheableAssets ? cacheableAssets[key2] : value;
      if (this._cache.has(key2) && this._cache.get(key2) !== val) {
        warn("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableMap.get(key2));
    });
  }
  remove(key) {
    if (!this._cacheMap.has(key)) {
      warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  get parsers() {
    return this._parsers;
  }
}
var Cache;
var init_Cache = __esm(() => {
  init_warn();
  init_convertToList();
  Cache = new CacheClass;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
function textureSourceFrom(options = {}) {
  const hasResource = options && options.resource;
  const res = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  for (let i2 = 0;i2 < sources.length; i2++) {
    const Source = sources[i2];
    if (Source.test(res)) {
      return new Source(opts);
    }
  }
  throw new Error(`Could not find a source type for resource: ${opts.resource}`);
}
function resourceToTexture(options = {}, skipCache = false) {
  const hasResource = options && options.resource;
  const resource = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  if (!skipCache && Cache.has(resource)) {
    return Cache.get(resource);
  }
  const texture = new Texture({ source: textureSourceFrom(opts) });
  texture.on("destroy", () => {
    if (Cache.has(resource)) {
      Cache.remove(resource);
    }
  });
  if (!skipCache) {
    Cache.set(resource, texture);
  }
  return texture;
}
function textureFrom(id, skipCache = false) {
  if (typeof id === "string") {
    return Cache.get(id);
  } else if (id instanceof TextureSource) {
    return new Texture({ source: id });
  }
  return resourceToTexture(id, skipCache);
}
var sources;
var init_textureFrom = __esm(() => {
  init_Cache();
  init_Extensions();
  init_TextureSource();
  init_Texture();
  sources = [];
  extensions.handleByList(ExtensionType.TextureSource, sources);
  Texture.from = textureFrom;
  TextureSource.from = textureSourceFrom;
});

// node_modules/pixi.js/lib/rendering/init.mjs
var init_init6 = __esm(() => {
  init_Extensions();
  init_AlphaMask();
  init_ColorMask();
  init_StencilMask();
  init_BufferImageSource();
  init_CanvasSource();
  init_ImageSource();
  init_VideoSource();
  init_textureFrom();
  extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
class BindGroup {
  constructor(resources) {
    this.resources = /* @__PURE__ */ Object.create(null);
    this._dirty = true;
    let index = 0;
    for (const i2 in resources) {
      const resource = resources[i2];
      this.setResource(resource, index++);
    }
    this._updateKey();
  }
  _updateKey() {
    if (!this._dirty)
      return;
    this._dirty = false;
    const keyParts = [];
    let index = 0;
    for (const i2 in this.resources) {
      keyParts[index++] = this.resources[i2]._resourceId;
    }
    this._key = keyParts.join("|");
  }
  setResource(resource, index) {
    const currentResource = this.resources[index];
    if (resource === currentResource)
      return;
    if (currentResource) {
      resource.off?.("change", this.onResourceChange, this);
    }
    resource.on?.("change", this.onResourceChange, this);
    this.resources[index] = resource;
    this._dirty = true;
  }
  getResource(index) {
    return this.resources[index];
  }
  _touch(tick) {
    const resources = this.resources;
    for (const i2 in resources) {
      resources[i2]._touched = tick;
    }
  }
  destroy() {
    const resources = this.resources;
    for (const i2 in resources) {
      const resource = resources[i2];
      resource?.off?.("change", this.onResourceChange, this);
    }
    this.resources = null;
  }
  onResourceChange(resource) {
    this._dirty = true;
    if (resource.destroyed) {
      const resources = this.resources;
      for (const i2 in resources) {
        if (resources[i2] === resource) {
          resources[i2] = null;
        }
      }
    } else {
      this._updateKey();
    }
  }
}
var init_BindGroup = () => {};

// node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
function getTextureBatchBindGroup(textures, size, maxTextures) {
  let uid2 = 2166136261;
  for (let i2 = 0;i2 < size; i2++) {
    uid2 ^= textures[i2].uid;
    uid2 = Math.imul(uid2, 16777619);
    uid2 >>>= 0;
  }
  return cachedGroups[uid2] || generateTextureBatchBindGroup(textures, size, uid2, maxTextures);
}
function generateTextureBatchBindGroup(textures, size, key, maxTextures) {
  const bindGroupResources = {};
  let bindIndex = 0;
  for (let i2 = 0;i2 < maxTextures; i2++) {
    const texture = i2 < size ? textures[i2] : Texture.EMPTY.source;
    bindGroupResources[bindIndex++] = texture.source;
    bindGroupResources[bindIndex++] = texture.style;
  }
  const bindGroup = new BindGroup(bindGroupResources);
  cachedGroups[key] = bindGroup;
  return bindGroup;
}
var cachedGroups;
var init_getTextureBatchBindGroup = __esm(() => {
  init_BindGroup();
  init_Texture();
  cachedGroups = {};
});

// node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs
class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
    this.size = this.rawBinaryData.byteLength;
  }
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  get float64View() {
    if (!this._float64Array) {
      this._float64Array = new Float64Array(this.rawBinaryData);
    }
    return this._float64Array;
  }
  get bigUint64View() {
    if (!this._bigUint64Array) {
      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
    }
    return this._bigUint64Array;
  }
  view(type) {
    return this[`${type}View`];
  }
  destroy() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this.uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  }
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}
var init_ViewableBuffer = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
function fastCopy(sourceBuffer, destinationBuffer) {
  const lengthDouble = sourceBuffer.byteLength / 8 | 0;
  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
  destinationFloat64View.set(sourceFloat64View);
  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
  if (remainingBytes > 0) {
    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
    destinationUint8View.set(sourceUint8View);
  }
}
var init_fastCopy = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
var BLEND_TO_NPM, STENCIL_MODES;
var init_const3 = __esm(() => {
  BLEND_TO_NPM = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
  };
  STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
    STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
    STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
    STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
    STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
    STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
    STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
    return STENCIL_MODES2;
  })(STENCIL_MODES || {});
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
function getAdjustedBlendModeBlend(blendMode, textureSource) {
  if (textureSource.alphaMode === "no-premultiply-alpha") {
    return BLEND_TO_NPM[blendMode] || blendMode;
  }
  return blendMode;
}
var init_getAdjustedBlendModeBlend = __esm(() => {
  init_const3();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
function getTestContext() {
  if (!context || context?.isContextLost()) {
    const canvas = DOMAdapter.get().createCanvas();
    context = canvas.getContext("webgl", {});
  }
  return context;
}
var context;
var init_getTestContext = __esm(() => {
  init_adapter();
});

// node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i2 = 0;i2 < maxIfs; ++i2) {
    if (i2 > 0) {
      src += `
else `;
    }
    if (i2 < maxIfs - 1) {
      src += `if(test == ${i2}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  try {
    while (true) {
      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
  } finally {
    gl.deleteShader(shader);
  }
  return maxIfs;
}
var fragTemplate;
var init_checkMaxIfStatementsInShader = __esm(() => {
  fragTemplate = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join(`
`);
});

// node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs
function getMaxTexturesPerBatch() {
  if (maxTexturesPerBatchCache)
    return maxTexturesPerBatchCache;
  const gl = getTestContext();
  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(maxTexturesPerBatchCache, gl);
  gl.getExtension("WEBGL_lose_context")?.loseContext();
  return maxTexturesPerBatchCache;
}
var maxTexturesPerBatchCache = null;
var init_maxRecommendedTextures = __esm(() => {
  init_getTestContext();
  init_checkMaxIfStatementsInShader();
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
class BatchTextureArray {
  constructor() {
    this.ids = /* @__PURE__ */ Object.create(null);
    this.textures = [];
    this.count = 0;
  }
  clear() {
    for (let i2 = 0;i2 < this.count; i2++) {
      const t2 = this.textures[i2];
      this.textures[i2] = null;
      this.ids[t2.uid] = null;
    }
    this.count = 0;
  }
}
var init_BatchTextureArray = () => {};

// node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
class Batch {
  constructor() {
    this.renderPipeId = "batch";
    this.action = "startBatch";
    this.start = 0;
    this.size = 0;
    this.textures = new BatchTextureArray;
    this.blendMode = "normal";
    this.topology = "triangle-strip";
    this.canBundle = true;
  }
  destroy() {
    this.textures = null;
    this.gpuBindGroup = null;
    this.bindGroup = null;
    this.batcher = null;
  }
}
function getBatchFromPool() {
  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch;
}
function returnBatchToPool(batch) {
  batchPool[batchPoolIndex++] = batch;
}
var batchPool, batchPoolIndex = 0, BATCH_TICK = 0, _Batcher = class _Batcher2 {
  constructor(options) {
    this.uid = uid("batcher");
    this.dirty = true;
    this.batchIndex = 0;
    this.batches = [];
    this._elements = [];
    options = { ..._Batcher2.defaultOptions, ...options };
    if (!options.maxTextures) {
      deprecation("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options");
      options.maxTextures = getMaxTexturesPerBatch();
    }
    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;
    this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
    this.indexBuffer = new Uint16Array(indicesInitialSize);
    this.maxTextures = maxTextures;
  }
  begin() {
    this.elementSize = 0;
    this.elementStart = 0;
    this.indexSize = 0;
    this.attributeSize = 0;
    for (let i2 = 0;i2 < this.batchIndex; i2++) {
      returnBatchToPool(this.batches[i2]);
    }
    this.batchIndex = 0;
    this._batchIndexStart = 0;
    this._batchIndexSize = 0;
    this.dirty = true;
  }
  add(batchableObject) {
    this._elements[this.elementSize++] = batchableObject;
    batchableObject._indexStart = this.indexSize;
    batchableObject._attributeStart = this.attributeSize;
    batchableObject._batcher = this;
    this.indexSize += batchableObject.indexSize;
    this.attributeSize += batchableObject.attributeSize * this.vertexSize;
  }
  checkAndUpdateTexture(batchableObject, texture) {
    const textureId = batchableObject._batch.textures.ids[texture._source.uid];
    if (!textureId && textureId !== 0)
      return false;
    batchableObject._textureId = textureId;
    batchableObject.texture = texture;
    return true;
  }
  updateElement(batchableObject) {
    this.dirty = true;
    const attributeBuffer = this.attributeBuffer;
    if (batchableObject.packAsQuad) {
      this.packQuadAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId);
    } else {
      this.packAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId);
    }
  }
  break(instructionSet) {
    const elements = this._elements;
    if (!elements[this.elementStart])
      return;
    let batch = getBatchFromPool();
    let textureBatch = batch.textures;
    textureBatch.clear();
    const firstElement = elements[this.elementStart];
    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
    let topology = firstElement.topology;
    if (this.attributeSize * 4 > this.attributeBuffer.size) {
      this._resizeAttributeBuffer(this.attributeSize * 4);
    }
    if (this.indexSize > this.indexBuffer.length) {
      this._resizeIndexBuffer(this.indexSize);
    }
    const f32 = this.attributeBuffer.float32View;
    const u32 = this.attributeBuffer.uint32View;
    const indexBuffer = this.indexBuffer;
    let size = this._batchIndexSize;
    let start = this._batchIndexStart;
    let action = "startBatch";
    const maxTextures = this.maxTextures;
    for (let i2 = this.elementStart;i2 < this.elementSize; ++i2) {
      const element = elements[i2];
      elements[i2] = null;
      const texture = element.texture;
      const source = texture._source;
      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);
      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;
      if (source._batchTick === BATCH_TICK && !breakRequired) {
        element._textureId = source._textureBindLocation;
        size += element.indexSize;
        if (element.packAsQuad) {
          this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId);
          this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);
        } else {
          this.packAttributes(element, f32, u32, element._attributeStart, element._textureId);
          this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);
        }
        element._batch = batch;
        continue;
      }
      source._batchTick = BATCH_TICK;
      if (textureBatch.count >= maxTextures || breakRequired) {
        this._finishBatch(batch, start, size - start, textureBatch, blendMode, topology, instructionSet, action);
        action = "renderBatch";
        start = size;
        blendMode = adjustedBlendMode;
        topology = element.topology;
        batch = getBatchFromPool();
        textureBatch = batch.textures;
        textureBatch.clear();
        ++BATCH_TICK;
      }
      element._textureId = source._textureBindLocation = textureBatch.count;
      textureBatch.ids[source.uid] = textureBatch.count;
      textureBatch.textures[textureBatch.count++] = source;
      element._batch = batch;
      size += element.indexSize;
      if (element.packAsQuad) {
        this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId);
        this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);
      } else {
        this.packAttributes(element, f32, u32, element._attributeStart, element._textureId);
        this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);
      }
    }
    if (textureBatch.count > 0) {
      this._finishBatch(batch, start, size - start, textureBatch, blendMode, topology, instructionSet, action);
      start = size;
      ++BATCH_TICK;
    }
    this.elementStart = this.elementSize;
    this._batchIndexStart = start;
    this._batchIndexSize = size;
  }
  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {
    batch.gpuBindGroup = null;
    batch.bindGroup = null;
    batch.action = action;
    batch.batcher = this;
    batch.textures = textureBatch;
    batch.blendMode = blendMode;
    batch.topology = topology;
    batch.start = indexStart;
    batch.size = indexSize;
    ++BATCH_TICK;
    this.batches[this.batchIndex++] = batch;
    instructionSet.add(batch);
  }
  finish(instructionSet) {
    this.break(instructionSet);
  }
  ensureAttributeBuffer(size) {
    if (size * 4 <= this.attributeBuffer.size)
      return;
    this._resizeAttributeBuffer(size * 4);
  }
  ensureIndexBuffer(size) {
    if (size <= this.indexBuffer.length)
      return;
    this._resizeIndexBuffer(size);
  }
  _resizeAttributeBuffer(size) {
    const newSize = Math.max(size, this.attributeBuffer.size * 2);
    const newArrayBuffer = new ViewableBuffer(newSize);
    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
    this.attributeBuffer = newArrayBuffer;
  }
  _resizeIndexBuffer(size) {
    const indexBuffer = this.indexBuffer;
    let newSize = Math.max(size, indexBuffer.length * 1.5);
    newSize += newSize % 2;
    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
      for (let i2 = 0;i2 < indexBuffer.length; i2++) {
        newIndexBuffer[i2] = indexBuffer[i2];
      }
    } else {
      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
    }
    this.indexBuffer = newIndexBuffer;
  }
  packQuadIndex(indexBuffer, index, indicesOffset) {
    indexBuffer[index] = indicesOffset + 0;
    indexBuffer[index + 1] = indicesOffset + 1;
    indexBuffer[index + 2] = indicesOffset + 2;
    indexBuffer[index + 3] = indicesOffset + 0;
    indexBuffer[index + 4] = indicesOffset + 2;
    indexBuffer[index + 5] = indicesOffset + 3;
  }
  packIndex(element, indexBuffer, index, indicesOffset) {
    const indices = element.indices;
    const size = element.indexSize;
    const indexOffset = element.indexOffset;
    const attributeOffset = element.attributeOffset;
    for (let i2 = 0;i2 < size; i2++) {
      indexBuffer[index++] = indicesOffset + indices[i2 + indexOffset] - attributeOffset;
    }
  }
  destroy() {
    if (this.batches === null)
      return;
    for (let i2 = 0;i2 < this.batches.length; i2++) {
      returnBatchToPool(this.batches[i2]);
    }
    this.batches = null;
    for (let i2 = 0;i2 < this._elements.length; i2++) {
      if (this._elements[i2])
        this._elements[i2]._batch = null;
    }
    this._elements = null;
    this.indexBuffer = null;
    this.attributeBuffer.destroy();
    this.attributeBuffer = null;
  }
}, Batcher;
var init_Batcher = __esm(() => {
  init_uid();
  init_ViewableBuffer();
  init_deprecation();
  init_GlobalResourceRegistry();
  init_fastCopy();
  init_getAdjustedBlendModeBlend();
  init_maxRecommendedTextures();
  init_BatchTextureArray();
  batchPool = [];
  GlobalResourceRegistry.register({
    clear: () => {
      if (batchPool.length > 0) {
        for (const item of batchPool) {
          if (item)
            item.destroy();
        }
      }
      batchPool.length = 0;
      batchPoolIndex = 0;
    }
  });
  _Batcher.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6
  };
  Batcher = _Batcher;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
var BufferUsage;
var init_const4 = __esm(() => {
  BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
    BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
    BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
    BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
    BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
    BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
    BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
    BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
    BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
    BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
    BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
    BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
    return BufferUsage2;
  })(BufferUsage || {});
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
var Buffer;
var init_Buffer = __esm(() => {
  init_eventemitter3();
  init_uid();
  init_const4();
  Buffer = class Buffer extends eventemitter3_default {
    constructor(options) {
      let { data, size } = options;
      const { usage, label, shrinkToFit } = options;
      super();
      this.uid = uid("buffer");
      this._resourceType = "buffer";
      this._resourceId = uid("resource");
      this._touched = 0;
      this._updateID = 1;
      this._dataInt32 = null;
      this.shrinkToFit = true;
      this.destroyed = false;
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      this._data = data;
      size ?? (size = data?.byteLength);
      const mappedAtCreation = !!data;
      this.descriptor = {
        size,
        usage,
        mappedAtCreation,
        label
      };
      this.shrinkToFit = shrinkToFit ?? true;
    }
    get data() {
      return this._data;
    }
    set data(value) {
      this.setDataWithSize(value, value.length, true);
    }
    get dataInt32() {
      if (!this._dataInt32) {
        this._dataInt32 = new Int32Array(this.data.buffer);
      }
      return this._dataInt32;
    }
    get static() {
      return !!(this.descriptor.usage & BufferUsage.STATIC);
    }
    set static(value) {
      if (value) {
        this.descriptor.usage |= BufferUsage.STATIC;
      } else {
        this.descriptor.usage &= ~BufferUsage.STATIC;
      }
    }
    setDataWithSize(value, size, syncGPU) {
      this._updateID++;
      this._updateSize = size * value.BYTES_PER_ELEMENT;
      if (this._data === value) {
        if (syncGPU)
          this.emit("update", this);
        return;
      }
      const oldData = this._data;
      this._data = value;
      this._dataInt32 = null;
      if (!oldData || oldData.length !== value.length) {
        if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {
          if (syncGPU)
            this.emit("update", this);
        } else {
          this.descriptor.size = value.byteLength;
          this._resourceId = uid("resource");
          this.emit("change", this);
        }
        return;
      }
      if (syncGPU)
        this.emit("update", this);
    }
    update(sizeInBytes) {
      this._updateSize = sizeInBytes ?? this._updateSize;
      this._updateID++;
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true;
      this.emit("destroy", this);
      this.emit("change", this);
      this._data = null;
      this.descriptor = null;
      this.removeAllListeners();
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
function ensureIsBuffer(buffer, index) {
  if (!(buffer instanceof Buffer)) {
    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
    if (buffer instanceof Array) {
      if (index) {
        buffer = new Uint32Array(buffer);
        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
      } else {
        buffer = new Float32Array(buffer);
        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
      }
    }
    buffer = new Buffer({
      data: buffer,
      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage
    });
  }
  return buffer;
}
var init_ensureIsBuffer = __esm(() => {
  init_Buffer();
  init_const4();
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
function getGeometryBounds(geometry, attributeId, bounds) {
  const attribute = geometry.getAttribute(attributeId);
  if (!attribute) {
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = 0;
    bounds.maxY = 0;
    return bounds;
  }
  const data = attribute.buffer.data;
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  const byteSize = data.BYTES_PER_ELEMENT;
  const offset = (attribute.offset || 0) / byteSize;
  const stride = (attribute.stride || 2 * 4) / byteSize;
  for (let i2 = offset;i2 < data.length; i2 += stride) {
    const x2 = data[i2];
    const y2 = data[i2 + 1];
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
  }
  bounds.minX = minX;
  bounds.minY = minY;
  bounds.maxX = maxX;
  bounds.maxY = maxY;
  return bounds;
}
var init_getGeometryBounds = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
function ensureIsAttribute(attribute) {
  if (attribute instanceof Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
    attribute = {
      buffer: attribute
    };
  }
  attribute.buffer = ensureIsBuffer(attribute.buffer, false);
  return attribute;
}
var Geometry;
var init_Geometry = __esm(() => {
  init_eventemitter3();
  init_Bounds();
  init_uid();
  init_Buffer();
  init_ensureIsBuffer();
  init_getGeometryBounds();
  Geometry = class Geometry extends eventemitter3_default {
    constructor(options = {}) {
      super();
      this.uid = uid("geometry");
      this._layoutKey = 0;
      this.instanceCount = 1;
      this._bounds = new Bounds;
      this._boundsDirty = true;
      const { attributes, indexBuffer, topology } = options;
      this.buffers = [];
      this.attributes = {};
      if (attributes) {
        for (const i2 in attributes) {
          this.addAttribute(i2, attributes[i2]);
        }
      }
      this.instanceCount = options.instanceCount ?? 1;
      if (indexBuffer) {
        this.addIndex(indexBuffer);
      }
      this.topology = topology || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = true;
      this.emit("update", this);
    }
    getAttribute(id) {
      return this.attributes[id];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(id) {
      return this.getAttribute(id).buffer;
    }
    getSize() {
      for (const i2 in this.attributes) {
        const attribute = this.attributes[i2];
        const buffer = attribute.buffer;
        return buffer.data.length / (attribute.stride / 4 || attribute.size);
      }
      return 0;
    }
    addAttribute(name, attributeOption) {
      const attribute = ensureIsAttribute(attributeOption);
      const bufferIndex = this.buffers.indexOf(attribute.buffer);
      if (bufferIndex === -1) {
        this.buffers.push(attribute.buffer);
        attribute.buffer.on("update", this.onBufferUpdate, this);
        attribute.buffer.on("change", this.onBufferUpdate, this);
      }
      this.attributes[name] = attribute;
    }
    addIndex(indexBuffer) {
      this.indexBuffer = ensureIsBuffer(indexBuffer, true);
      this.buffers.push(this.indexBuffer);
    }
    get bounds() {
      if (!this._boundsDirty)
        return this._bounds;
      this._boundsDirty = false;
      return getGeometryBounds(this, "aPosition", this._bounds);
    }
    destroy(destroyBuffers = false) {
      this.emit("destroy", this);
      this.removeAllListeners();
      if (destroyBuffers) {
        this.buffers.forEach((buffer) => buffer.destroy());
      }
      this.attributes = null;
      this.buffers = null;
      this.indexBuffer = null;
      this._bounds = null;
    }
  };
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs
var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
var init_BatchGeometry = __esm(() => {
  init_Buffer();
  init_const4();
  init_Geometry();
  placeHolderBufferData = new Float32Array(1);
  placeHolderIndexData = new Uint32Array(1);
  BatchGeometry = class BatchGeometry extends Geometry {
    constructor() {
      const vertexSize = 6;
      const attributeBuffer = new Buffer({
        data: placeHolderBufferData,
        label: "attribute-batch-buffer",
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
        shrinkToFit: false
      });
      const indexBuffer = new Buffer({
        data: placeHolderIndexData,
        label: "index-batch-buffer",
        usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
        shrinkToFit: false
      });
      const stride = vertexSize * 4;
      super({
        attributes: {
          aPosition: {
            buffer: attributeBuffer,
            format: "float32x2",
            stride,
            offset: 0
          },
          aUV: {
            buffer: attributeBuffer,
            format: "float32x2",
            stride,
            offset: 2 * 4
          },
          aColor: {
            buffer: attributeBuffer,
            format: "unorm8x4",
            stride,
            offset: 4 * 4
          },
          aTextureIdAndRound: {
            buffer: attributeBuffer,
            format: "uint16x2",
            stride,
            offset: 5 * 4
          }
        },
        indexBuffer
      });
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
function createIdFromString(value, groupId) {
  let id = idHash2[value];
  if (id === undefined) {
    if (idCounts[groupId] === undefined) {
      idCounts[groupId] = 1;
    }
    idHash2[value] = id = idCounts[groupId]++;
  }
  return id;
}
var idCounts, idHash2;
var init_createIdFromString = __esm(() => {
  idCounts = /* @__PURE__ */ Object.create(null);
  idHash2 = /* @__PURE__ */ Object.create(null);
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = "mediump";
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision;
}
var maxFragmentPrecision;
var init_getMaxFragmentPrecision = __esm(() => {
  init_getTestContext();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
function addProgramDefines(src, isES300, isFragment) {
  if (isES300)
    return src;
  if (isFragment) {
    src = src.replace("out vec4 finalColor;", "");
    return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
  }
  return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
}
var init_addProgramDefines = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
function ensurePrecision(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var init_ensurePrecision = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
function insertVersion(src, isES300) {
  if (!isES300)
    return src;
  return `#version 300 es
${src}`;
}
var init_insertVersion = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache[name]) {
    nameCache[name]++;
    name += `-${nameCache[name]}`;
  } else {
    nameCache[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  return `${shaderName}
${src}`;
}
var fragmentNameCache, VertexNameCache;
var init_setProgramName = __esm(() => {
  fragmentNameCache = {};
  VertexNameCache = {};
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
function stripVersion(src, isES300) {
  if (!isES300)
    return src;
  return src.replace("#version 300 es", "");
}
var init_stripVersion = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
var processes, programCache, _GlProgram = class _GlProgram2 {
  constructor(options) {
    options = { ..._GlProgram2.defaultOptions, ...options };
    const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
    const preprocessorOptions = {
      stripVersion: isES300,
      ensurePrecision: {
        requestedFragmentPrecision: options.preferredFragmentPrecision,
        requestedVertexPrecision: options.preferredVertexPrecision,
        maxSupportedVertexPrecision: "highp",
        maxSupportedFragmentPrecision: getMaxFragmentPrecision()
      },
      setProgramName: {
        name: options.name
      },
      addProgramDefines: isES300,
      insertVersion: isES300
    };
    let fragment = options.fragment;
    let vertex = options.vertex;
    Object.keys(processes).forEach((processKey) => {
      const processOptions = preprocessorOptions[processKey];
      fragment = processes[processKey](fragment, processOptions, true);
      vertex = processes[processKey](vertex, processOptions, false);
    });
    this.fragment = fragment;
    this.vertex = vertex;
    this.transformFeedbackVaryings = options.transformFeedbackVaryings;
    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
  }
  destroy() {
    this.fragment = null;
    this.vertex = null;
    this._attributeData = null;
    this._uniformData = null;
    this._uniformBlockData = null;
    this.transformFeedbackVaryings = null;
    programCache[this._cacheKey] = null;
  }
  static from(options) {
    const key = `${options.vertex}:${options.fragment}`;
    if (!programCache[key]) {
      programCache[key] = new _GlProgram2(options);
      programCache[key]._cacheKey = key;
    }
    return programCache[key];
  }
}, GlProgram;
var init_GlProgram = __esm(() => {
  init_createIdFromString();
  init_getMaxFragmentPrecision();
  init_addProgramDefines();
  init_ensurePrecision();
  init_insertVersion();
  init_setProgramName();
  init_stripVersion();
  processes = {
    stripVersion,
    ensurePrecision,
    addProgramDefines,
    setProgramName,
    insertVersion
  };
  programCache = /* @__PURE__ */ Object.create(null);
  _GlProgram.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
  };
  GlProgram = _GlProgram;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
function getAttributeInfoFromFormat(format) {
  return attributeFormatData[format] ?? attributeFormatData.float32;
}
var attributeFormatData;
var init_getAttributeInfoFromFormat = __esm(() => {
  attributeFormatData = {
    uint8x2: { size: 2, stride: 2, normalised: false },
    uint8x4: { size: 4, stride: 4, normalised: false },
    sint8x2: { size: 2, stride: 2, normalised: false },
    sint8x4: { size: 4, stride: 4, normalised: false },
    unorm8x2: { size: 2, stride: 2, normalised: true },
    unorm8x4: { size: 4, stride: 4, normalised: true },
    snorm8x2: { size: 2, stride: 2, normalised: true },
    snorm8x4: { size: 4, stride: 4, normalised: true },
    uint16x2: { size: 2, stride: 4, normalised: false },
    uint16x4: { size: 4, stride: 8, normalised: false },
    sint16x2: { size: 2, stride: 4, normalised: false },
    sint16x4: { size: 4, stride: 8, normalised: false },
    unorm16x2: { size: 2, stride: 4, normalised: true },
    unorm16x4: { size: 4, stride: 8, normalised: true },
    snorm16x2: { size: 2, stride: 4, normalised: true },
    snorm16x4: { size: 4, stride: 8, normalised: true },
    float16x2: { size: 2, stride: 4, normalised: false },
    float16x4: { size: 4, stride: 8, normalised: false },
    float32: { size: 1, stride: 4, normalised: false },
    float32x2: { size: 2, stride: 8, normalised: false },
    float32x3: { size: 3, stride: 12, normalised: false },
    float32x4: { size: 4, stride: 16, normalised: false },
    uint32: { size: 1, stride: 4, normalised: false },
    uint32x2: { size: 2, stride: 8, normalised: false },
    uint32x3: { size: 3, stride: 12, normalised: false },
    uint32x4: { size: 4, stride: 16, normalised: false },
    sint32: { size: 1, stride: 4, normalised: false },
    sint32x2: { size: 2, stride: 8, normalised: false },
    sint32x3: { size: 3, stride: 12, normalised: false },
    sint32x4: { size: 4, stride: 16, normalised: false }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
function extractAttributesFromGpuProgram({ source, entryPoint }) {
  const results = {};
  const mainVertStart = source.indexOf(`fn ${entryPoint}`);
  if (mainVertStart !== -1) {
    const arrowFunctionStart = source.indexOf("->", mainVertStart);
    if (arrowFunctionStart !== -1) {
      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);
      const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let match;
      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
        results[match[2]] = {
          location: parseInt(match[1], 10),
          format,
          stride: getAttributeInfoFromFormat(format).stride,
          offset: 0,
          instance: false,
          start: 0
        };
      }
    }
  }
  return results;
}
var WGSL_TO_VERTEX_TYPES;
var init_extractAttributesFromGpuProgram = __esm(() => {
  init_getAttributeInfoFromFormat();
  WGSL_TO_VERTEX_TYPES = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
function extractStructAndGroups(wgsl) {
  const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl.match(structPattern)?.map((struct) => {
    const name = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type] = member.split(":");
      acc[name2.trim()] = type.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name, members };
  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
  return {
    groups,
    structs
  };
}
var init_extractStructAndGroups = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
var ShaderStage;
var init_const5 = __esm(() => {
  ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
    ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
    ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
    ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
    return ShaderStage2;
  })(ShaderStage || {});
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i2 = 0;i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}
var init_generateGpuLayoutGroups = __esm(() => {
  init_const5();
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i2 = 0;i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}
var init_generateLayoutHash = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set;
  const dupeGroupKeySet = /* @__PURE__ */ new Set;
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key)) {
      return false;
    }
    dupeGroupKeySet.add(key);
    return true;
  });
  return { structs, groups };
}
var init_removeStructAndGroupDuplicates = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
class GpuProgram {
  constructor(options) {
    this._layoutKey = 0;
    this._attributeLocationsKey = 0;
    const { fragment, vertex, layout, gpuLayout, name } = options;
    this.name = name;
    this.fragment = fragment;
    this.vertex = vertex;
    if (fragment.source === vertex.source) {
      const structsAndGroups = extractStructAndGroups(fragment.source);
      this.structsAndGroups = structsAndGroups;
    } else {
      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);
      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);
      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
    }
    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);
    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);
    this._generateProgramKey();
  }
  _generateProgramKey() {
    const { vertex, fragment } = this;
    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;
    this._layoutKey = createIdFromString(bigKey, "program");
  }
  get attributeData() {
    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
    return this._attributeData;
  }
  destroy() {
    this.gpuLayout = null;
    this.layout = null;
    this.structsAndGroups = null;
    this.fragment = null;
    this.vertex = null;
    programCache2[this._cacheKey] = null;
  }
  static from(options) {
    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
    if (!programCache2[key]) {
      programCache2[key] = new GpuProgram(options);
      programCache2[key]._cacheKey = key;
    }
    return programCache2[key];
  }
}
var programCache2;
var init_GpuProgram = __esm(() => {
  init_createIdFromString();
  init_extractAttributesFromGpuProgram();
  init_extractStructAndGroups();
  init_generateGpuLayoutGroups();
  init_generateLayoutHash();
  init_removeStructAndGroupDuplicates();
  programCache2 = /* @__PURE__ */ Object.create(null);
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
function addBits(srcParts, parts, name) {
  if (srcParts) {
    for (const i2 in srcParts) {
      const id = i2.toLocaleLowerCase();
      const part = parts[id];
      if (part) {
        let sanitisedPart = srcParts[i2];
        if (i2 === "header") {
          sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
        }
        if (name) {
          part.push(`//----${name}----//`);
        }
        part.push(sanitisedPart);
      } else {
        warn(`${i2} placement hook does not exist in shader`);
      }
    }
  }
}
var init_addBits = __esm(() => {
  init_warn();
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
function compileHooks(programSrc) {
  const parts = {};
  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
  partMatches.forEach((hook) => {
    parts[hook] = [];
  });
  return parts;
}
var findHooksRx;
var init_compileHooks = __esm(() => {
  findHooksRx = /\{\{(.*?)\}\}/g;
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
function extractInputs(fragmentSource, out) {
  let match;
  const regex = /@in\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out.push(match[1]);
  }
}
function compileInputs(fragments, template, sort = false) {
  const results = [];
  extractInputs(template, results);
  fragments.forEach((fragment) => {
    if (fragment.header) {
      extractInputs(fragment.header, results);
    }
  });
  const mainInput = results;
  if (sort) {
    mainInput.sort();
  }
  const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join(`
`);
  let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
  cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
  return cleanedString;
}
var init_compileInputs = () => {};

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
function extractOutputs(fragmentSource, out) {
  let match;
  const regex = /@out\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out.push(match[1]);
  }
}
function extractVariableName(value) {
  const regex = /\b(\w+)\s*:/g;
  const match = regex.exec(value);
  return match ? match[1] : "";
}
function stripVariable(value) {
  const regex = /@.*?\s+/g;
  return value.replace(regex, "");
}
function compileOutputs(fragments, template) {
  const results = [];
  extractOutputs(template, results);
  fragments.forEach((fragment) => {
    if (fragment.header) {
      extractOutputs(fragment.header, results);
    }
  });
  let index = 0;
  const mainStruct = results.sort().map((inValue) => {
    if (inValue.indexOf("builtin") > -1) {
      return inValue;
    }
    return `@location(${index++}) ${inValue}`;
  }).join(`,
`);
  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(`
`);
  const mainEnd = `return VSOutput(
            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(`,
`)});`;
  let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
  compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
  compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
  compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
  return compiledCode;
}
var init_compileOutputs = () => {};

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
function injectBits(templateSrc, fragmentParts) {
  let out = templateSrc;
  for (const i2 in fragmentParts) {
    const parts = fragmentParts[i2];
    const toInject = parts.join(`
`);
    if (toInject.length) {
      out = out.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join(`
`)}
//----${i2} FINISH----//`);
    } else {
      out = out.replace(`{{${i2}}}`, "");
    }
  }
  return out;
}
var init_injectBits = () => {};

// node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
function compileHighShader({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  const { vertex, fragment } = compileInputsAndOutputs(template, bits);
  cacheMap[cacheId] = compileBits(vertex, fragment, bits);
  return cacheMap[cacheId];
}
function compileHighShaderGl({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
  return cacheMap[cacheId];
}
function compileInputsAndOutputs(template, bits) {
  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
  compiledVertex = compileOutputs(vertexFragments, compiledVertex);
  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
  return {
    vertex: compiledVertex,
    fragment: compiledFragment
  };
}
function generateCacheId(template, bits) {
  return bits.map((highFragment) => {
    if (!bitCacheMap.has(highFragment)) {
      bitCacheMap.set(highFragment, CACHE_UID++);
    }
    return bitCacheMap.get(highFragment);
  }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
}
function compileBits(vertex, fragment, bits) {
  const vertexParts = compileHooks(vertex);
  const fragmentParts = compileHooks(fragment);
  bits.forEach((shaderBit) => {
    addBits(shaderBit.vertex, vertexParts, shaderBit.name);
    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
  });
  return {
    vertex: injectBits(vertex, vertexParts),
    fragment: injectBits(fragment, fragmentParts)
  };
}
var cacheMap, bitCacheMap, CACHE_UID = 0;
var init_compileHighShader = __esm(() => {
  init_addBits();
  init_compileHooks();
  init_compileInputs();
  init_compileOutputs();
  init_injectBits();
  cacheMap = /* @__PURE__ */ Object.create(null);
  bitCacheMap = /* @__PURE__ */ new Map;
});

// node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
var vertexGPUTemplate = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, fragmentGPUTemplate = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, vertexGlTemplate = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, fragmentGlTemplate = `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`;
var init_defaultProgramTemplate = () => {};

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
var globalUniformsBit, globalUniformsBitGl;
var init_globalUniformsBit = __esm(() => {
  globalUniformsBit = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    }
  };
  globalUniformsBitGl = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    }
  };
});

// node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
function compileHighShaderGpuProgram({ bits, name }) {
  const source = compileHighShader({
    template: {
      fragment: fragmentGPUTemplate,
      vertex: vertexGPUTemplate
    },
    bits: [
      globalUniformsBit,
      ...bits
    ]
  });
  return GpuProgram.from({
    name,
    vertex: {
      source: source.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: source.fragment,
      entryPoint: "main"
    }
  });
}
function compileHighShaderGlProgram({ bits, name }) {
  return new GlProgram({
    name,
    ...compileHighShaderGl({
      template: {
        vertex: vertexGlTemplate,
        fragment: fragmentGlTemplate
      },
      bits: [
        globalUniformsBitGl,
        ...bits
      ]
    })
  });
}
var init_compileHighShaderToProgram = __esm(() => {
  init_GlProgram();
  init_GpuProgram();
  init_compileHighShader();
  init_defaultProgramTemplate();
  init_globalUniformsBit();
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
var colorBit, colorBitGl;
var init_colorBit = __esm(() => {
  colorBit = {
    name: "color-bit",
    vertex: {
      header: `
            @in aColor: vec4<f32>;
        `,
      main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  colorBitGl = {
    name: "color-bit",
    vertex: {
      header: `
            in vec4 aColor;
        `,
      main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
function generateBindingSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i2 = 0;i2 < maxTextures; i2++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
    }
  }
  return src.join(`
`);
}
function generateSampleSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  } else {
    src.push("switch vTextureId {");
    for (let i2 = 0;i2 < maxTextures; i2++) {
      if (i2 === maxTextures - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i2}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join(`
`);
}
function generateTextureBatchBit(maxTextures) {
  if (!textureBatchBitGpuCache[maxTextures]) {
    textureBatchBitGpuCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGpuCache[maxTextures];
}
function generateSampleGlSrc(maxTextures) {
  const src = [];
  for (let i2 = 0;i2 < maxTextures; i2++) {
    if (i2 > 0) {
      src.push("else");
    }
    if (i2 < maxTextures - 1) {
      src.push(`if(vTextureId < ${i2}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uTextures[${i2}], vUV);`);
    src.push("}");
  }
  return src.join(`
`);
}
function generateTextureBatchBitGl(maxTextures) {
  if (!textureBatchBitGlCache[maxTextures]) {
    textureBatchBitGlCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures}];

            `,
        main: `

                ${generateSampleGlSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGlCache[maxTextures];
}
var textureBatchBitGpuCache, textureBatchBitGlCache;
var init_generateTextureBatchBit = __esm(() => {
  textureBatchBitGpuCache = {};
  textureBatchBitGlCache = {};
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
var roundPixelsBit, roundPixelsBitGl;
var init_roundPixelsBit = __esm(() => {
  roundPixelsBit = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  roundPixelsBitGl = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs
var UNIFORM_TYPES_VALUES, UNIFORM_TYPES_MAP;
var init_types = __esm(() => {
  UNIFORM_TYPES_VALUES = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    "mat3x4<f32>",
    "vec2<i32>",
    "vec3<i32>",
    "vec4<i32>"
  ];
  UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
    acc[type] = true;
    return acc;
  }, {});
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
function getDefaultUniformValue(type, size) {
  switch (type) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size);
    case "vec3<f32>":
      return new Float32Array(3 * size);
    case "vec4<f32>":
      return new Float32Array(4 * size);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_getDefaultUniformValue = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
var _UniformGroup = class _UniformGroup2 {
  constructor(uniformStructures, options) {
    this._touched = 0;
    this.uid = uid("uniform");
    this._resourceType = "uniformGroup";
    this._resourceId = uid("resource");
    this.isUniformGroup = true;
    this._dirtyId = 0;
    this.destroyed = false;
    options = { ..._UniformGroup2.defaultOptions, ...options };
    this.uniformStructures = uniformStructures;
    const uniforms = {};
    for (const i2 in uniformStructures) {
      const uniformData = uniformStructures[i2];
      uniformData.name = i2;
      uniformData.size = uniformData.size ?? 1;
      if (!UNIFORM_TYPES_MAP[uniformData.type]) {
        const arrayMatch = uniformData.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
        if (arrayMatch) {
          const [, innerType, size] = arrayMatch;
          throw new Error(`Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size} instead.`);
        }
        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
      }
      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
      uniforms[i2] = uniformData.value;
    }
    this.uniforms = uniforms;
    this._dirtyId = 1;
    this.ubo = options.ubo;
    this.isStatic = options.isStatic;
    this._signature = createIdFromString(Object.keys(uniforms).map((i2) => `${i2}-${uniformStructures[i2].type}`).join("-"), "uniform-group");
  }
  update() {
    this._dirtyId++;
  }
}, UniformGroup;
var init_UniformGroup = __esm(() => {
  init_uid();
  init_createIdFromString();
  init_types();
  init_getDefaultUniformValue();
  _UniformGroup.defaultOptions = {
    ubo: false,
    isStatic: false
  };
  UniformGroup = _UniformGroup;
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs
function getBatchSamplersUniformGroup(maxTextures) {
  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];
  if (batchSamplersUniformGroup)
    return batchSamplersUniformGroup;
  const sampleValues = new Int32Array(maxTextures);
  for (let i2 = 0;i2 < maxTextures; i2++) {
    sampleValues[i2] = i2;
  }
  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({
    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }
  }, { isStatic: true });
  return batchSamplersUniformGroup;
}
var batchSamplersUniformGroupHash;
var init_getBatchSamplersUniformGroup = __esm(() => {
  init_UniformGroup();
  batchSamplersUniformGroupHash = {};
});

// node_modules/pixi.js/lib/rendering/renderers/types.mjs
var RendererType;
var init_types2 = __esm(() => {
  RendererType = /* @__PURE__ */ ((RendererType2) => {
    RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
    RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
    RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
    return RendererType2;
  })(RendererType || {});
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
var Shader;
var init_Shader = __esm(() => {
  init_eventemitter3();
  init_uid();
  init_GlProgram();
  init_BindGroup();
  init_GpuProgram();
  init_types2();
  init_UniformGroup();
  Shader = class Shader extends eventemitter3_default {
    constructor(options) {
      super();
      this.uid = uid("shader");
      this._uniformBindMap = /* @__PURE__ */ Object.create(null);
      this._ownedBindGroups = [];
      let {
        gpuProgram,
        glProgram,
        groups,
        resources,
        compatibleRenderers,
        groupMap
      } = options;
      this.gpuProgram = gpuProgram;
      this.glProgram = glProgram;
      if (compatibleRenderers === undefined) {
        compatibleRenderers = 0;
        if (gpuProgram)
          compatibleRenderers |= RendererType.WEBGPU;
        if (glProgram)
          compatibleRenderers |= RendererType.WEBGL;
      }
      this.compatibleRenderers = compatibleRenderers;
      const nameHash = {};
      if (!resources && !groups) {
        resources = {};
      }
      if (resources && groups) {
        throw new Error("[Shader] Cannot have both resources and groups");
      } else if (!gpuProgram && groups && !groupMap) {
        throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
      } else if (!gpuProgram && groups && groupMap) {
        for (const i2 in groupMap) {
          for (const j2 in groupMap[i2]) {
            const uniformName = groupMap[i2][j2];
            nameHash[uniformName] = {
              group: i2,
              binding: j2,
              name: uniformName
            };
          }
        }
      } else if (gpuProgram && groups && !groupMap) {
        const groupData = gpuProgram.structsAndGroups.groups;
        groupMap = {};
        groupData.forEach((data) => {
          groupMap[data.group] = groupMap[data.group] || {};
          groupMap[data.group][data.binding] = data.name;
          nameHash[data.name] = data;
        });
      } else if (resources) {
        groups = {};
        groupMap = {};
        if (gpuProgram) {
          const groupData = gpuProgram.structsAndGroups.groups;
          groupData.forEach((data) => {
            groupMap[data.group] = groupMap[data.group] || {};
            groupMap[data.group][data.binding] = data.name;
            nameHash[data.name] = data;
          });
        }
        let bindTick = 0;
        for (const i2 in resources) {
          if (nameHash[i2])
            continue;
          if (!groups[99]) {
            groups[99] = new BindGroup;
            this._ownedBindGroups.push(groups[99]);
          }
          nameHash[i2] = { group: 99, binding: bindTick, name: i2 };
          groupMap[99] = groupMap[99] || {};
          groupMap[99][bindTick] = i2;
          bindTick++;
        }
        for (const i2 in resources) {
          const name = i2;
          let value = resources[i2];
          if (!value.source && !value._resourceType) {
            value = new UniformGroup(value);
          }
          const data = nameHash[name];
          if (data) {
            if (!groups[data.group]) {
              groups[data.group] = new BindGroup;
              this._ownedBindGroups.push(groups[data.group]);
            }
            groups[data.group].setResource(value, data.binding);
          }
        }
      }
      this.groups = groups;
      this._uniformBindMap = groupMap;
      this.resources = this._buildResourceAccessor(groups, nameHash);
    }
    addResource(name, groupIndex, bindIndex) {
      var _a, _b;
      (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
      (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
      if (!this.groups[groupIndex]) {
        this.groups[groupIndex] = new BindGroup;
        this._ownedBindGroups.push(this.groups[groupIndex]);
      }
    }
    _buildResourceAccessor(groups, nameHash) {
      const uniformsOut = {};
      for (const i2 in nameHash) {
        const data = nameHash[i2];
        Object.defineProperty(uniformsOut, data.name, {
          get() {
            return groups[data.group].getResource(data.binding);
          },
          set(value) {
            groups[data.group].setResource(value, data.binding);
          }
        });
      }
      return uniformsOut;
    }
    destroy(destroyPrograms = false) {
      this.emit("destroy", this);
      if (destroyPrograms) {
        this.gpuProgram?.destroy();
        this.glProgram?.destroy();
      }
      this.gpuProgram = null;
      this.glProgram = null;
      this.removeAllListeners();
      this._uniformBindMap = null;
      this._ownedBindGroups.forEach((bindGroup) => {
        bindGroup.destroy();
      });
      this._ownedBindGroups = null;
      this.resources = null;
      this.groups = null;
    }
    static from(options) {
      const { gpu, gl, ...rest } = options;
      let gpuProgram;
      let glProgram;
      if (gpu) {
        gpuProgram = GpuProgram.from(gpu);
      }
      if (gl) {
        glProgram = GlProgram.from(gl);
      }
      return new Shader({
        gpuProgram,
        glProgram,
        ...rest
      });
    }
  };
});

// node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs
var DefaultShader;
var init_DefaultShader = __esm(() => {
  init_compileHighShaderToProgram();
  init_colorBit();
  init_generateTextureBatchBit();
  init_roundPixelsBit();
  init_getBatchSamplersUniformGroup();
  init_Shader();
  DefaultShader = class DefaultShader extends Shader {
    constructor(maxTextures) {
      const glProgram = compileHighShaderGlProgram({
        name: "batch",
        bits: [
          colorBitGl,
          generateTextureBatchBitGl(maxTextures),
          roundPixelsBitGl
        ]
      });
      const gpuProgram = compileHighShaderGpuProgram({
        name: "batch",
        bits: [
          colorBit,
          generateTextureBatchBit(maxTextures),
          roundPixelsBit
        ]
      });
      super({
        glProgram,
        gpuProgram,
        resources: {
          batchSamplers: getBatchSamplersUniformGroup(maxTextures)
        }
      });
    }
  };
});

// node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs
var defaultShader = null, _DefaultBatcher, DefaultBatcher;
var init_DefaultBatcher = __esm(() => {
  init_Extensions();
  init_Batcher();
  init_BatchGeometry();
  init_DefaultShader();
  _DefaultBatcher = class _DefaultBatcher2 extends Batcher {
    constructor(options) {
      super(options);
      this.geometry = new BatchGeometry;
      this.name = _DefaultBatcher2.extension.name;
      this.vertexSize = 6;
      defaultShader ?? (defaultShader = new DefaultShader(options.maxTextures));
      this.shader = defaultShader;
    }
    packAttributes(element, float32View, uint32View, index, textureId) {
      const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
      const wt = element.transform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c2 = wt.c;
      const d2 = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const { positions, uvs } = element;
      const argb = element.color;
      const offset = element.attributeOffset;
      const end = offset + element.attributeSize;
      for (let i2 = offset;i2 < end; i2++) {
        const i22 = i2 * 2;
        const x2 = positions[i22];
        const y2 = positions[i22 + 1];
        float32View[index++] = a2 * x2 + c2 * y2 + tx;
        float32View[index++] = d2 * y2 + b2 * x2 + ty;
        float32View[index++] = uvs[i22];
        float32View[index++] = uvs[i22 + 1];
        uint32View[index++] = argb;
        uint32View[index++] = textureIdAndRound;
      }
    }
    packQuadAttributes(element, float32View, uint32View, index, textureId) {
      const texture = element.texture;
      const wt = element.transform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c2 = wt.c;
      const d2 = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const bounds = element.bounds;
      const w0 = bounds.maxX;
      const w1 = bounds.minX;
      const h0 = bounds.maxY;
      const h1 = bounds.minY;
      const uvs = texture.uvs;
      const argb = element.color;
      const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
      float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
      float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
      float32View[index + 2] = uvs.x0;
      float32View[index + 3] = uvs.y0;
      uint32View[index + 4] = argb;
      uint32View[index + 5] = textureIdAndRound;
      float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
      float32View[index + 7] = d2 * h1 + b2 * w0 + ty;
      float32View[index + 8] = uvs.x1;
      float32View[index + 9] = uvs.y1;
      uint32View[index + 10] = argb;
      uint32View[index + 11] = textureIdAndRound;
      float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
      float32View[index + 13] = d2 * h0 + b2 * w0 + ty;
      float32View[index + 14] = uvs.x2;
      float32View[index + 15] = uvs.y2;
      uint32View[index + 16] = argb;
      uint32View[index + 17] = textureIdAndRound;
      float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
      float32View[index + 19] = d2 * h0 + b2 * w1 + ty;
      float32View[index + 20] = uvs.x3;
      float32View[index + 21] = uvs.y3;
      uint32View[index + 22] = argb;
      uint32View[index + 23] = textureIdAndRound;
    }
  };
  _DefaultBatcher.extension = {
    type: [
      ExtensionType.Batcher
    ],
    name: "default"
  };
  DefaultBatcher = _DefaultBatcher;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
  let index = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index < size) {
    const x2 = vertices[verticesOffset];
    const y2 = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
    uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
  let index = 0;
  uvsOffset *= uvsStride;
  while (index < size) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index++;
  }
}
var init_buildUvs = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
function transformVertices(vertices, m2, offset, stride, size) {
  const a2 = m2.a;
  const b2 = m2.b;
  const c2 = m2.c;
  const d2 = m2.d;
  const tx = m2.tx;
  const ty = m2.ty;
  offset || (offset = 0);
  stride || (stride = 2);
  size || (size = vertices.length / stride - offset);
  let index = offset * stride;
  for (let i2 = 0;i2 < size; i2++) {
    const x2 = vertices[index];
    const y2 = vertices[index + 1];
    vertices[index] = a2 * x2 + c2 * y2 + tx;
    vertices[index + 1] = b2 * x2 + d2 * y2 + ty;
    index += stride;
  }
}
var init_transformVertices = () => {};

// node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
class BatchableGraphics {
  constructor() {
    this.packAsQuad = false;
    this.batcherName = "default";
    this.topology = "triangle-list";
    this.applyTransform = true;
    this.roundPixels = 0;
    this._batcher = null;
    this._batch = null;
  }
  get uvs() {
    return this.geometryData.uvs;
  }
  get positions() {
    return this.geometryData.vertices;
  }
  get indices() {
    return this.geometryData.indices;
  }
  get blendMode() {
    if (this.renderable && this.applyTransform) {
      return this.renderable.groupBlendMode;
    }
    return "normal";
  }
  get color() {
    const rgb = this.baseColor;
    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
    const renderable = this.renderable;
    if (renderable) {
      return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
    }
    return bgr + (this.alpha * 255 << 24);
  }
  get transform() {
    return this.renderable?.groupTransform || identityMatrix2;
  }
  copyTo(gpuBuffer) {
    gpuBuffer.indexOffset = this.indexOffset;
    gpuBuffer.indexSize = this.indexSize;
    gpuBuffer.attributeOffset = this.attributeOffset;
    gpuBuffer.attributeSize = this.attributeSize;
    gpuBuffer.baseColor = this.baseColor;
    gpuBuffer.alpha = this.alpha;
    gpuBuffer.texture = this.texture;
    gpuBuffer.geometryData = this.geometryData;
    gpuBuffer.topology = this.topology;
  }
  reset() {
    this.applyTransform = true;
    this.renderable = null;
    this.topology = "triangle-list";
  }
  destroy() {
    this.renderable = null;
    this.texture = null;
    this.geometryData = null;
    this._batcher = null;
    this._batch = null;
  }
}
var identityMatrix2;
var init_BatchableGraphics = __esm(() => {
  init_Matrix();
  init_multiplyHexColors();
  identityMatrix2 = new Matrix;
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
var buildCircle, buildEllipse, buildRoundedRectangle;
var init_buildCircle = __esm(() => {
  init_Extensions();
  buildCircle = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "circle"
    },
    build(shape, points) {
      let x2;
      let y2;
      let dx;
      let dy;
      let rx;
      let ry;
      if (shape.type === "circle") {
        const circle = shape;
        rx = ry = circle.radius;
        if (rx <= 0) {
          return false;
        }
        x2 = circle.x;
        y2 = circle.y;
        dx = dy = 0;
      } else if (shape.type === "ellipse") {
        const ellipse = shape;
        rx = ellipse.halfWidth;
        ry = ellipse.halfHeight;
        if (rx <= 0 || ry <= 0) {
          return false;
        }
        x2 = ellipse.x;
        y2 = ellipse.y;
        dx = dy = 0;
      } else {
        const roundedRect = shape;
        const halfWidth = roundedRect.width / 2;
        const halfHeight = roundedRect.height / 2;
        x2 = roundedRect.x + halfWidth;
        y2 = roundedRect.y + halfHeight;
        rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
        dx = halfWidth - rx;
        dy = halfHeight - ry;
      }
      if (dx < 0 || dy < 0) {
        return false;
      }
      const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
      const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
      if (m2 === 0) {
        return false;
      }
      if (n2 === 0) {
        points[0] = points[6] = x2 + dx;
        points[1] = points[3] = y2 + dy;
        points[2] = points[4] = x2 - dx;
        points[5] = points[7] = y2 - dy;
        return true;
      }
      let j1 = 0;
      let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
      let j3 = j2;
      let j4 = m2;
      let x0 = dx + rx;
      let y0 = dy;
      let x1 = x2 + x0;
      let x22 = x2 - x0;
      let y1 = y2 + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      if (dy) {
        const y222 = y2 - y0;
        points[j3++] = x22;
        points[j3++] = y222;
        points[--j4] = y222;
        points[--j4] = x1;
      }
      for (let i2 = 1;i2 < n2; i2++) {
        const a2 = Math.PI / 2 * (i2 / n2);
        const x02 = dx + Math.cos(a2) * rx;
        const y02 = dy + Math.sin(a2) * ry;
        const x12 = x2 + x02;
        const x222 = x2 - x02;
        const y12 = y2 + y02;
        const y222 = y2 - y02;
        points[j1++] = x12;
        points[j1++] = y12;
        points[--j2] = y12;
        points[--j2] = x222;
        points[j3++] = x222;
        points[j3++] = y222;
        points[--j4] = y222;
        points[--j4] = x12;
      }
      x0 = dx;
      y0 = dy + ry;
      x1 = x2 + x0;
      x22 = x2 - x0;
      y1 = y2 + y0;
      const y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y22;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x22;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x22;
      }
      return true;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      if (points.length === 0) {
        return;
      }
      let centerX = 0;
      let centerY = 0;
      for (let i2 = 0;i2 < points.length; i2 += 2) {
        centerX += points[i2];
        centerY += points[i2 + 1];
      }
      centerX /= points.length / 2;
      centerY /= points.length / 2;
      let count2 = verticesOffset;
      vertices[count2 * verticesStride] = centerX;
      vertices[count2 * verticesStride + 1] = centerY;
      const centerIndex = count2++;
      for (let i2 = 0;i2 < points.length; i2 += 2) {
        vertices[count2 * verticesStride] = points[i2];
        vertices[count2 * verticesStride + 1] = points[i2 + 1];
        if (i2 > 0) {
          indices[indicesOffset++] = count2;
          indices[indicesOffset++] = centerIndex;
          indices[indicesOffset++] = count2 - 1;
        }
        count2++;
      }
      indices[indicesOffset++] = centerIndex + 1;
      indices[indicesOffset++] = centerIndex;
      indices[indicesOffset++] = count2 - 1;
    }
  };
  buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };
  buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };
});

// node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
var closePointEps = 0.0001, curveEps = 0.0001;
var init_const6 = () => {};

// node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
function getOrientationOfPoints(points) {
  const m2 = points.length;
  if (m2 < 6) {
    return 1;
  }
  let area = 0;
  for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1];i2 < m2; i2 += 2) {
    const x2 = points[i2];
    const y2 = points[i2 + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (area < 0) {
    return -1;
  }
  return 1;
}
var init_getOrientationOfPoints = () => {};

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x2 - nx * innerWeight;
  const iy = y2 - ny * innerWeight;
  const ox = x2 + nx * outerWeight;
  const oy = y2 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i2 = 1, angle = startAngle;i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i2 = 1, angle = startAngle;i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = getOrientationOfPoints(points);
    if (flipAlignment)
      orientation *= -1;
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(x0 - perpX * (innerWeight - outerWeight) * 0.5, y0 - perpY * (innerWeight - outerWeight) * 0.5, x0 - perpX * innerWeight, y0 - perpY * innerWeight, x0 + perpX * outerWeight, y0 + perpY * outerWeight, verts, true) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpX * innerWeight, y0 - perpY * innerWeight);
  verts.push(x0 + perpX * outerWeight, y0 + perpY * outerWeight);
  for (let i2 = 1;i2 < length - 1; ++i2) {
    x0 = points[(i2 - 1) * 2];
    y0 = points[(i2 - 1) * 2 + 1];
    x1 = points[i2 * 2];
    y1 = points[i2 * 2 + 1];
    x2 = points[(i2 + 1) * 2];
    y2 = points[(i2 + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 0.001 * Math.abs(dot)) {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);
        verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
        } else {
          indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(x1 - perpX * (innerWeight - outerWeight) * 0.5, y1 - perpY * (innerWeight - outerWeight) * 0.5, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 + perpX * outerWeight, y1 + perpY * outerWeight, verts, false) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = curveEps * curveEps;
  for (let i2 = indexStart;i2 < indexCount + indexStart - 2; ++i2) {
    x0 = verts[i2 * 2];
    y0 = verts[i2 * 2 + 1];
    x1 = verts[(i2 + 1) * 2];
    y1 = verts[(i2 + 1) * 2 + 1];
    x2 = verts[(i2 + 2) * 2];
    y2 = verts[(i2 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i2, i2 + 1, i2 + 2);
  }
}
var init_buildLine = __esm(() => {
  init_Point();
  init_const6();
  init_getOrientationOfPoints();
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs
function buildPixelLine(points, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const fx = points[0];
  const fy = points[1];
  const lx = points[points.length - 2];
  const ly = points[points.length - 1];
  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;
  const verts = vertices;
  const length = points.length / 2;
  const indexStart = verts.length / 2;
  for (let i2 = 0;i2 < length; i2++) {
    verts.push(points[i2 * 2]);
    verts.push(points[i2 * 2 + 1]);
  }
  for (let i2 = 0;i2 < length - 1; i2++) {
    indices.push(indexStart + i2, indexStart + i2 + 1);
  }
  if (closePath) {
    indices.push(indexStart + length - 1, indexStart);
  }
}
var init_buildPixelLine = __esm(() => {
  init_const6();
});

// node_modules/earcut/src/earcut.js
function earcut(data, holeIndices, dim = 2) {
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  let outerNode = linkedList(data, 0, outerLen, dim, true);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  let minX, minY, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = data[0];
    minY = data[1];
    let maxX = minX;
    let maxY = minY;
    for (let i2 = dim;i2 < outerLen; i2 += dim) {
      const x2 = data[i2];
      const y2 = data[i2 + 1];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  let last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (let i2 = start;i2 < end; i2 += dim)
      last = insertNode(i2 / dim | 0, data[i2], data[i2 + 1], last);
  } else {
    for (let i2 = end - dim;i2 >= start; i2 -= dim)
      last = insertNode(i2 / dim | 0, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  while (ear.prev !== ear.next) {
    const prev = ear.prev;
    const next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i, ear.i, next.i);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
  let p2 = c2.next;
  while (p2 !== a2) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let { prevZ: p2, nextZ: n2 } = ear;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles) {
  let p2 = start;
  do {
    const a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i, p2.i, b2.i);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        let c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  for (let i2 = 0, len = holeIndices.length;i2 < len; i2++) {
    const start = holeIndices[i2] * dim;
    const end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    const list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareXYSlope);
  for (let i2 = 0;i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
  }
  return outerNode;
}
function compareXYSlope(a2, b2) {
  let result = a2.x - b2.x;
  if (result === 0) {
    result = a2.y - b2.y;
    if (result === 0) {
      const aSlope = (a2.next.y - a2.y) / (a2.next.x - a2.x);
      const bSlope = (b2.next.y - b2.y) / (b2.next.x - b2.x);
      result = aSlope - bSlope;
    }
  }
  return result;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m2;
  if (equals(hole, p2))
    return p2;
  do {
    if (equals(hole, p2.next))
      return p2.next;
    else if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m2 = p2.x < p2.next.x ? p2 : p2.next;
        if (x2 === hx)
          return m2;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2)
    return null;
  const stop = m2;
  const mx = m2.x;
  const my = m2.y;
  let tanMin = Infinity;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      const tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === 0)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let numMerges;
  let inSize = 1;
  do {
    let p2 = list;
    let e2;
    list = null;
    let tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      let q = p2;
      let pSize = 0;
      for (let i2 = 0;i2 < inSize; i2++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      let qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = (x2 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
  return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q, r2) {
  return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q, r2) {
  return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  let p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
      return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  let p2 = a2;
  let inside = false;
  const px = (a2.x + b2.x) / 2;
  const py = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  const a22 = createNode(a2.i, a2.x, a2.y), b22 = createNode(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last) {
  const p2 = createNode(i2, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function createNode(i2, x2, y2) {
  return {
    i: i2,
    x: x2,
    y: y2,
    prev: null,
    next: null,
    z: 0,
    prevZ: null,
    nextZ: null,
    steiner: false
  };
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j2 = end - dim;i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}

// node_modules/pixi.js/lib/utils/utils.mjs
var earcut2;
var init_utils = __esm(() => {
  init_eventemitter3();
  earcut2 = earcut.default || earcut;
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = earcut2(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i2 = 0;i2 < triangles.length; i2 += 3) {
    indices[indicesOffset++] = triangles[i2] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
  }
  let index = verticesOffset * verticesStride;
  for (let i2 = 0;i2 < points.length; i2 += 2) {
    vertices[index] = points[i2];
    vertices[index + 1] = points[i2 + 1];
    index += verticesStride;
  }
}
var init_triangulateWithHoles = __esm(() => {
  init_utils();
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
var emptyArray, buildPolygon;
var init_buildPolygon = __esm(() => {
  init_Extensions();
  init_triangulateWithHoles();
  emptyArray = [];
  buildPolygon = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "polygon"
    },
    build(shape, points) {
      for (let i2 = 0;i2 < shape.points.length; i2++) {
        points[i2] = shape.points[i2];
      }
      return true;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
    }
  };
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
var buildRectangle;
var init_buildRectangle = __esm(() => {
  init_Extensions();
  buildRectangle = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "rectangle"
    },
    build(shape, points) {
      const rectData = shape;
      const x2 = rectData.x;
      const y2 = rectData.y;
      const width = rectData.width;
      const height = rectData.height;
      if (!(width > 0 && height > 0)) {
        return false;
      }
      points[0] = x2;
      points[1] = y2;
      points[2] = x2 + width;
      points[3] = y2;
      points[4] = x2 + width;
      points[5] = y2 + height;
      points[6] = x2;
      points[7] = y2 + height;
      return true;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      let count2 = 0;
      verticesOffset *= verticesStride;
      vertices[verticesOffset + count2] = points[0];
      vertices[verticesOffset + count2 + 1] = points[1];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[2];
      vertices[verticesOffset + count2 + 1] = points[3];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[6];
      vertices[verticesOffset + count2 + 1] = points[7];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[4];
      vertices[verticesOffset + count2 + 1] = points[5];
      count2 += verticesStride;
      const verticesIndex = verticesOffset / verticesStride;
      indices[indicesOffset++] = verticesIndex;
      indices[indicesOffset++] = verticesIndex + 1;
      indices[indicesOffset++] = verticesIndex + 2;
      indices[indicesOffset++] = verticesIndex + 1;
      indices[indicesOffset++] = verticesIndex + 3;
      indices[indicesOffset++] = verticesIndex + 2;
    }
  };
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
var buildTriangle;
var init_buildTriangle = __esm(() => {
  init_Extensions();
  buildTriangle = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "triangle"
    },
    build(shape, points) {
      points[0] = shape.x;
      points[1] = shape.y;
      points[2] = shape.x2;
      points[3] = shape.y2;
      points[4] = shape.x3;
      points[5] = shape.y3;
      return true;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      let count2 = 0;
      verticesOffset *= verticesStride;
      vertices[verticesOffset + count2] = points[0];
      vertices[verticesOffset + count2 + 1] = points[1];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[2];
      vertices[verticesOffset + count2 + 1] = points[3];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[4];
      vertices[verticesOffset + count2 + 1] = points[5];
      const verticesIndex = verticesOffset / verticesStride;
      indices[indicesOffset++] = verticesIndex;
      indices[indicesOffset++] = verticesIndex + 1;
      indices[indicesOffset++] = verticesIndex + 2;
    }
  };
});

// node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
function addColorStops(gradient, colorStops) {
  for (let i2 = 0;i2 < colorStops.length; i2++) {
    const stop = colorStops[i2];
    gradient.addColorStop(stop.offset, stop.color);
  }
}
function getCanvas(width, height) {
  const canvas = DOMAdapter.get().createCanvas(width, height);
  const context2 = canvas.getContext("2d");
  return { canvas, context: context2 };
}
function ensureGradientOptions(args) {
  let options = args[0] ?? {};
  if (typeof options === "number" || args[1]) {
    deprecation("8.5.2", `use options object instead`);
    options = {
      type: "linear",
      start: { x: args[0], y: args[1] },
      end: { x: args[2], y: args[3] },
      textureSpace: args[4],
      textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize
    };
  }
  return options;
}
var emptyColorStops, _FillGradient = class _FillGradient2 {
  constructor(...args) {
    this.uid = uid("fillGradient");
    this._tick = 0;
    this.type = "linear";
    this.colorStops = [];
    let options = ensureGradientOptions(args);
    const defaults = options.type === "radial" ? _FillGradient2.defaultRadialOptions : _FillGradient2.defaultLinearOptions;
    options = { ...defaults, ...definedProps(options) };
    this._textureSize = options.textureSize;
    this._wrapMode = options.wrapMode;
    if (options.type === "radial") {
      this.center = options.center;
      this.outerCenter = options.outerCenter ?? this.center;
      this.innerRadius = options.innerRadius;
      this.outerRadius = options.outerRadius;
      this.scale = options.scale;
      this.rotation = options.rotation;
    } else {
      this.start = options.start;
      this.end = options.end;
    }
    this.textureSpace = options.textureSpace;
    this.type = options.type;
    options.colorStops.forEach((stop) => {
      this.addColorStop(stop.offset, stop.color);
    });
  }
  addColorStop(offset, color) {
    this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });
    return this;
  }
  buildLinearGradient() {
    if (this.texture)
      return;
    let { x: x0, y: y0 } = this.start;
    let { x: x1, y: y1 } = this.end;
    let dx = x1 - x0;
    let dy = y1 - y0;
    const flip = dx < 0 || dy < 0;
    if (this._wrapMode === "clamp-to-edge") {
      if (dx < 0) {
        const temp = x0;
        x0 = x1;
        x1 = temp;
        dx *= -1;
      }
      if (dy < 0) {
        const temp = y0;
        y0 = y1;
        y1 = temp;
        dy *= -1;
      }
    }
    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
    const defaultSize = this._textureSize;
    const { canvas, context: context2 } = getCanvas(defaultSize, 1);
    const gradient = !flip ? context2.createLinearGradient(0, 0, this._textureSize, 0) : context2.createLinearGradient(this._textureSize, 0, 0, 0);
    addColorStops(gradient, colorStops);
    context2.fillStyle = gradient;
    context2.fillRect(0, 0, defaultSize, 1);
    this.texture = new Texture({
      source: new ImageSource({
        resource: canvas,
        addressMode: this._wrapMode
      })
    });
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    const m2 = new Matrix;
    m2.scale(dist / defaultSize, 1);
    m2.rotate(angle);
    m2.translate(x0, y0);
    if (this.textureSpace === "local") {
      m2.scale(defaultSize, defaultSize);
    }
    this.transform = m2;
  }
  buildGradient() {
    if (!this.texture)
      this._tick++;
    if (this.type === "linear") {
      this.buildLinearGradient();
    } else {
      this.buildRadialGradient();
    }
  }
  buildRadialGradient() {
    if (this.texture)
      return;
    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
    const defaultSize = this._textureSize;
    const { canvas, context: context2 } = getCanvas(defaultSize, defaultSize);
    const { x: x0, y: y0 } = this.center;
    const { x: x1, y: y1 } = this.outerCenter;
    const r0 = this.innerRadius;
    const r1 = this.outerRadius;
    const ox = x1 - r1;
    const oy = y1 - r1;
    const scale = defaultSize / (r1 * 2);
    const cx = (x0 - ox) * scale;
    const cy = (y0 - oy) * scale;
    const gradient = context2.createRadialGradient(cx, cy, r0 * scale, (x1 - ox) * scale, (y1 - oy) * scale, r1 * scale);
    addColorStops(gradient, colorStops);
    context2.fillStyle = colorStops[colorStops.length - 1].color;
    context2.fillRect(0, 0, defaultSize, defaultSize);
    context2.fillStyle = gradient;
    context2.translate(cx, cy);
    context2.rotate(this.rotation);
    context2.scale(1, this.scale);
    context2.translate(-cx, -cy);
    context2.fillRect(0, 0, defaultSize, defaultSize);
    this.texture = new Texture({
      source: new ImageSource({
        resource: canvas,
        addressMode: this._wrapMode
      })
    });
    const m2 = new Matrix;
    m2.scale(1 / scale, 1 / scale);
    m2.translate(ox, oy);
    if (this.textureSpace === "local") {
      m2.scale(defaultSize, defaultSize);
    }
    this.transform = m2;
  }
  destroy() {
    this.texture?.destroy(true);
    this.texture = null;
    this.transform = null;
    this.colorStops = [];
    this.start = null;
    this.end = null;
    this.center = null;
    this.outerCenter = null;
  }
  get styleKey() {
    return `fill-gradient-${this.uid}-${this._tick}`;
  }
}, FillGradient;
var init_FillGradient = __esm(() => {
  init_Color();
  init_adapter();
  init_Matrix();
  init_ImageSource();
  init_Texture();
  init_uid();
  init_deprecation();
  init_definedProps();
  emptyColorStops = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }];
  _FillGradient.defaultLinearOptions = {
    start: { x: 0, y: 0 },
    end: { x: 0, y: 1 },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256,
    wrapMode: "clamp-to-edge"
  };
  _FillGradient.defaultRadialOptions = {
    center: { x: 0.5, y: 0.5 },
    innerRadius: 0,
    outerRadius: 0.5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256,
    wrapMode: "clamp-to-edge"
  };
  FillGradient = _FillGradient;
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs
function generateTextureMatrix(out, style, shape, matrix) {
  const textureMatrix = style.matrix ? out.copyFrom(style.matrix).invert() : out.identity();
  if (style.textureSpace === "local") {
    const bounds = shape.getBounds(tempRect);
    if (style.width) {
      bounds.pad(style.width);
    }
    const { x: tx, y: ty } = bounds;
    const sx = 1 / bounds.width;
    const sy = 1 / bounds.height;
    const mTx = -tx * sx;
    const mTy = -ty * sy;
    const a1 = textureMatrix.a;
    const b1 = textureMatrix.b;
    const c1 = textureMatrix.c;
    const d1 = textureMatrix.d;
    textureMatrix.a *= sx;
    textureMatrix.b *= sx;
    textureMatrix.c *= sy;
    textureMatrix.d *= sy;
    textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;
    textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;
  } else {
    textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);
    textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
  }
  const sourceStyle = style.texture.source.style;
  if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === "clamp-to-edge") {
    sourceStyle.addressMode = "repeat";
    sourceStyle.update();
  }
  if (matrix) {
    textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());
  }
  return textureMatrix;
}
var tempTextureMatrix, tempRect;
var init_generateTextureFillMatrix = __esm(() => {
  init_Matrix();
  init_Rectangle();
  init_FillGradient();
  tempTextureMatrix = new Matrix;
  tempRect = new Rectangle;
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
function buildContextBatches(context2, gpuContext) {
  const { geometryData, batches } = gpuContext;
  batches.length = 0;
  geometryData.indices.length = 0;
  geometryData.vertices.length = 0;
  geometryData.uvs.length = 0;
  for (let i2 = 0;i2 < context2.instructions.length; i2++) {
    const instruction = context2.instructions[i2];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);
      }
      if (hole) {
        shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;
      }
      addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);
    }
  }
}
function addTextureToGeometryData(data, batches, geometryData) {
  const points = [];
  const build = shapeBuilders.rectangle;
  const rect = tempRect2;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  if (!build.build(rect, points)) {
    return;
  }
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  if (matrix) {
    transformVertices(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const texture = data.image;
  const textureUvs = texture.uvs;
  uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);
  const graphicsBatch = BigPool.get(BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.attributeOffset = vertOffset;
  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
  graphicsBatch.baseColor = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) => {
    const points = [];
    const build = shapeBuilders[shape.type];
    if (!build.build(shape, points)) {
      return;
    }
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    let topology = "triangle-list";
    if (matrix) {
      transformVertices(points, matrix);
    }
    if (!isStroke) {
      if (holes) {
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(holes);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      if (!lineStyle.pixelLine) {
        buildLine(points, lineStyle, false, close, vertices, indices);
      } else {
        buildPixelLine(points, close, vertices, indices);
        topology = "line-list";
      }
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== Texture.WHITE) {
      const textureMatrix = generateTextureMatrix(tempTextureMatrix2, style, shape, matrix);
      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    graphicsBatch.topology = topology;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(holePrimitives) {
  const holeArrays = [];
  for (let k2 = 0;k2 < holePrimitives.length; k2++) {
    const holePrimitive = holePrimitives[k2].shape;
    const holePoints = [];
    const holeBuilder = shapeBuilders[holePrimitive.type];
    if (holeBuilder.build(holePrimitive, holePoints)) {
      holeArrays.push(holePoints);
    }
  }
  return holeArrays;
}
var shapeBuilders, tempRect2, tempTextureMatrix2;
var init_buildContextBatches = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_Rectangle();
  init_buildUvs();
  init_transformVertices();
  init_Texture();
  init_PoolGroup();
  init_BatchableGraphics();
  init_buildCircle();
  init_buildLine();
  init_buildPixelLine();
  init_buildPolygon();
  init_buildRectangle();
  init_buildTriangle();
  init_generateTextureFillMatrix();
  init_triangulateWithHoles();
  shapeBuilders = {};
  extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
  extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
  tempRect2 = new Rectangle;
  tempTextureMatrix2 = new Matrix;
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
class GpuGraphicsContext {
  constructor() {
    this.batches = [];
    this.geometryData = {
      vertices: [],
      uvs: [],
      indices: []
    };
  }
}

class GraphicsContextRenderData {
  constructor() {
    this.instructions = new InstructionSet;
  }
  init(maxTextures) {
    this.batcher = new DefaultBatcher({
      maxTextures
    });
    this.instructions.reset();
  }
  get geometry() {
    deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
    return this.batcher.geometry;
  }
  destroy() {
    this.batcher.destroy();
    this.instructions.destroy();
    this.batcher = null;
    this.instructions = null;
  }
}
var _GraphicsContextSystem = class _GraphicsContextSystem2 {
  constructor(renderer) {
    this._gpuContextHash = {};
    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    renderer.renderableGC.addManagedHash(this, "_gpuContextHash");
    renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
  }
  init(options) {
    _GraphicsContextSystem2.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
  }
  getContextRenderData(context2) {
    return this._graphicsDataContextHash[context2.uid] || this._initContextRenderData(context2);
  }
  updateGpuContext(context2) {
    let gpuContext = this._gpuContextHash[context2.uid] || this._initContext(context2);
    if (context2.dirty) {
      if (gpuContext) {
        this._cleanGraphicsContextData(context2);
      } else {
        gpuContext = this._initContext(context2);
      }
      buildContextBatches(context2, gpuContext);
      const batchMode = context2.batchMode;
      if (context2.customShader || batchMode === "no-batch") {
        gpuContext.isBatchable = false;
      } else if (batchMode === "auto") {
        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
      } else {
        gpuContext.isBatchable = true;
      }
      context2.dirty = false;
    }
    return gpuContext;
  }
  getGpuContext(context2) {
    return this._gpuContextHash[context2.uid] || this._initContext(context2);
  }
  _initContextRenderData(context2) {
    const graphicsData = BigPool.get(GraphicsContextRenderData, {
      maxTextures: this._renderer.limits.maxBatchableTextures
    });
    const { batches, geometryData } = this._gpuContextHash[context2.uid];
    const vertexSize = geometryData.vertices.length;
    const indexSize = geometryData.indices.length;
    for (let i2 = 0;i2 < batches.length; i2++) {
      batches[i2].applyTransform = false;
    }
    const batcher = graphicsData.batcher;
    batcher.ensureAttributeBuffer(vertexSize);
    batcher.ensureIndexBuffer(indexSize);
    batcher.begin();
    for (let i2 = 0;i2 < batches.length; i2++) {
      const batch = batches[i2];
      batcher.add(batch);
    }
    batcher.finish(graphicsData.instructions);
    const geometry = batcher.geometry;
    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
    const drawBatches = batcher.batches;
    for (let i2 = 0;i2 < drawBatches.length; i2++) {
      const batch = drawBatches[i2];
      batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count, this._renderer.limits.maxBatchableTextures);
    }
    this._graphicsDataContextHash[context2.uid] = graphicsData;
    return graphicsData;
  }
  _initContext(context2) {
    const gpuContext = new GpuGraphicsContext;
    gpuContext.context = context2;
    this._gpuContextHash[context2.uid] = gpuContext;
    context2.on("destroy", this.onGraphicsContextDestroy, this);
    return this._gpuContextHash[context2.uid];
  }
  onGraphicsContextDestroy(context2) {
    this._cleanGraphicsContextData(context2);
    context2.off("destroy", this.onGraphicsContextDestroy, this);
    this._gpuContextHash[context2.uid] = null;
  }
  _cleanGraphicsContextData(context2) {
    const gpuContext = this._gpuContextHash[context2.uid];
    if (!gpuContext.isBatchable) {
      if (this._graphicsDataContextHash[context2.uid]) {
        BigPool.return(this.getContextRenderData(context2));
        this._graphicsDataContextHash[context2.uid] = null;
      }
    }
    if (gpuContext.batches) {
      gpuContext.batches.forEach((batch) => {
        BigPool.return(batch);
      });
    }
  }
  destroy() {
    for (const i2 in this._gpuContextHash) {
      if (this._gpuContextHash[i2]) {
        this.onGraphicsContextDestroy(this._gpuContextHash[i2].context);
      }
    }
  }
}, GraphicsContextSystem;
var init_GraphicsContextSystem = __esm(() => {
  init_Extensions();
  init_getTextureBatchBindGroup();
  init_DefaultBatcher();
  init_InstructionSet();
  init_deprecation();
  init_PoolGroup();
  init_buildContextBatches();
  _GraphicsContextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "graphicsContext"
  };
  _GraphicsContextSystem.defaultOptions = {
    bezierSmoothness: 0.5
  };
  GraphicsContextSystem = _GraphicsContextSystem;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
var blendModeIds, BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, _State = class _State2 {
  constructor() {
    this.data = 0;
    this.blendMode = "normal";
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  get blend() {
    return !!(this.data & 1 << BLEND);
  }
  set blend(value) {
    if (!!(this.data & 1 << BLEND) !== value) {
      this.data ^= 1 << BLEND;
    }
  }
  get offsets() {
    return !!(this.data & 1 << OFFSET);
  }
  set offsets(value) {
    if (!!(this.data & 1 << OFFSET) !== value) {
      this.data ^= 1 << OFFSET;
    }
  }
  set cullMode(value) {
    if (value === "none") {
      this.culling = false;
      return;
    }
    this.culling = true;
    this.clockwiseFrontFace = value === "front";
  }
  get cullMode() {
    if (!this.culling) {
      return "none";
    }
    return this.clockwiseFrontFace ? "front" : "back";
  }
  get culling() {
    return !!(this.data & 1 << CULLING);
  }
  set culling(value) {
    if (!!(this.data & 1 << CULLING) !== value) {
      this.data ^= 1 << CULLING;
    }
  }
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST);
  }
  set depthTest(value) {
    if (!!(this.data & 1 << DEPTH_TEST) !== value) {
      this.data ^= 1 << DEPTH_TEST;
    }
  }
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK);
  }
  set depthMask(value) {
    if (!!(this.data & 1 << DEPTH_MASK) !== value) {
      this.data ^= 1 << DEPTH_MASK;
    }
  }
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING);
  }
  set clockwiseFrontFace(value) {
    if (!!(this.data & 1 << WINDING) !== value) {
      this.data ^= 1 << WINDING;
    }
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== "none";
    this._blendMode = value;
    this._blendModeId = blendModeIds[value] || 0;
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value;
    this._polygonOffset = value;
  }
  toString() {
    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  static for2d() {
    const state = new _State2;
    state.depthTest = false;
    state.blend = true;
    return state;
  }
}, State;
var init_State = __esm(() => {
  blendModeIds = {
    normal: 0,
    add: 1,
    multiply: 2,
    screen: 3,
    overlay: 4,
    erase: 5,
    "normal-npm": 6,
    "add-npm": 7,
    "screen-npm": 8,
    min: 9,
    max: 10
  };
  _State.default2d = _State.for2d();
  State = _State;
});

// node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
function color32BitToUniform(abgr, out, offset) {
  const alpha = (abgr >> 24 & 255) / 255;
  out[offset++] = (abgr & 255) / 255 * alpha;
  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;
  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;
  out[offset++] = alpha;
}
var init_colorToUniform = () => {};

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
class GraphicsGpuData {
  constructor() {
    this.batches = [];
    this.batched = false;
  }
  destroy() {
    this.batches.forEach((batch) => {
      BigPool.return(batch);
    });
    this.batches.length = 0;
  }
}

class GraphicsPipe {
  constructor(renderer, adaptor) {
    this.state = State.for2d();
    this.renderer = renderer;
    this._adaptor = adaptor;
    this.renderer.runners.contextChange.add(this);
  }
  contextChange() {
    this._adaptor.contextChange(this.renderer);
  }
  validateRenderable(graphics) {
    const context2 = graphics.context;
    const wasBatched = !!graphics._gpuData;
    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context2);
    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
      return true;
    }
    return false;
  }
  addRenderable(graphics, instructionSet) {
    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
    if (graphics.didViewUpdate) {
      this._rebuild(graphics);
    }
    if (gpuContext.isBatchable) {
      this._addToBatcher(graphics, instructionSet);
    } else {
      this.renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(graphics);
    }
  }
  updateRenderable(graphics) {
    const gpuData = this._getGpuDataForRenderable(graphics);
    const batches = gpuData.batches;
    for (let i2 = 0;i2 < batches.length; i2++) {
      const batch = batches[i2];
      batch._batcher.updateElement(batch);
    }
  }
  execute(graphics) {
    if (!graphics.isRenderable)
      return;
    const renderer = this.renderer;
    const context2 = graphics.context;
    const contextSystem = renderer.graphicsContext;
    if (!contextSystem.getGpuContext(context2).batches.length) {
      return;
    }
    const shader = context2.customShader || this._adaptor.shader;
    this.state.blendMode = graphics.groupBlendMode;
    const localUniforms = shader.resources.localUniforms.uniforms;
    localUniforms.uTransformMatrix = graphics.groupTransform;
    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
    color32BitToUniform(graphics.groupColorAlpha, localUniforms.uColor, 0);
    this._adaptor.execute(this, graphics);
  }
  _rebuild(graphics) {
    const gpuData = this._getGpuDataForRenderable(graphics);
    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
    gpuData.destroy();
    if (gpuContext.isBatchable) {
      this._updateBatchesForRenderable(graphics, gpuData);
    }
  }
  _addToBatcher(graphics, instructionSet) {
    const batchPipe = this.renderer.renderPipes.batch;
    const batches = this._getGpuDataForRenderable(graphics).batches;
    for (let i2 = 0;i2 < batches.length; i2++) {
      const batch = batches[i2];
      batchPipe.addToBatch(batch, instructionSet);
    }
  }
  _getGpuDataForRenderable(graphics) {
    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);
  }
  _initGpuDataForRenderable(graphics) {
    const gpuData = new GraphicsGpuData;
    graphics._gpuData[this.renderer.uid] = gpuData;
    return gpuData;
  }
  _updateBatchesForRenderable(graphics, gpuData) {
    const context2 = graphics.context;
    const gpuContext = this.renderer.graphicsContext.getGpuContext(context2);
    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
    gpuData.batches = gpuContext.batches.map((batch) => {
      const batchClone = BigPool.get(BatchableGraphics);
      batch.copyTo(batchClone);
      batchClone.renderable = graphics;
      batchClone.roundPixels = roundPixels;
      return batchClone;
    });
  }
  destroy() {
    this.renderer = null;
    this._adaptor.destroy();
    this._adaptor = null;
    this.state = null;
  }
}
var init_GraphicsPipe = __esm(() => {
  init_Extensions();
  init_State();
  init_PoolGroup();
  init_colorToUniform();
  init_BatchableGraphics();
  GraphicsPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "graphics"
  };
});

// node_modules/pixi.js/lib/scene/graphics/init.mjs
var init_init7 = __esm(() => {
  init_Extensions();
  init_GraphicsContextSystem();
  init_GraphicsPipe();
  extensions.add(GraphicsPipe);
  extensions.add(GraphicsContextSystem);
});

// node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
class BatchableMesh {
  constructor() {
    this.batcherName = "default";
    this.packAsQuad = false;
    this.indexOffset = 0;
    this.attributeOffset = 0;
    this.roundPixels = 0;
    this._batcher = null;
    this._batch = null;
    this._textureMatrixUpdateId = -1;
    this._uvUpdateId = -1;
  }
  get blendMode() {
    return this.renderable.groupBlendMode;
  }
  get topology() {
    return this._topology || this.geometry.topology;
  }
  set topology(value) {
    this._topology = value;
  }
  reset() {
    this.renderable = null;
    this.texture = null;
    this._batcher = null;
    this._batch = null;
    this.geometry = null;
    this._uvUpdateId = -1;
    this._textureMatrixUpdateId = -1;
  }
  setTexture(value) {
    if (this.texture === value)
      return;
    this.texture = value;
    this._textureMatrixUpdateId = -1;
  }
  get uvs() {
    const geometry = this.geometry;
    const uvBuffer = geometry.getBuffer("aUV");
    const uvs = uvBuffer.data;
    let transformedUvs = uvs;
    const textureMatrix = this.texture.textureMatrix;
    if (!textureMatrix.isSimple) {
      transformedUvs = this._transformedUvs;
      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
        if (!transformedUvs || transformedUvs.length < uvs.length) {
          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
        }
        this._textureMatrixUpdateId = textureMatrix._updateID;
        this._uvUpdateId = uvBuffer._updateID;
        textureMatrix.multiplyUvs(uvs, transformedUvs);
      }
    }
    return transformedUvs;
  }
  get positions() {
    return this.geometry.positions;
  }
  get indices() {
    return this.geometry.indices;
  }
  get color() {
    return this.renderable.groupColorAlpha;
  }
  get groupTransform() {
    return this.renderable.groupTransform;
  }
  get attributeSize() {
    return this.geometry.positions.length / 2;
  }
  get indexSize() {
    return this.geometry.indices.length;
  }
}
var init_BatchableMesh = () => {};

// node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
class MeshGpuData {
  destroy() {}
}

class MeshPipe {
  constructor(renderer, adaptor) {
    this.localUniforms = new UniformGroup({
      uTransformMatrix: { value: new Matrix, type: "mat3x3<f32>" },
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    this.localUniformsBindGroup = new BindGroup({
      0: this.localUniforms
    });
    this.renderer = renderer;
    this._adaptor = adaptor;
    this._adaptor.init();
  }
  validateRenderable(mesh) {
    const meshData = this._getMeshData(mesh);
    const wasBatched = meshData.batched;
    const isBatched = mesh.batched;
    meshData.batched = isBatched;
    if (wasBatched !== isBatched) {
      return true;
    } else if (isBatched) {
      const geometry = mesh._geometry;
      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
        meshData.indexSize = geometry.indices.length;
        meshData.vertexSize = geometry.positions.length;
        return true;
      }
      const batchableMesh = this._getBatchableMesh(mesh);
      if (batchableMesh.texture.uid !== mesh._texture.uid) {
        batchableMesh._textureMatrixUpdateId = -1;
      }
      return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, mesh._texture);
    }
    return false;
  }
  addRenderable(mesh, instructionSet) {
    const batcher = this.renderer.renderPipes.batch;
    const meshData = this._getMeshData(mesh);
    if (mesh.didViewUpdate) {
      meshData.indexSize = mesh._geometry.indices?.length;
      meshData.vertexSize = mesh._geometry.positions?.length;
    }
    if (meshData.batched) {
      const gpuBatchableMesh = this._getBatchableMesh(mesh);
      gpuBatchableMesh.setTexture(mesh._texture);
      gpuBatchableMesh.geometry = mesh._geometry;
      batcher.addToBatch(gpuBatchableMesh, instructionSet);
    } else {
      batcher.break(instructionSet);
      instructionSet.add(mesh);
    }
  }
  updateRenderable(mesh) {
    if (mesh.batched) {
      const gpuBatchableMesh = this._getBatchableMesh(mesh);
      gpuBatchableMesh.setTexture(mesh._texture);
      gpuBatchableMesh.geometry = mesh._geometry;
      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
    }
  }
  execute(mesh) {
    if (!mesh.isRenderable)
      return;
    mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
    const localUniforms = this.localUniforms;
    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
    localUniforms.update();
    color32BitToUniform(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);
    this._adaptor.execute(this, mesh);
  }
  _getMeshData(mesh) {
    var _a, _b;
    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData);
    return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);
  }
  _initMeshData(mesh) {
    mesh._gpuData[this.renderer.uid].meshData = {
      batched: mesh.batched,
      indexSize: 0,
      vertexSize: 0
    };
    return mesh._gpuData[this.renderer.uid].meshData;
  }
  _getBatchableMesh(mesh) {
    var _a, _b;
    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData);
    return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);
  }
  _initBatchableMesh(mesh) {
    const gpuMesh = new BatchableMesh;
    gpuMesh.renderable = mesh;
    gpuMesh.setTexture(mesh._texture);
    gpuMesh.transform = mesh.groupTransform;
    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
    mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;
    return gpuMesh;
  }
  destroy() {
    this.localUniforms = null;
    this.localUniformsBindGroup = null;
    this._adaptor.destroy();
    this._adaptor = null;
    this.renderer = null;
  }
}
var init_MeshPipe = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_BindGroup();
  init_UniformGroup();
  init_getAdjustedBlendModeBlend();
  init_colorToUniform();
  init_BatchableMesh();
  MeshPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "mesh"
  };
});

// node_modules/pixi.js/lib/scene/mesh/init.mjs
var init_init8 = __esm(() => {
  init_Extensions();
  init_MeshPipe();
  extensions.add(MeshPipe);
});

// node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs
class GlParticleContainerAdaptor {
  execute(particleContainerPipe, container) {
    const state = particleContainerPipe.state;
    const renderer = particleContainerPipe.renderer;
    const shader = container.shader || particleContainerPipe.defaultShader;
    shader.resources.uTexture = container.texture._source;
    shader.resources.uniforms = particleContainerPipe.localUniforms;
    const gl = renderer.gl;
    const buffer = particleContainerPipe.getBuffers(container);
    renderer.shader.bind(shader);
    renderer.state.set(state);
    renderer.geometry.bind(buffer.geometry, shader.glProgram);
    const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;
    const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
    gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
  }
}
var init_GlParticleContainerAdaptor = () => {};

// node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs
function createIndicesForQuads(size, outBuffer = null) {
  const totalIndices = size * 6;
  if (totalIndices > 65535) {
    outBuffer || (outBuffer = new Uint32Array(totalIndices));
  } else {
    outBuffer || (outBuffer = new Uint16Array(totalIndices));
  }
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i2 = 0, j2 = 0;i2 < totalIndices; i2 += 6, j2 += 4) {
    outBuffer[i2 + 0] = j2 + 0;
    outBuffer[i2 + 1] = j2 + 1;
    outBuffer[i2 + 2] = j2 + 2;
    outBuffer[i2 + 3] = j2 + 0;
    outBuffer[i2 + 4] = j2 + 2;
    outBuffer[i2 + 5] = j2 + 3;
  }
  return outBuffer;
}
var init_createIndicesForQuads = () => {};

// node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs
function generateParticleUpdateFunction(properties) {
  return {
    dynamicUpdate: generateUpdateFunction(properties, true),
    staticUpdate: generateUpdateFunction(properties, false)
  };
}
function generateUpdateFunction(properties, dynamic) {
  const funcFragments = [];
  funcFragments.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
  let offset = 0;
  for (const i2 in properties) {
    const property = properties[i2];
    if (dynamic !== property.dynamic)
      continue;
    funcFragments.push(`offset = index + ${offset}`);
    funcFragments.push(property.code);
    const attributeInfo = getAttributeInfoFromFormat(property.format);
    offset += attributeInfo.stride / 4;
  }
  funcFragments.push(`
            index += stride * 4;
        }
    `);
  funcFragments.unshift(`
        var stride = ${offset};
    `);
  const functionSource = funcFragments.join(`
`);
  return new Function("ps", "f32v", "u32v", functionSource);
}
var init_generateParticleUpdateFunction = __esm(() => {
  init_getAttributeInfoFromFormat();
});

// node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs
class ParticleBuffer {
  constructor(options) {
    this._size = 0;
    this._generateParticleUpdateCache = {};
    const size = this._size = options.size ?? 1000;
    const properties = options.properties;
    let staticVertexSize = 0;
    let dynamicVertexSize = 0;
    for (const i2 in properties) {
      const property = properties[i2];
      const attributeInfo = getAttributeInfoFromFormat(property.format);
      if (property.dynamic) {
        dynamicVertexSize += attributeInfo.stride;
      } else {
        staticVertexSize += attributeInfo.stride;
      }
    }
    this._dynamicStride = dynamicVertexSize / 4;
    this._staticStride = staticVertexSize / 4;
    this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);
    this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);
    this.indexBuffer = createIndicesForQuads(size);
    const geometry = new Geometry;
    let dynamicOffset = 0;
    let staticOffset = 0;
    this._staticBuffer = new Buffer({
      data: new Float32Array(1),
      label: "static-particle-buffer",
      shrinkToFit: false,
      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
    });
    this._dynamicBuffer = new Buffer({
      data: new Float32Array(1),
      label: "dynamic-particle-buffer",
      shrinkToFit: false,
      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
    });
    for (const i2 in properties) {
      const property = properties[i2];
      const attributeInfo = getAttributeInfoFromFormat(property.format);
      if (property.dynamic) {
        geometry.addAttribute(property.attributeName, {
          buffer: this._dynamicBuffer,
          stride: this._dynamicStride * 4,
          offset: dynamicOffset * 4,
          format: property.format
        });
        dynamicOffset += attributeInfo.size;
      } else {
        geometry.addAttribute(property.attributeName, {
          buffer: this._staticBuffer,
          stride: this._staticStride * 4,
          offset: staticOffset * 4,
          format: property.format
        });
        staticOffset += attributeInfo.size;
      }
    }
    geometry.addIndex(this.indexBuffer);
    const uploadFunction = this.getParticleUpdate(properties);
    this._dynamicUpload = uploadFunction.dynamicUpdate;
    this._staticUpload = uploadFunction.staticUpdate;
    this.geometry = geometry;
  }
  getParticleUpdate(properties) {
    const key = getParticleSyncKey(properties);
    if (this._generateParticleUpdateCache[key]) {
      return this._generateParticleUpdateCache[key];
    }
    this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);
    return this._generateParticleUpdateCache[key];
  }
  generateParticleUpdate(properties) {
    return generateParticleUpdateFunction(properties);
  }
  update(particles, uploadStatic) {
    if (particles.length > this._size) {
      uploadStatic = true;
      this._size = Math.max(particles.length, this._size * 1.5 | 0);
      this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);
      this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);
      this.indexBuffer = createIndicesForQuads(this._size);
      this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, true);
    }
    const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
    this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
    this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);
    if (uploadStatic) {
      const staticAttributeBuffer = this.staticAttributeBuffer;
      this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
      this._staticBuffer.setDataWithSize(staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);
    }
  }
  destroy() {
    this._staticBuffer.destroy();
    this._dynamicBuffer.destroy();
    this.geometry.destroy();
  }
}
function getParticleSyncKey(properties) {
  const keyGen = [];
  for (const key in properties) {
    const property = properties[key];
    keyGen.push(key, property.code, property.dynamic ? "d" : "s");
  }
  return keyGen.join("_");
}
var init_ParticleBuffer = __esm(() => {
  init_Buffer();
  init_const4();
  init_Geometry();
  init_getAttributeInfoFromFormat();
  init_ViewableBuffer();
  init_createIndicesForQuads();
  init_generateParticleUpdateFunction();
});

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs
var fragment = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`;
var init_particles_frag = () => {};

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs
var vertex = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`;
var init_particles_vert = () => {};

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs
var wgsl = `
struct ParticleUniforms {
  uTranslationMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uRound:f32,
  uResolution:vec2<f32>,
};

fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
{
  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

   if(uniforms.uRound == 1.0) {
       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);
   }

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;
var init_particles_wgsl = () => {};

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs
var ParticleShader;
var init_ParticleShader = __esm(() => {
  init_Color();
  init_Matrix();
  init_GlProgram();
  init_GpuProgram();
  init_Shader();
  init_Texture();
  init_TextureStyle();
  init_particles_frag();
  init_particles_vert();
  init_particles_wgsl();
  ParticleShader = class ParticleShader extends Shader {
    constructor() {
      const glProgram = GlProgram.from({
        vertex,
        fragment
      });
      const gpuProgram = GpuProgram.from({
        fragment: {
          source: wgsl,
          entryPoint: "mainFragment"
        },
        vertex: {
          source: wgsl,
          entryPoint: "mainVertex"
        }
      });
      super({
        glProgram,
        gpuProgram,
        resources: {
          uTexture: Texture.WHITE.source,
          uSampler: new TextureStyle({}),
          uniforms: {
            uTranslationMatrix: { value: new Matrix, type: "mat3x3<f32>" },
            uColor: { value: new Color(16777215), type: "vec4<f32>" },
            uRound: { value: 1, type: "f32" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          }
        }
      });
    }
  };
});

// node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs
class ParticleContainerPipe {
  constructor(renderer, adaptor) {
    this.state = State.for2d();
    this.localUniforms = new UniformGroup({
      uTranslationMatrix: { value: new Matrix, type: "mat3x3<f32>" },
      uColor: { value: new Float32Array(4), type: "vec4<f32>" },
      uRound: { value: 1, type: "f32" },
      uResolution: { value: [0, 0], type: "vec2<f32>" }
    });
    this.renderer = renderer;
    this.adaptor = adaptor;
    this.defaultShader = new ParticleShader;
    this.state = State.for2d();
  }
  validateRenderable(_renderable) {
    return false;
  }
  addRenderable(renderable, instructionSet) {
    this.renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add(renderable);
  }
  getBuffers(renderable) {
    return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);
  }
  _initBuffer(renderable) {
    renderable._gpuData[this.renderer.uid] = new ParticleBuffer({
      size: renderable.particleChildren.length,
      properties: renderable._properties
    });
    return renderable._gpuData[this.renderer.uid];
  }
  updateRenderable(_renderable) {}
  execute(container) {
    const children = container.particleChildren;
    if (children.length === 0) {
      return;
    }
    const renderer = this.renderer;
    const buffer = this.getBuffers(container);
    container.texture || (container.texture = children[0].texture);
    const state = this.state;
    buffer.update(children, container._childrenDirty);
    container._childrenDirty = false;
    state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);
    const uniforms = this.localUniforms.uniforms;
    const transformationMatrix = uniforms.uTranslationMatrix;
    container.worldTransform.copyTo(transformationMatrix);
    transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
    uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;
    uniforms.uRound = renderer._roundPixels | container._roundPixels;
    color32BitToUniform(container.groupColorAlpha, uniforms.uColor, 0);
    this.adaptor.execute(this, container);
  }
  destroy() {
    this.renderer = null;
    if (this.defaultShader) {
      this.defaultShader.destroy();
      this.defaultShader = null;
    }
  }
}
var init_ParticleContainerPipe = __esm(() => {
  init_Matrix();
  init_UniformGroup();
  init_getAdjustedBlendModeBlend();
  init_State();
  init_colorToUniform();
  init_ParticleBuffer();
  init_ParticleShader();
});

// node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs
var GlParticleContainerPipe;
var init_GlParticleContainerPipe = __esm(() => {
  init_Extensions();
  init_GlParticleContainerAdaptor();
  init_ParticleContainerPipe();
  GlParticleContainerPipe = class GlParticleContainerPipe extends ParticleContainerPipe {
    constructor(renderer) {
      super(renderer, new GlParticleContainerAdaptor);
    }
  };
  GlParticleContainerPipe.extension = {
    type: [
      ExtensionType.WebGLPipes
    ],
    name: "particle"
  };
});

// node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs
class GpuParticleContainerAdaptor {
  execute(particleContainerPipe, container) {
    const renderer = particleContainerPipe.renderer;
    const shader = container.shader || particleContainerPipe.defaultShader;
    shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);
    shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);
    const state = particleContainerPipe.state;
    const buffer = particleContainerPipe.getBuffers(container);
    renderer.encoder.draw({
      geometry: buffer.geometry,
      shader: container.shader || particleContainerPipe.defaultShader,
      state,
      size: container.particleChildren.length * 6
    });
  }
}
var init_GpuParticleContainerAdaptor = () => {};

// node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs
var GpuParticleContainerPipe;
var init_GpuParticleContainerPipe = __esm(() => {
  init_Extensions();
  init_GpuParticleContainerAdaptor();
  init_ParticleContainerPipe();
  GpuParticleContainerPipe = class GpuParticleContainerPipe extends ParticleContainerPipe {
    constructor(renderer) {
      super(renderer, new GpuParticleContainerAdaptor);
    }
  };
  GpuParticleContainerPipe.extension = {
    type: [
      ExtensionType.WebGPUPipes
    ],
    name: "particle"
  };
});

// node_modules/pixi.js/lib/scene/particle-container/init.mjs
var init_init9 = __esm(() => {
  init_Extensions();
  init_GlParticleContainerPipe();
  init_GpuParticleContainerPipe();
  extensions.add(GlParticleContainerPipe);
  extensions.add(GpuParticleContainerPipe);
});

// node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs
function updateTextBounds(batchableSprite, text) {
  const { texture, bounds } = batchableSprite;
  const padding = text._style._getFinalPadding();
  updateQuadBounds(bounds, text._anchor, texture);
  const paddingOffset = text._anchor._x * padding * 2;
  const paddingOffsetY = text._anchor._y * padding * 2;
  bounds.minX -= padding - paddingOffset;
  bounds.minY -= padding - paddingOffsetY;
  bounds.maxX -= padding - paddingOffset;
  bounds.maxY -= padding - paddingOffsetY;
}
var init_updateTextBounds = __esm(() => {
  init_updateQuadBounds();
});

// node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
class BatchableSprite {
  constructor() {
    this.batcherName = "default";
    this.topology = "triangle-list";
    this.attributeSize = 4;
    this.indexSize = 6;
    this.packAsQuad = true;
    this.roundPixels = 0;
    this._attributeStart = 0;
    this._batcher = null;
    this._batch = null;
  }
  get blendMode() {
    return this.renderable.groupBlendMode;
  }
  get color() {
    return this.renderable.groupColorAlpha;
  }
  reset() {
    this.renderable = null;
    this.texture = null;
    this._batcher = null;
    this._batch = null;
    this.bounds = null;
  }
  destroy() {}
}
var init_BatchableSprite = () => {};

// node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs
var BatchableText;
var init_BatchableText = __esm(() => {
  init_BatchableSprite();
  BatchableText = class BatchableText extends BatchableSprite {
    constructor(renderer) {
      super();
      this._renderer = renderer;
      renderer.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      const text = this.renderable;
      if (text._autoResolution) {
        text.onViewUpdate();
      }
    }
    destroy() {
      const { canvasText } = this._renderer;
      const refCount = canvasText.getReferenceCount(this.currentKey);
      if (refCount > 0) {
        canvasText.decreaseReferenceCount(this.currentKey);
      } else if (this.texture) {
        canvasText.returnTexture(this.texture);
      }
      this._renderer.runners.resolutionChange.remove(this);
      this._renderer = null;
    }
  };
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
class CanvasTextPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  validateRenderable(text) {
    const gpuText = this._getGpuText(text);
    const newKey = text.styleKey;
    if (gpuText.currentKey !== newKey)
      return true;
    return text._didTextUpdate;
  }
  addRenderable(text, instructionSet) {
    const batchableText = this._getGpuText(text);
    if (text._didTextUpdate) {
      const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
      if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution) {
        this._updateGpuText(text);
      }
      text._didTextUpdate = false;
    }
    this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);
  }
  updateRenderable(text) {
    const batchableText = this._getGpuText(text);
    batchableText._batcher.updateElement(batchableText);
  }
  _updateGpuText(text) {
    const batchableText = this._getGpuText(text);
    if (batchableText.texture) {
      this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);
    }
    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
    batchableText.texture = this._renderer.canvasText.getManagedTexture(text);
    batchableText.currentKey = text.styleKey;
    updateTextBounds(batchableText, text);
  }
  _getGpuText(text) {
    return text._gpuData[this._renderer.uid] || this.initGpuText(text);
  }
  initGpuText(text) {
    const batchableText = new BatchableText(this._renderer);
    batchableText.currentKey = "--";
    batchableText.renderable = text;
    batchableText.transform = text.groupTransform;
    batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
    batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;
    text._gpuData[this._renderer.uid] = batchableText;
    return batchableText;
  }
  destroy() {
    this._renderer = null;
  }
}
var init_CanvasTextPipe = __esm(() => {
  init_Extensions();
  init_updateTextBounds();
  init_BatchableText();
  CanvasTextPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "text"
  };
});

// node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
class FillPattern {
  constructor(texture, repetition) {
    this.uid = uid("fillPattern");
    this._tick = 0;
    this.transform = new Matrix;
    this.texture = texture;
    this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);
    if (repetition) {
      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
    }
  }
  setTransform(transform) {
    const texture = this.texture;
    this.transform.copyFrom(transform);
    this.transform.invert();
    this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);
    this._tick++;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this._texture === value)
      return;
    this._texture = value;
    this._tick++;
  }
  get styleKey() {
    return `fill-pattern-${this.uid}-${this._tick}`;
  }
  destroy() {
    this.texture.destroy(true);
    this.texture = null;
  }
}
var repetitionMap;
var init_FillPattern = __esm(() => {
  init_Matrix();
  init_uid();
  repetitionMap = {
    repeat: {
      addressModeU: "repeat",
      addressModeV: "repeat"
    },
    "repeat-x": {
      addressModeU: "repeat",
      addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
      addressModeU: "clamp-to-edge",
      addressModeV: "repeat"
    },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
});

// node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS((exports, module) => {
  module.exports = parse;
  var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
  var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
  function parse(path2) {
    var data = [];
    path2.replace(segment, function(_, command, args) {
      var type = command.toLowerCase();
      args = parseValues(args);
      if (type == "m" && args.length > 2) {
        data.push([command].concat(args.splice(0, 2)));
        type = "l";
        command = command == "m" ? "l" : "L";
      }
      while (true) {
        if (args.length == length[type]) {
          args.unshift(command);
          return data.push(args);
        }
        if (args.length < length[type])
          throw new Error("malformed path data");
        data.push([command].concat(args.splice(0, length[type])));
      }
    });
    return data;
  }
  var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
  function parseValues(args) {
    var numbers = args.match(number);
    return numbers ? numbers.map(Number) : [];
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs
function parseSVGPath(svgPath, path2) {
  const commands = import_parse_svg_path.default(svgPath);
  const subpaths = [];
  let currentSubPath = null;
  let lastX = 0;
  let lastY = 0;
  for (let i2 = 0;i2 < commands.length; i2++) {
    const command = commands[i2];
    const type = command[0];
    const data = command;
    switch (type) {
      case "M":
        lastX = data[1];
        lastY = data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[1];
        lastY += data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[1];
        lastY = data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[1];
        lastY += data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[5];
        lastY = data[6];
        path2.bezierCurveTo(data[1], data[2], data[3], data[4], lastX, lastY);
        break;
      case "c":
        path2.bezierCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4], lastX + data[5], lastY + data[6]);
        lastX += data[5];
        lastY += data[6];
        break;
      case "S":
        lastX = data[3];
        lastY = data[4];
        path2.bezierCurveToShort(data[1], data[2], lastX, lastY);
        break;
      case "s":
        path2.bezierCurveToShort(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);
        lastX += data[3];
        lastY += data[4];
        break;
      case "Q":
        lastX = data[3];
        lastY = data[4];
        path2.quadraticCurveTo(data[1], data[2], lastX, lastY);
        break;
      case "q":
        path2.quadraticCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);
        lastX += data[3];
        lastY += data[4];
        break;
      case "T":
        lastX = data[1];
        lastY = data[2];
        path2.quadraticCurveToShort(lastX, lastY);
        break;
      case "t":
        lastX += data[1];
        lastY += data[2];
        path2.quadraticCurveToShort(lastX, lastY);
        break;
      case "A":
        lastX = data[6];
        lastY = data[7];
        path2.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);
        break;
      case "a":
        lastX += data[6];
        lastY += data[7];
        path2.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);
        break;
      case "Z":
      case "z":
        path2.closePath();
        if (subpaths.length > 0) {
          currentSubPath = subpaths.pop();
          if (currentSubPath) {
            lastX = currentSubPath.startX;
            lastY = currentSubPath.startY;
          } else {
            lastX = 0;
            lastY = 0;
          }
        }
        currentSubPath = null;
        break;
      default:
        warn(`Unknown SVG path command: ${type}`);
    }
    if (type !== "Z" && type !== "z") {
      if (currentSubPath === null) {
        currentSubPath = { startX: lastX, startY: lastY };
        subpaths.push(currentSubPath);
      }
    }
  }
  return path2;
}
var import_parse_svg_path;
var init_parseSVGPath = __esm(() => {
  init_warn();
  import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
});

// node_modules/pixi.js/lib/maths/shapes/Circle.mjs
class Circle {
  constructor(x2 = 0, y2 = 0, radius = 0) {
    this.type = "circle";
    this.x = x2;
    this.y = y2;
    this.radius = radius;
  }
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  contains(x2, y2) {
    if (this.radius <= 0)
      return false;
    const r2 = this.radius * this.radius;
    let dx = this.x - x2;
    let dy = this.y - y2;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  strokeContains(x2, y2, width, alignment = 0.5) {
    if (this.radius === 0)
      return false;
    const dx = this.x - x2;
    const dy = this.y - y2;
    const radius = this.radius;
    const outerWidth = (1 - alignment) * width;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance <= radius + outerWidth && distance > radius - (width - outerWidth);
  }
  getBounds(out) {
    out || (out = new Rectangle);
    out.x = this.x - this.radius;
    out.y = this.y - this.radius;
    out.width = this.radius * 2;
    out.height = this.radius * 2;
    return out;
  }
  copyFrom(circle) {
    this.x = circle.x;
    this.y = circle.y;
    this.radius = circle.radius;
    return this;
  }
  copyTo(circle) {
    circle.copyFrom(this);
    return circle;
  }
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
var init_Circle = __esm(() => {
  init_Rectangle();
});

// node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
class Ellipse {
  constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
    this.type = "ellipse";
    this.x = x2;
    this.y = y2;
    this.halfWidth = halfWidth;
    this.halfHeight = halfHeight;
  }
  clone() {
    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  contains(x2, y2) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0) {
      return false;
    }
    let normx = (x2 - this.x) / this.halfWidth;
    let normy = (y2 - this.y) / this.halfHeight;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
    const { halfWidth, halfHeight } = this;
    if (halfWidth <= 0 || halfHeight <= 0) {
      return false;
    }
    const strokeOuterWidth = strokeWidth * (1 - alignment);
    const strokeInnerWidth = strokeWidth - strokeOuterWidth;
    const innerHorizontal = halfWidth - strokeInnerWidth;
    const innerVertical = halfHeight - strokeInnerWidth;
    const outerHorizontal = halfWidth + strokeOuterWidth;
    const outerVertical = halfHeight + strokeOuterWidth;
    const normalizedX = x2 - this.x;
    const normalizedY = y2 - this.y;
    const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);
    const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);
    return innerEllipse > 1 && outerEllipse <= 1;
  }
  getBounds(out) {
    out || (out = new Rectangle);
    out.x = this.x - this.halfWidth;
    out.y = this.y - this.halfHeight;
    out.width = this.halfWidth * 2;
    out.height = this.halfHeight * 2;
    return out;
  }
  copyFrom(ellipse) {
    this.x = ellipse.x;
    this.y = ellipse.y;
    this.halfWidth = ellipse.halfWidth;
    this.halfHeight = ellipse.halfHeight;
    return this;
  }
  copyTo(ellipse) {
    ellipse.copyFrom(this);
    return ellipse;
  }
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
}
var init_Ellipse = __esm(() => {
  init_Rectangle();
});

// node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs
function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
  const a2 = x2 - x1;
  const b2 = y2 - y1;
  const c2 = x22 - x1;
  const d2 = y22 - y1;
  const dot = a2 * c2 + b2 * d2;
  const lenSq = c2 * c2 + d2 * d2;
  let param = -1;
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  let xx;
  let yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x22;
    yy = y22;
  } else {
    xx = x1 + param * c2;
    yy = y1 + param * d2;
  }
  const dx = x2 - xx;
  const dy = y2 - yy;
  return dx * dx + dy * dy;
}
var init_squaredDistanceToLineSegment = () => {};

// node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
class Polygon {
  constructor(...points) {
    this.type = "polygon";
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p2 = [];
      for (let i2 = 0, il = flat.length;i2 < il; i2++) {
        p2.push(flat[i2].x, flat[i2].y);
      }
      flat = p2;
    }
    this.points = flat;
    this.closePath = true;
  }
  isClockwise() {
    let area2 = 0;
    const points = this.points;
    const length = points.length;
    for (let i2 = 0;i2 < length; i2 += 2) {
      const x1 = points[i2];
      const y1 = points[i2 + 1];
      const x2 = points[(i2 + 2) % length];
      const y2 = points[(i2 + 3) % length];
      area2 += (x2 - x1) * (y2 + y1);
    }
    return area2 < 0;
  }
  containsPolygon(polygon) {
    const thisBounds = this.getBounds(tempRect3);
    const otherBounds = polygon.getBounds(tempRect22);
    if (!thisBounds.containsRect(otherBounds)) {
      return false;
    }
    const points = polygon.points;
    for (let i2 = 0;i2 < points.length; i2 += 2) {
      const x2 = points[i2];
      const y2 = points[i2 + 1];
      if (!this.contains(x2, y2)) {
        return false;
      }
    }
    return true;
  }
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closePath = this.closePath;
    return polygon;
  }
  contains(x2, y2) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i2 = 0, j2 = length - 1;i2 < length; j2 = i2++) {
      const xi = this.points[i2 * 2];
      const yi = this.points[i2 * 2 + 1];
      const xj = this.points[j2 * 2];
      const yj = this.points[j2 * 2 + 1];
      const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
    const strokeWidthSquared = strokeWidth * strokeWidth;
    const rightWidthSquared = strokeWidthSquared * (1 - alignment);
    const leftWidthSquared = strokeWidthSquared - rightWidthSquared;
    const { points } = this;
    const iterationLength = points.length - (this.closePath ? 0 : 2);
    for (let i2 = 0;i2 < iterationLength; i2 += 2) {
      const x1 = points[i2];
      const y1 = points[i2 + 1];
      const x22 = points[(i2 + 2) % points.length];
      const y22 = points[(i2 + 3) % points.length];
      const distanceSquared = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
      const sign2 = Math.sign((x22 - x1) * (y2 - y1) - (y22 - y1) * (x2 - x1));
      if (distanceSquared <= (sign2 < 0 ? leftWidthSquared : rightWidthSquared)) {
        return true;
      }
    }
    return false;
  }
  getBounds(out) {
    out || (out = new Rectangle);
    const points = this.points;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i2 = 0, n2 = points.length;i2 < n2; i2 += 2) {
      const x2 = points[i2];
      const y2 = points[i2 + 1];
      minX = x2 < minX ? x2 : minX;
      maxX = x2 > maxX ? x2 : maxX;
      minY = y2 < minY ? y2 : minY;
      maxY = y2 > maxY ? y2 : maxY;
    }
    out.x = minX;
    out.width = maxX - minX;
    out.y = minY;
    out.height = maxY - minY;
    return out;
  }
  copyFrom(polygon) {
    this.points = polygon.points.slice();
    this.closePath = polygon.closePath;
    return this;
  }
  copyTo(polygon) {
    polygon.copyFrom(this);
    return polygon;
  }
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
  get lastX() {
    return this.points[this.points.length - 2];
  }
  get lastY() {
    return this.points[this.points.length - 1];
  }
  get x() {
    deprecation("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead.");
    return this.points[this.points.length - 2];
  }
  get y() {
    deprecation("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead.");
    return this.points[this.points.length - 1];
  }
  get startX() {
    return this.points[0];
  }
  get startY() {
    return this.points[1];
  }
}
var tempRect3, tempRect22;
var init_Polygon = __esm(() => {
  init_deprecation();
  init_squaredDistanceToLineSegment();
  init_Rectangle();
});

// node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
class RoundedRectangle {
  constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
    this.type = "roundedRectangle";
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.radius = radius;
  }
  getBounds(out) {
    out || (out = new Rectangle);
    out.x = this.x;
    out.y = this.y;
    out.width = this.width;
    out.height = this.height;
    return out;
  }
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  copyTo(rectangle) {
    rectangle.copyFrom(this);
    return rectangle;
  }
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 <= this.x + this.width) {
      if (y2 >= this.y && y2 <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
          return true;
        }
        let dx = x2 - (this.x + radius);
        let dy = y2 - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y2 - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  strokeContains(pX, pY, strokeWidth, alignment = 0.5) {
    const { x: x2, y: y2, width, height, radius } = this;
    const strokeWidthOuter = strokeWidth * (1 - alignment);
    const strokeWidthInner = strokeWidth - strokeWidthOuter;
    const innerX = x2 + radius;
    const innerY = y2 + radius;
    const innerWidth = width - radius * 2;
    const innerHeight = height - radius * 2;
    const rightBound = x2 + width;
    const bottomBound = y2 + height;
    if ((pX >= x2 - strokeWidthOuter && pX <= x2 + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {
      return true;
    }
    if ((pY >= y2 - strokeWidthOuter && pY <= y2 + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {
      return true;
    }
    return pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, strokeWidthInner, strokeWidthOuter) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, strokeWidthInner, strokeWidthOuter) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, strokeWidthInner, strokeWidthOuter) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, strokeWidthInner, strokeWidthOuter);
  }
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
var isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {
  const dx = pX - cornerX;
  const dy = pY - cornerY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;
};
var init_RoundedRectangle = __esm(() => {
  init_Rectangle();
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(0.99, Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness));
  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    let da1;
    let da2;
    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        const a23 = Math.atan2(y3 - y2, x3 - x2);
        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da2 >= pi)
          da2 = 2 * pi - da2;
        if (da1 + da2 < mAngleTolerance) {
          points.push(x1234, y1234);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
          if (da2 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else if (d2 > FLT_EPSILON) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
        }
      }
    } else if (d3 > FLT_EPSILON) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}
var RECURSION_LIMIT = 8, FLT_EPSILON = 0.00000011920929, PATH_DISTANCE_EPSILON = 1, curveAngleToleranceEpsilon = 0.01, mAngleTolerance = 0, mCuspLimit = 0;
var init_buildAdaptiveBezier = __esm(() => {
  init_GraphicsContextSystem();
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(0.99, Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness));
  let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
  if (level > RECURSION_LIMIT2) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
  if (d2 > FLT_EPSILON2) {
    if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
      if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
        points.push(x123, y123);
        return;
      }
      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
      if (da >= pi)
        da = 2 * pi - da;
      if (da < mAngleTolerance2) {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}
var RECURSION_LIMIT2 = 8, FLT_EPSILON2 = 0.00000011920929, PATH_DISTANCE_EPSILON2 = 1, curveAngleToleranceEpsilon2 = 0.01, mAngleTolerance2 = 0;
var init_buildAdaptiveQuadratic = __esm(() => {
  init_GraphicsContextSystem();
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
function buildArc(points, x2, y2, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));
  steps = Math.max(steps, 3);
  let f2 = dist / steps;
  let t2 = start;
  f2 *= clockwise ? -1 : 1;
  for (let i2 = 0;i2 < steps + 1; i2++) {
    const cs = Math.cos(t2);
    const sn = Math.sin(t2);
    const nx = x2 + cs * radius;
    const ny = y2 + sn * radius;
    points.push(nx, ny);
    t2 += f2;
  }
}
var init_buildArc = () => {};

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
function buildArcTo(points, x1, y1, x2, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b2 = x2 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a2);
  if (mm < 0.00000001 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b2 * b2;
  const tt = a1 * a2 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k2 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j2 = k2 * tt / cc;
  const cx = k1 * b2 + k2 * b1;
  const cy = k1 * a2 + k2 * a1;
  const px = b1 * (k2 + j1);
  const py = a1 * (k2 + j1);
  const qx = b2 * (k1 + j2);
  const qy = a2 * (k1 + j2);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc(points, cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
}
var init_buildArcTo = __esm(() => {
  init_buildArc();
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x2 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a2,
      y: y1 + x1 * a2
    },
    {
      x: x2 + y2 * a2,
      y: y2 - x2 * a2
    },
    {
      x: x2,
      y: y2
    }
  ];
}
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out);
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 0.0000001) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i2 = 0;i2 < segments; i2++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier(points, lastX, lastY, x1, y1, x2, y2, x3, y3);
    lastX = x3;
    lastY = y3;
    ang1 += ang2;
  }
}
var TAU, out, mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
  x2 *= rx;
  y2 *= ry;
  const xp = cosPhi * x2 - sinPhi * y2;
  const yp = sinPhi * x2 + cosPhi * y2;
  out2.x = xp + centerX;
  out2.y = yp + centerY;
  return out2;
}, vectorAngle = (ux2, uy2, vx2, vy2) => {
  const sign2 = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
  let dot = ux2 * vx2 + uy2 * vy2;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign2 * Math.acos(dot);
}, getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
  const rxSq = Math.pow(rx, 2);
  const rySq = Math.pow(ry, 2);
  const pxpSq = Math.pow(pxp, 2);
  const pypSq = Math.pow(pyp, 2);
  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxSq * pypSq + rySq * pxpSq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  const centerXp = radicant * rx / ry * pyp;
  const centerYp = radicant * -ry / rx * pxp;
  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
  const vx1 = (pxp - centerXp) / rx;
  const vy1 = (pyp - centerYp) / ry;
  const vx2 = (-pxp - centerXp) / rx;
  const vy2 = (-pyp - centerYp) / ry;
  const ang1 = vectorAngle(1, 0, vx1, vy1);
  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  out2.centerX = centerX;
  out2.centerY = centerY;
  out2.ang1 = ang1;
  out2.ang2 = ang2;
};
var init_buildArcToSvg = __esm(() => {
  init_buildAdaptiveBezier();
  TAU = Math.PI * 2;
  out = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
  };
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs
function roundedShapeArc(g2, points, radius) {
  const vecFrom = (p2, pp) => {
    const x2 = pp.x - p2.x;
    const y2 = pp.y - p2.y;
    const len = Math.sqrt(x2 * x2 + y2 * y2);
    const nx = x2 / len;
    const ny = y2 / len;
    return { len, nx, ny };
  };
  const sharpCorner = (i2, p2) => {
    if (i2 === 0) {
      g2.moveTo(p2.x, p2.y);
    } else {
      g2.lineTo(p2.x, p2.y);
    }
  };
  let p1 = points[points.length - 1];
  for (let i2 = 0;i2 < points.length; i2++) {
    const p2 = points[i2 % points.length];
    const pRadius = p2.radius ?? radius;
    if (pRadius <= 0) {
      sharpCorner(i2, p2);
      p1 = p2;
      continue;
    }
    const p3 = points[(i2 + 1) % points.length];
    const v1 = vecFrom(p2, p1);
    const v2 = vecFrom(p2, p3);
    if (v1.len < 0.0001 || v2.len < 0.0001) {
      sharpCorner(i2, p2);
      p1 = p2;
      continue;
    }
    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
    let radDirection = 1;
    let drawDirection = false;
    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else if (angle > 0) {
      radDirection = -1;
      drawDirection = true;
    }
    const halfAngle = angle / 2;
    let cRadius;
    let lenOut = Math.abs(Math.cos(halfAngle) * pRadius / Math.sin(halfAngle));
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = pRadius;
    }
    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
    if (i2 === 0) {
      g2.moveTo(cX + Math.cos(startAngle) * cRadius, cY + Math.sin(startAngle) * cRadius);
    }
    g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
    p1 = p2;
  }
}
function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  const pointLerp = (p1, p2, t2) => ({
    x: p1.x + (p2.x - p1.x) * t2,
    y: p1.y + (p2.y - p1.y) * t2
  });
  const numPoints = points.length;
  for (let i2 = 0;i2 < numPoints; i2++) {
    const thisPoint = points[(i2 + 1) % numPoints];
    const pRadius = thisPoint.radius ?? radius;
    if (pRadius <= 0) {
      if (i2 === 0) {
        g2.moveTo(thisPoint.x, thisPoint.y);
      } else {
        g2.lineTo(thisPoint.x, thisPoint.y);
      }
      continue;
    }
    const lastPoint = points[i2];
    const nextPoint = points[(i2 + 2) % numPoints];
    const lastEdgeLength = distance(lastPoint, thisPoint);
    let start;
    if (lastEdgeLength < 0.0001) {
      start = thisPoint;
    } else {
      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
      start = pointLerp(thisPoint, lastPoint, lastOffsetDistance / lastEdgeLength);
    }
    const nextEdgeLength = distance(nextPoint, thisPoint);
    let end;
    if (nextEdgeLength < 0.0001) {
      end = thisPoint;
    } else {
      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
      end = pointLerp(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);
    }
    if (i2 === 0) {
      g2.moveTo(start.x, start.y);
    } else {
      g2.lineTo(start.x, start.y);
    }
    g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
  }
}
var init_roundShape = () => {};

// node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
class ShapePath {
  constructor(graphicsPath2D) {
    this.shapePrimitives = [];
    this._currentPoly = null;
    this._bounds = new Bounds;
    this._graphicsPath2D = graphicsPath2D;
    this.signed = graphicsPath2D.checkForHoles;
  }
  moveTo(x2, y2) {
    this.startPoly(x2, y2);
    return this;
  }
  lineTo(x2, y2) {
    this._ensurePoly();
    const points = this._currentPoly.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x2 || fromY !== y2) {
      points.push(x2, y2);
    }
    return this;
  }
  arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
    this._ensurePoly(false);
    const points = this._currentPoly.points;
    buildArc(points, x2, y2, radius, startAngle, endAngle, counterclockwise);
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._ensurePoly();
    const points = this._currentPoly.points;
    buildArcTo(points, x1, y1, x2, y2, radius);
    return this;
  }
  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
    const points = this._currentPoly.points;
    buildArcToSvg(points, this._currentPoly.lastX, this._currentPoly.lastY, x2, y2, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);
    return this;
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
    this._ensurePoly();
    const currentPoly = this._currentPoly;
    buildAdaptiveBezier(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness);
    return this;
  }
  quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
    this._ensurePoly();
    const currentPoly = this._currentPoly;
    buildAdaptiveQuadratic(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x2, y2, smoothing);
    return this;
  }
  closePath() {
    this.endPoly(true);
    return this;
  }
  addPath(path2, transform) {
    this.endPoly();
    if (transform && !transform.isIdentity()) {
      path2 = path2.clone(true);
      path2.transform(transform);
    }
    const shapePrimitives = this.shapePrimitives;
    const start = shapePrimitives.length;
    for (let i2 = 0;i2 < path2.instructions.length; i2++) {
      const instruction = path2.instructions[i2];
      this[instruction.action](...instruction.data);
    }
    if (path2.checkForHoles && shapePrimitives.length - start > 1) {
      let mainShape = null;
      for (let i2 = start;i2 < shapePrimitives.length; i2++) {
        const shapePrimitive = shapePrimitives[i2];
        if (shapePrimitive.shape.type === "polygon") {
          const polygon = shapePrimitive.shape;
          const mainPolygon = mainShape?.shape;
          if (mainPolygon && mainPolygon.containsPolygon(polygon)) {
            mainShape.holes || (mainShape.holes = []);
            mainShape.holes.push(shapePrimitive);
            shapePrimitives.copyWithin(i2, i2 + 1);
            shapePrimitives.length--;
            i2--;
          } else {
            mainShape = shapePrimitive;
          }
        }
      }
    }
    return this;
  }
  finish(closePath = false) {
    this.endPoly(closePath);
  }
  rect(x2, y2, w2, h2, transform) {
    this.drawShape(new Rectangle(x2, y2, w2, h2), transform);
    return this;
  }
  circle(x2, y2, radius, transform) {
    this.drawShape(new Circle(x2, y2, radius), transform);
    return this;
  }
  poly(points, close, transform) {
    const polygon = new Polygon(points);
    polygon.closePath = close;
    this.drawShape(polygon, transform);
    return this;
  }
  regularPoly(x2, y2, radius, sides, rotation = 0, transform) {
    sides = Math.max(sides | 0, 3);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const delta = Math.PI * 2 / sides;
    const polygon = [];
    for (let i2 = 0;i2 < sides; i2++) {
      const angle = startAngle - i2 * delta;
      polygon.push(x2 + radius * Math.cos(angle), y2 + radius * Math.sin(angle));
    }
    this.poly(polygon, true, transform);
    return this;
  }
  roundPoly(x2, y2, radius, sides, corner, rotation = 0, smoothness) {
    sides = Math.max(sides | 0, 3);
    if (corner <= 0) {
      return this.regularPoly(x2, y2, radius, sides, rotation);
    }
    const sideLength = radius * Math.sin(Math.PI / sides) - 0.001;
    corner = Math.min(corner, sideLength);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const delta = Math.PI * 2 / sides;
    const internalAngle = (sides - 2) * Math.PI / sides / 2;
    for (let i2 = 0;i2 < sides; i2++) {
      const angle = i2 * delta + startAngle;
      const x0 = x2 + radius * Math.cos(angle);
      const y0 = y2 + radius * Math.sin(angle);
      const a1 = angle + Math.PI + internalAngle;
      const a2 = angle - Math.PI - internalAngle;
      const x1 = x0 + corner * Math.cos(a1);
      const y1 = y0 + corner * Math.sin(a1);
      const x3 = x0 + corner * Math.cos(a2);
      const y3 = y0 + corner * Math.sin(a2);
      if (i2 === 0) {
        this.moveTo(x1, y1);
      } else {
        this.lineTo(x1, y1);
      }
      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
    }
    return this.closePath();
  }
  roundShape(points, radius, useQuadratic = false, smoothness) {
    if (points.length < 3) {
      return this;
    }
    if (useQuadratic) {
      roundedShapeQuadraticCurve(this, points, radius, smoothness);
    } else {
      roundedShapeArc(this, points, radius);
    }
    return this.closePath();
  }
  filletRect(x2, y2, width, height, fillet) {
    if (fillet === 0) {
      return this.rect(x2, y2, width, height);
    }
    const maxFillet = Math.min(width, height) / 2;
    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
    const right = x2 + width;
    const bottom = y2 + height;
    const dir = inset < 0 ? -inset : 0;
    const size = Math.abs(inset);
    return this.moveTo(x2, y2 + size).arcTo(x2 + dir, y2 + dir, x2 + size, y2, size).lineTo(right - size, y2).arcTo(right - dir, y2 + dir, right, y2 + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x2 + width - size, bottom, size).lineTo(x2 + size, bottom).arcTo(x2 + dir, bottom - dir, x2, bottom - size, size).closePath();
  }
  chamferRect(x2, y2, width, height, chamfer, transform) {
    if (chamfer <= 0) {
      return this.rect(x2, y2, width, height);
    }
    const inset = Math.min(chamfer, Math.min(width, height) / 2);
    const right = x2 + width;
    const bottom = y2 + height;
    const points = [
      x2 + inset,
      y2,
      right - inset,
      y2,
      right,
      y2 + inset,
      right,
      bottom - inset,
      right - inset,
      bottom,
      x2 + inset,
      bottom,
      x2,
      bottom - inset,
      x2,
      y2 + inset
    ];
    for (let i2 = points.length - 1;i2 >= 2; i2 -= 2) {
      if (points[i2] === points[i2 - 2] && points[i2 - 1] === points[i2 - 3]) {
        points.splice(i2 - 1, 2);
      }
    }
    return this.poly(points, true, transform);
  }
  ellipse(x2, y2, radiusX, radiusY, transform) {
    this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform);
    return this;
  }
  roundRect(x2, y2, w2, h2, radius, transform) {
    this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radius), transform);
    return this;
  }
  drawShape(shape, matrix) {
    this.endPoly();
    this.shapePrimitives.push({ shape, transform: matrix });
    return this;
  }
  startPoly(x2, y2) {
    let currentPoly = this._currentPoly;
    if (currentPoly) {
      this.endPoly();
    }
    currentPoly = new Polygon;
    currentPoly.points.push(x2, y2);
    this._currentPoly = currentPoly;
    return this;
  }
  endPoly(closePath = false) {
    const shape = this._currentPoly;
    if (shape && shape.points.length > 2) {
      shape.closePath = closePath;
      this.shapePrimitives.push({ shape });
    }
    this._currentPoly = null;
    return this;
  }
  _ensurePoly(start = true) {
    if (this._currentPoly)
      return;
    this._currentPoly = new Polygon;
    if (start) {
      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
      if (lastShape) {
        let lx = lastShape.shape.x;
        let ly = lastShape.shape.y;
        if (lastShape.transform && !lastShape.transform.isIdentity()) {
          const t2 = lastShape.transform;
          const tempX = lx;
          lx = t2.a * lx + t2.c * ly + t2.tx;
          ly = t2.b * tempX + t2.d * ly + t2.ty;
        }
        this._currentPoly.points.push(lx, ly);
      } else {
        this._currentPoly.points.push(0, 0);
      }
    }
  }
  buildPath() {
    const path2 = this._graphicsPath2D;
    this.shapePrimitives.length = 0;
    this._currentPoly = null;
    for (let i2 = 0;i2 < path2.instructions.length; i2++) {
      const instruction = path2.instructions[i2];
      this[instruction.action](...instruction.data);
    }
    this.finish();
  }
  get bounds() {
    const bounds = this._bounds;
    bounds.clear();
    const shapePrimitives = this.shapePrimitives;
    for (let i2 = 0;i2 < shapePrimitives.length; i2++) {
      const shapePrimitive = shapePrimitives[i2];
      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
      if (shapePrimitive.transform) {
        bounds.addRect(boundsRect, shapePrimitive.transform);
      } else {
        bounds.addRect(boundsRect);
      }
    }
    return bounds;
  }
}
var tempRectangle;
var init_ShapePath = __esm(() => {
  init_Circle();
  init_Ellipse();
  init_Polygon();
  init_Rectangle();
  init_RoundedRectangle();
  init_Bounds();
  init_buildAdaptiveBezier();
  init_buildAdaptiveQuadratic();
  init_buildArc();
  init_buildArcTo();
  init_buildArcToSvg();
  init_roundShape();
  tempRectangle = new Rectangle;
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
class GraphicsPath {
  constructor(instructions, signed = false) {
    this.instructions = [];
    this.uid = uid("graphicsPath");
    this._dirty = true;
    this.checkForHoles = signed;
    if (typeof instructions === "string") {
      parseSVGPath(instructions, this);
    } else {
      this.instructions = instructions?.slice() ?? [];
    }
  }
  get shapePath() {
    if (!this._shapePath) {
      this._shapePath = new ShapePath(this);
    }
    if (this._dirty) {
      this._dirty = false;
      this._shapePath.buildPath();
    }
    return this._shapePath;
  }
  addPath(path2, transform) {
    path2 = path2.clone();
    this.instructions.push({ action: "addPath", data: [path2, transform] });
    this._dirty = true;
    return this;
  }
  arc(...args) {
    this.instructions.push({ action: "arc", data: args });
    this._dirty = true;
    return this;
  }
  arcTo(...args) {
    this.instructions.push({ action: "arcTo", data: args });
    this._dirty = true;
    return this;
  }
  arcToSvg(...args) {
    this.instructions.push({ action: "arcToSvg", data: args });
    this._dirty = true;
    return this;
  }
  bezierCurveTo(...args) {
    this.instructions.push({ action: "bezierCurveTo", data: args });
    this._dirty = true;
    return this;
  }
  bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
    const last = this.instructions[this.instructions.length - 1];
    const lastPoint = this.getLastPoint(Point.shared);
    let cp1x = 0;
    let cp1y = 0;
    if (!last || last.action !== "bezierCurveTo") {
      cp1x = lastPoint.x;
      cp1y = lastPoint.y;
    } else {
      cp1x = last.data[2];
      cp1y = last.data[3];
      const currentX = lastPoint.x;
      const currentY = lastPoint.y;
      cp1x = currentX + (currentX - cp1x);
      cp1y = currentY + (currentY - cp1y);
    }
    this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness] });
    this._dirty = true;
    return this;
  }
  closePath() {
    this.instructions.push({ action: "closePath", data: [] });
    this._dirty = true;
    return this;
  }
  ellipse(...args) {
    this.instructions.push({ action: "ellipse", data: args });
    this._dirty = true;
    return this;
  }
  lineTo(...args) {
    this.instructions.push({ action: "lineTo", data: args });
    this._dirty = true;
    return this;
  }
  moveTo(...args) {
    this.instructions.push({ action: "moveTo", data: args });
    return this;
  }
  quadraticCurveTo(...args) {
    this.instructions.push({ action: "quadraticCurveTo", data: args });
    this._dirty = true;
    return this;
  }
  quadraticCurveToShort(x2, y2, smoothness) {
    const last = this.instructions[this.instructions.length - 1];
    const lastPoint = this.getLastPoint(Point.shared);
    let cpx1 = 0;
    let cpy1 = 0;
    if (!last || last.action !== "quadraticCurveTo") {
      cpx1 = lastPoint.x;
      cpy1 = lastPoint.y;
    } else {
      cpx1 = last.data[0];
      cpy1 = last.data[1];
      const currentX = lastPoint.x;
      const currentY = lastPoint.y;
      cpx1 = currentX + (currentX - cpx1);
      cpy1 = currentY + (currentY - cpy1);
    }
    this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness] });
    this._dirty = true;
    return this;
  }
  rect(x2, y2, w2, h2, transform) {
    this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform] });
    this._dirty = true;
    return this;
  }
  circle(x2, y2, radius, transform) {
    this.instructions.push({ action: "circle", data: [x2, y2, radius, transform] });
    this._dirty = true;
    return this;
  }
  roundRect(...args) {
    this.instructions.push({ action: "roundRect", data: args });
    this._dirty = true;
    return this;
  }
  poly(...args) {
    this.instructions.push({ action: "poly", data: args });
    this._dirty = true;
    return this;
  }
  regularPoly(...args) {
    this.instructions.push({ action: "regularPoly", data: args });
    this._dirty = true;
    return this;
  }
  roundPoly(...args) {
    this.instructions.push({ action: "roundPoly", data: args });
    this._dirty = true;
    return this;
  }
  roundShape(...args) {
    this.instructions.push({ action: "roundShape", data: args });
    this._dirty = true;
    return this;
  }
  filletRect(...args) {
    this.instructions.push({ action: "filletRect", data: args });
    this._dirty = true;
    return this;
  }
  chamferRect(...args) {
    this.instructions.push({ action: "chamferRect", data: args });
    this._dirty = true;
    return this;
  }
  star(x2, y2, points, radius, innerRadius, rotation, transform) {
    innerRadius || (innerRadius = radius / 2);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const len = points * 2;
    const delta = Math.PI * 2 / len;
    const polygon = [];
    for (let i2 = 0;i2 < len; i2++) {
      const r2 = i2 % 2 ? innerRadius : radius;
      const angle = i2 * delta + startAngle;
      polygon.push(x2 + r2 * Math.cos(angle), y2 + r2 * Math.sin(angle));
    }
    this.poly(polygon, true, transform);
    return this;
  }
  clone(deep = false) {
    const newGraphicsPath2D = new GraphicsPath;
    newGraphicsPath2D.checkForHoles = this.checkForHoles;
    if (!deep) {
      newGraphicsPath2D.instructions = this.instructions.slice();
    } else {
      for (let i2 = 0;i2 < this.instructions.length; i2++) {
        const instruction = this.instructions[i2];
        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
      }
    }
    return newGraphicsPath2D;
  }
  clear() {
    this.instructions.length = 0;
    this._dirty = true;
    return this;
  }
  transform(matrix) {
    if (matrix.isIdentity())
      return this;
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let x2 = 0;
    let y2 = 0;
    let cpx1 = 0;
    let cpy1 = 0;
    let cpx2 = 0;
    let cpy2 = 0;
    let rx = 0;
    let ry = 0;
    for (let i2 = 0;i2 < this.instructions.length; i2++) {
      const instruction = this.instructions[i2];
      const data = instruction.data;
      switch (instruction.action) {
        case "moveTo":
        case "lineTo":
          x2 = data[0];
          y2 = data[1];
          data[0] = a2 * x2 + c2 * y2 + tx;
          data[1] = b2 * x2 + d2 * y2 + ty;
          break;
        case "bezierCurveTo":
          cpx1 = data[0];
          cpy1 = data[1];
          cpx2 = data[2];
          cpy2 = data[3];
          x2 = data[4];
          y2 = data[5];
          data[0] = a2 * cpx1 + c2 * cpy1 + tx;
          data[1] = b2 * cpx1 + d2 * cpy1 + ty;
          data[2] = a2 * cpx2 + c2 * cpy2 + tx;
          data[3] = b2 * cpx2 + d2 * cpy2 + ty;
          data[4] = a2 * x2 + c2 * y2 + tx;
          data[5] = b2 * x2 + d2 * y2 + ty;
          break;
        case "quadraticCurveTo":
          cpx1 = data[0];
          cpy1 = data[1];
          x2 = data[2];
          y2 = data[3];
          data[0] = a2 * cpx1 + c2 * cpy1 + tx;
          data[1] = b2 * cpx1 + d2 * cpy1 + ty;
          data[2] = a2 * x2 + c2 * y2 + tx;
          data[3] = b2 * x2 + d2 * y2 + ty;
          break;
        case "arcToSvg":
          x2 = data[5];
          y2 = data[6];
          rx = data[0];
          ry = data[1];
          data[0] = a2 * rx + c2 * ry;
          data[1] = b2 * rx + d2 * ry;
          data[5] = a2 * x2 + c2 * y2 + tx;
          data[6] = b2 * x2 + d2 * y2 + ty;
          break;
        case "circle":
          data[4] = adjustTransform(data[3], matrix);
          break;
        case "rect":
          data[4] = adjustTransform(data[4], matrix);
          break;
        case "ellipse":
          data[8] = adjustTransform(data[8], matrix);
          break;
        case "roundRect":
          data[5] = adjustTransform(data[5], matrix);
          break;
        case "addPath":
          data[0].transform(matrix);
          break;
        case "poly":
          data[2] = adjustTransform(data[2], matrix);
          break;
        default:
          warn("unknown transform action", instruction.action);
          break;
      }
    }
    this._dirty = true;
    return this;
  }
  get bounds() {
    return this.shapePath.bounds;
  }
  getLastPoint(out2) {
    let index = this.instructions.length - 1;
    let lastInstruction = this.instructions[index];
    if (!lastInstruction) {
      out2.x = 0;
      out2.y = 0;
      return out2;
    }
    while (lastInstruction.action === "closePath") {
      index--;
      if (index < 0) {
        out2.x = 0;
        out2.y = 0;
        return out2;
      }
      lastInstruction = this.instructions[index];
    }
    switch (lastInstruction.action) {
      case "moveTo":
      case "lineTo":
        out2.x = lastInstruction.data[0];
        out2.y = lastInstruction.data[1];
        break;
      case "quadraticCurveTo":
        out2.x = lastInstruction.data[2];
        out2.y = lastInstruction.data[3];
        break;
      case "bezierCurveTo":
        out2.x = lastInstruction.data[4];
        out2.y = lastInstruction.data[5];
        break;
      case "arc":
      case "arcToSvg":
        out2.x = lastInstruction.data[5];
        out2.y = lastInstruction.data[6];
        break;
      case "addPath":
        lastInstruction.data[0].getLastPoint(out2);
        break;
    }
    return out2;
  }
}
function adjustTransform(currentMatrix, transform) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform);
  }
  return transform.clone();
}
var init_GraphicsPath = __esm(() => {
  init_Point();
  init_uid();
  init_warn();
  init_parseSVGPath();
  init_ShapePath();
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs
function parseSVGFloatAttribute(svg, id, defaultValue) {
  const value = svg.getAttribute(id);
  return value ? Number(value) : defaultValue;
}
var init_parseSVGFloatAttribute = () => {};

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs
function parseSVGDefinitions(svg, session) {
  const definitions = svg.querySelectorAll("defs");
  for (let i2 = 0;i2 < definitions.length; i2++) {
    const definition = definitions[i2];
    for (let j2 = 0;j2 < definition.children.length; j2++) {
      const child = definition.children[j2];
      switch (child.nodeName.toLowerCase()) {
        case "lineargradient":
          session.defs[child.id] = parseLinearGradient(child);
          break;
        case "radialgradient":
          session.defs[child.id] = parseRadialGradient(child);
          break;
        default:
          break;
      }
    }
  }
}
function parseLinearGradient(child) {
  const x0 = parseSVGFloatAttribute(child, "x1", 0);
  const y0 = parseSVGFloatAttribute(child, "y1", 0);
  const x1 = parseSVGFloatAttribute(child, "x2", 1);
  const y1 = parseSVGFloatAttribute(child, "y2", 0);
  const gradientUnit = child.getAttribute("gradientUnits") || "objectBoundingBox";
  const gradient = new FillGradient(x0, y0, x1, y1, gradientUnit === "objectBoundingBox" ? "local" : "global");
  for (let k2 = 0;k2 < child.children.length; k2++) {
    const stop = child.children[k2];
    const offset = parseSVGFloatAttribute(stop, "offset", 0);
    const color = Color.shared.setValue(stop.getAttribute("stop-color")).toNumber();
    gradient.addColorStop(offset, color);
  }
  return gradient;
}
function parseRadialGradient(_child) {
  warn("[SVG Parser] Radial gradients are not yet supported");
  return new FillGradient(0, 0, 1, 0);
}
var init_parseSVGDefinitions = __esm(() => {
  init_Color();
  init_warn();
  init_FillGradient();
  init_parseSVGFloatAttribute();
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs
function extractSvgUrlId(url) {
  const match = url.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
  return match ? match[1] : "";
}
var init_extractSvgUrlId = () => {};

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs
function parseSVGStyle(svg, session) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  const result = {
    strokeStyle,
    fillStyle,
    useFill: false,
    useStroke: false
  };
  for (const key in styleAttributes) {
    const attribute = svg.getAttribute(key);
    if (attribute) {
      parseAttribute(session, result, key, attribute.trim());
    }
  }
  if (style) {
    const styleParts = style.split(";");
    for (let i2 = 0;i2 < styleParts.length; i2++) {
      const stylePart = styleParts[i2].trim();
      const [key, value] = stylePart.split(":");
      if (styleAttributes[key]) {
        parseAttribute(session, result, key, value.trim());
      }
    }
  }
  return {
    strokeStyle: result.useStroke ? strokeStyle : null,
    fillStyle: result.useFill ? fillStyle : null,
    useFill: result.useFill,
    useStroke: result.useStroke
  };
}
function parseAttribute(session, result, id, value) {
  switch (id) {
    case "stroke":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = extractSvgUrlId(value);
          result.strokeStyle.fill = session.defs[id2];
        } else {
          result.strokeStyle.color = Color.shared.setValue(value).toNumber();
        }
        result.useStroke = true;
      }
      break;
    case "stroke-width":
      result.strokeStyle.width = Number(value);
      break;
    case "fill":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = extractSvgUrlId(value);
          result.fillStyle.fill = session.defs[id2];
        } else {
          result.fillStyle.color = Color.shared.setValue(value).toNumber();
        }
        result.useFill = true;
      }
      break;
    case "fill-opacity":
      result.fillStyle.alpha = Number(value);
      break;
    case "stroke-opacity":
      result.strokeStyle.alpha = Number(value);
      break;
    case "opacity":
      result.fillStyle.alpha = Number(value);
      result.strokeStyle.alpha = Number(value);
      break;
  }
}
var styleAttributes;
var init_parseSVGStyle = __esm(() => {
  init_Color();
  init_extractSvgUrlId();
  styleAttributes = {
    fill: { type: "paint", default: 0 },
    "fill-opacity": { type: "number", default: 1 },
    stroke: { type: "paint", default: 0 },
    "stroke-width": { type: "number", default: 1 },
    "stroke-opacity": { type: "number", default: 1 },
    "stroke-linecap": { type: "string", default: "butt" },
    "stroke-linejoin": { type: "string", default: "miter" },
    "stroke-miterlimit": { type: "number", default: 10 },
    "stroke-dasharray": { type: "string", default: "none" },
    "stroke-dashoffset": { type: "number", default: 0 },
    opacity: { type: "number", default: 1 }
  };
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/fillOperations.mjs
function checkForNestedPattern(subpathsWithArea) {
  if (subpathsWithArea.length <= 2) {
    return true;
  }
  const areas = subpathsWithArea.map((s2) => s2.area).sort((a2, b2) => b2 - a2);
  const [largestArea, secondArea] = areas;
  const smallestArea = areas[areas.length - 1];
  const largestToSecondRatio = largestArea / secondArea;
  const secondToSmallestRatio = secondArea / smallestArea;
  if (largestToSecondRatio > 3 && secondToSmallestRatio < 2) {
    return false;
  }
  return true;
}
var init_fillOperations = () => {};

// node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/pathOperations.mjs
function extractSubpaths(pathData) {
  const parts = pathData.split(/(?=[Mm])/);
  const subpaths = parts.filter((part) => part.trim().length > 0);
  return subpaths;
}
function calculatePathArea(pathData) {
  const coords = pathData.match(/[-+]?[0-9]*\.?[0-9]+/g);
  if (!coords || coords.length < 4)
    return 0;
  const numbers = coords.map(Number);
  const xs = [];
  const ys = [];
  for (let i2 = 0;i2 < numbers.length; i2 += 2) {
    if (i2 + 1 < numbers.length) {
      xs.push(numbers[i2]);
      ys.push(numbers[i2 + 1]);
    }
  }
  if (xs.length === 0 || ys.length === 0)
    return 0;
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  const area2 = (maxX - minX) * (maxY - minY);
  return area2;
}
function appendSVGPath(pathData, graphicsPath) {
  const tempPath = new GraphicsPath(pathData, false);
  for (const instruction of tempPath.instructions) {
    graphicsPath.instructions.push(instruction);
  }
}
var init_pathOperations = __esm(() => {
  init_GraphicsPath();
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    defs: {},
    path: new GraphicsPath
  };
  parseSVGDefinitions(svg, session);
  const children = svg.children;
  const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);
  for (let i2 = 0;i2 < children.length; i2++) {
    const child = children[i2];
    if (child.nodeName.toLowerCase() === "defs")
      continue;
    renderChildren(child, session, fillStyle, strokeStyle);
  }
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  const noStyle = !fillStyle && !strokeStyle;
  if (noStyle) {
    fillStyle = { color: 0 };
  }
  let x2;
  let y2;
  let x1;
  let y1;
  let x22;
  let y22;
  let cx;
  let cy;
  let r2;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d2;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path": {
      d2 = svg.getAttribute("d");
      const fillRule = svg.getAttribute("fill-rule");
      const subpaths = extractSubpaths(d2);
      const hasExplicitEvenodd = fillRule === "evenodd";
      const hasMultipleSubpaths = subpaths.length > 1;
      const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;
      if (shouldProcessHoles) {
        const subpathsWithArea = subpaths.map((subpath) => ({
          path: subpath,
          area: calculatePathArea(subpath)
        }));
        subpathsWithArea.sort((a2, b2) => b2.area - a2.area);
        const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);
        if (useMultipleHolesApproach) {
          for (let i2 = 0;i2 < subpathsWithArea.length; i2++) {
            const subpath = subpathsWithArea[i2];
            const isMainShape = i2 === 0;
            session.context.beginPath();
            const newPath = new GraphicsPath(undefined, true);
            appendSVGPath(subpath.path, newPath);
            session.context.path(newPath);
            if (isMainShape) {
              if (fillStyle)
                session.context.fill(fillStyle);
              if (strokeStyle)
                session.context.stroke(strokeStyle);
            } else {
              session.context.cut();
            }
          }
        } else {
          for (let i2 = 0;i2 < subpathsWithArea.length; i2++) {
            const subpath = subpathsWithArea[i2];
            const isHole = i2 % 2 === 1;
            session.context.beginPath();
            const newPath = new GraphicsPath(undefined, true);
            appendSVGPath(subpath.path, newPath);
            session.context.path(newPath);
            if (isHole) {
              session.context.cut();
            } else {
              if (fillStyle)
                session.context.fill(fillStyle);
              if (strokeStyle)
                session.context.stroke(strokeStyle);
            }
          }
        }
      } else {
        const useEvenoddForGraphicsPath = fillRule ? fillRule === "evenodd" : true;
        graphicsPath = new GraphicsPath(d2, useEvenoddForGraphicsPath);
        session.context.path(graphicsPath);
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
      }
      break;
    }
    case "circle":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      r2 = parseSVGFloatAttribute(svg, "r", 0);
      session.context.ellipse(cx, cy, r2, r2);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "rect":
      x2 = parseSVGFloatAttribute(svg, "x", 0);
      y2 = parseSVGFloatAttribute(svg, "y", 0);
      width = parseSVGFloatAttribute(svg, "width", 0);
      height = parseSVGFloatAttribute(svg, "height", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x2, y2, width, height, rx || ry);
      } else {
        session.context.rect(x2, y2, width, height);
      }
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "ellipse":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "line":
      x1 = parseSVGFloatAttribute(svg, "x1", 0);
      y1 = parseSVGFloatAttribute(svg, "y1", 0);
      x22 = parseSVGFloatAttribute(svg, "x2", 0);
      y22 = parseSVGFloatAttribute(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x22, y22);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "g":
    case "svg":
      break;
    default: {
      warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  if (noStyle) {
    fillStyle = null;
  }
  for (let i2 = 0;i2 < children.length; i2++) {
    renderChildren(children[i2], session, fillStyle, strokeStyle);
  }
}
var init_SVGParser = __esm(() => {
  init_warn();
  init_GraphicsPath();
  init_parseSVGDefinitions();
  init_parseSVGFloatAttribute();
  init_parseSVGStyle();
  init_fillOperations();
  init_pathOperations();
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
function isColorLike(value) {
  return Color.isColorLike(value);
}
function isFillPattern(value) {
  return value instanceof FillPattern;
}
function isFillGradient(value) {
  return value instanceof FillGradient;
}
function isTexture(value) {
  return value instanceof Texture;
}
function handleColorLike(fill, value, defaultStyle) {
  const temp = Color.shared.setValue(value ?? 0);
  fill.color = temp.toNumber();
  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
  fill.texture = Texture.WHITE;
  return { ...defaultStyle, ...fill };
}
function handleTexture(fill, value, defaultStyle) {
  fill.texture = value;
  return { ...defaultStyle, ...fill };
}
function handleFillPattern(fill, value, defaultStyle) {
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  return { ...defaultStyle, ...fill };
}
function handleFillGradient(fill, value, defaultStyle) {
  value.buildGradient();
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  fill.textureSpace = value.textureSpace;
  return { ...defaultStyle, ...fill };
}
function handleFillObject(value, defaultStyle) {
  const style = { ...defaultStyle, ...value };
  const color = Color.shared.setValue(style.color);
  style.alpha *= color.alpha;
  style.color = color.toNumber();
  return style;
}
function toFillStyle(value, defaultStyle) {
  if (value === undefined || value === null) {
    return null;
  }
  const fill = {};
  const objectStyle = value;
  if (isColorLike(value)) {
    return handleColorLike(fill, value, defaultStyle);
  } else if (isTexture(value)) {
    return handleTexture(fill, value, defaultStyle);
  } else if (isFillPattern(value)) {
    return handleFillPattern(fill, value, defaultStyle);
  } else if (isFillGradient(value)) {
    return handleFillGradient(fill, value, defaultStyle);
  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
  }
  return handleFillObject(objectStyle, defaultStyle);
}
function toStrokeStyle(value, defaultStyle) {
  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;
  const fill = toFillStyle(value, rest);
  if (!fill) {
    return null;
  }
  return {
    width,
    alignment,
    miterLimit,
    cap,
    join,
    pixelLine,
    ...fill
  };
}
var init_convertFillInputToFillStyle = __esm(() => {
  init_Color();
  init_Texture();
  init_FillGradient();
  init_FillPattern();
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
var tmpPoint, tempMatrix4, _GraphicsContext, GraphicsContext;
var init_GraphicsContext = __esm(() => {
  init_eventemitter3();
  init_Color();
  init_Matrix();
  init_Point();
  init_Texture();
  init_uid();
  init_deprecation();
  init_Bounds();
  init_GraphicsPath();
  init_SVGParser();
  init_convertFillInputToFillStyle();
  tmpPoint = new Point;
  tempMatrix4 = new Matrix;
  _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
    constructor() {
      super(...arguments);
      this.uid = uid("graphicsContext");
      this.dirty = true;
      this.batchMode = "auto";
      this.instructions = [];
      this._activePath = new GraphicsPath;
      this._transform = new Matrix;
      this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
      this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
      this._stateStack = [];
      this._tick = 0;
      this._bounds = new Bounds;
      this._boundsDirty = true;
    }
    clone() {
      const clone = new _GraphicsContext2;
      clone.batchMode = this.batchMode;
      clone.instructions = this.instructions.slice();
      clone._activePath = this._activePath.clone();
      clone._transform = this._transform.clone();
      clone._fillStyle = { ...this._fillStyle };
      clone._strokeStyle = { ...this._strokeStyle };
      clone._stateStack = this._stateStack.slice();
      clone._bounds = this._bounds.clone();
      clone._boundsDirty = true;
      return clone;
    }
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(value) {
      this._fillStyle = toFillStyle(value, _GraphicsContext2.defaultFillStyle);
    }
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(value) {
      this._strokeStyle = toStrokeStyle(value, _GraphicsContext2.defaultStrokeStyle);
    }
    setFillStyle(style) {
      this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
      return this;
    }
    setStrokeStyle(style) {
      this._strokeStyle = toFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
      return this;
    }
    texture(texture, tint, dx, dy, dw, dh) {
      this.instructions.push({
        action: "texture",
        data: {
          image: texture,
          dx: dx || 0,
          dy: dy || 0,
          dw: dw || texture.frame.width,
          dh: dh || texture.frame.height,
          transform: this._transform.clone(),
          alpha: this._fillStyle.alpha,
          style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
        }
      });
      this.onUpdate();
      return this;
    }
    beginPath() {
      this._activePath = new GraphicsPath;
      return this;
    }
    fill(style, alpha) {
      let path2;
      const lastInstruction = this.instructions[this.instructions.length - 1];
      if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
        path2 = lastInstruction.data.path;
      } else {
        path2 = this._activePath.clone();
      }
      if (!path2)
        return this;
      if (style != null) {
        if (alpha !== undefined && typeof style === "number") {
          deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
          style = { color: style, alpha };
        }
        this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
      }
      this.instructions.push({
        action: "fill",
        data: { style: this.fillStyle, path: path2 }
      });
      this.onUpdate();
      this._initNextPathLocation();
      this._tick = 0;
      return this;
    }
    _initNextPathLocation() {
      const { x: x2, y: y2 } = this._activePath.getLastPoint(Point.shared);
      this._activePath.clear();
      this._activePath.moveTo(x2, y2);
    }
    stroke(style) {
      let path2;
      const lastInstruction = this.instructions[this.instructions.length - 1];
      if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
        path2 = lastInstruction.data.path;
      } else {
        path2 = this._activePath.clone();
      }
      if (!path2)
        return this;
      if (style != null) {
        this._strokeStyle = toStrokeStyle(style, _GraphicsContext2.defaultStrokeStyle);
      }
      this.instructions.push({
        action: "stroke",
        data: { style: this.strokeStyle, path: path2 }
      });
      this.onUpdate();
      this._initNextPathLocation();
      this._tick = 0;
      return this;
    }
    cut() {
      for (let i2 = 0;i2 < 2; i2++) {
        const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
        const holePath = this._activePath.clone();
        if (lastInstruction) {
          if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
            if (lastInstruction.data.hole) {
              lastInstruction.data.hole.addPath(holePath);
            } else {
              lastInstruction.data.hole = holePath;
              break;
            }
          }
        }
      }
      this._initNextPathLocation();
      return this;
    }
    arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.arc(t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty, radius, startAngle, endAngle, counterclockwise);
      return this;
    }
    arcTo(x1, y1, x2, y2, radius) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.arcTo(t2.a * x1 + t2.c * y1 + t2.tx, t2.b * x1 + t2.d * y1 + t2.ty, t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty, radius);
      return this;
    }
    arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty);
      return this;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.bezierCurveTo(t2.a * cp1x + t2.c * cp1y + t2.tx, t2.b * cp1x + t2.d * cp1y + t2.ty, t2.a * cp2x + t2.c * cp2y + t2.tx, t2.b * cp2x + t2.d * cp2y + t2.ty, t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty, smoothness);
      return this;
    }
    closePath() {
      this._tick++;
      this._activePath?.closePath();
      return this;
    }
    ellipse(x2, y2, radiusX, radiusY) {
      this._tick++;
      this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
      return this;
    }
    circle(x2, y2, radius) {
      this._tick++;
      this._activePath.circle(x2, y2, radius, this._transform.clone());
      return this;
    }
    path(path2) {
      this._tick++;
      this._activePath.addPath(path2, this._transform.clone());
      return this;
    }
    lineTo(x2, y2) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.lineTo(t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty);
      return this;
    }
    moveTo(x2, y2) {
      this._tick++;
      const t2 = this._transform;
      const instructions = this._activePath.instructions;
      const transformedX = t2.a * x2 + t2.c * y2 + t2.tx;
      const transformedY = t2.b * x2 + t2.d * y2 + t2.ty;
      if (instructions.length === 1 && instructions[0].action === "moveTo") {
        instructions[0].data[0] = transformedX;
        instructions[0].data[1] = transformedY;
        return this;
      }
      this._activePath.moveTo(transformedX, transformedY);
      return this;
    }
    quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.quadraticCurveTo(t2.a * cpx + t2.c * cpy + t2.tx, t2.b * cpx + t2.d * cpy + t2.ty, t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty, smoothness);
      return this;
    }
    rect(x2, y2, w2, h2) {
      this._tick++;
      this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
      return this;
    }
    roundRect(x2, y2, w2, h2, radius) {
      this._tick++;
      this._activePath.roundRect(x2, y2, w2, h2, radius, this._transform.clone());
      return this;
    }
    poly(points, close) {
      this._tick++;
      this._activePath.poly(points, close, this._transform.clone());
      return this;
    }
    regularPoly(x2, y2, radius, sides, rotation = 0, transform) {
      this._tick++;
      this._activePath.regularPoly(x2, y2, radius, sides, rotation, transform);
      return this;
    }
    roundPoly(x2, y2, radius, sides, corner, rotation) {
      this._tick++;
      this._activePath.roundPoly(x2, y2, radius, sides, corner, rotation);
      return this;
    }
    roundShape(points, radius, useQuadratic, smoothness) {
      this._tick++;
      this._activePath.roundShape(points, radius, useQuadratic, smoothness);
      return this;
    }
    filletRect(x2, y2, width, height, fillet) {
      this._tick++;
      this._activePath.filletRect(x2, y2, width, height, fillet);
      return this;
    }
    chamferRect(x2, y2, width, height, chamfer, transform) {
      this._tick++;
      this._activePath.chamferRect(x2, y2, width, height, chamfer, transform);
      return this;
    }
    star(x2, y2, points, radius, innerRadius = 0, rotation = 0) {
      this._tick++;
      this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
      return this;
    }
    svg(svg) {
      this._tick++;
      SVGParser(svg, this);
      return this;
    }
    restore() {
      const state = this._stateStack.pop();
      if (state) {
        this._transform = state.transform;
        this._fillStyle = state.fillStyle;
        this._strokeStyle = state.strokeStyle;
      }
      return this;
    }
    save() {
      this._stateStack.push({
        transform: this._transform.clone(),
        fillStyle: { ...this._fillStyle },
        strokeStyle: { ...this._strokeStyle }
      });
      return this;
    }
    getTransform() {
      return this._transform;
    }
    resetTransform() {
      this._transform.identity();
      return this;
    }
    rotate(angle) {
      this._transform.rotate(angle);
      return this;
    }
    scale(x2, y2 = x2) {
      this._transform.scale(x2, y2);
      return this;
    }
    setTransform(a2, b2, c2, d2, dx, dy) {
      if (a2 instanceof Matrix) {
        this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
        return this;
      }
      this._transform.set(a2, b2, c2, d2, dx, dy);
      return this;
    }
    transform(a2, b2, c2, d2, dx, dy) {
      if (a2 instanceof Matrix) {
        this._transform.append(a2);
        return this;
      }
      tempMatrix4.set(a2, b2, c2, d2, dx, dy);
      this._transform.append(tempMatrix4);
      return this;
    }
    translate(x2, y2 = x2) {
      this._transform.translate(x2, y2);
      return this;
    }
    clear() {
      this._activePath.clear();
      this.instructions.length = 0;
      this.resetTransform();
      this.onUpdate();
      return this;
    }
    onUpdate() {
      this._boundsDirty = true;
      if (this.dirty)
        return;
      this.emit("update", this, 16);
      this.dirty = true;
    }
    get bounds() {
      if (!this._boundsDirty)
        return this._bounds;
      this._boundsDirty = false;
      const bounds = this._bounds;
      bounds.clear();
      for (let i2 = 0;i2 < this.instructions.length; i2++) {
        const instruction = this.instructions[i2];
        const action = instruction.action;
        if (action === "fill") {
          const data = instruction.data;
          bounds.addBounds(data.path.bounds);
        } else if (action === "texture") {
          const data = instruction.data;
          bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
        }
        if (action === "stroke") {
          const data = instruction.data;
          const alignment = data.style.alignment;
          const outerPadding = data.style.width * (1 - alignment);
          const _bounds = data.path.bounds;
          bounds.addFrame(_bounds.minX - outerPadding, _bounds.minY - outerPadding, _bounds.maxX + outerPadding, _bounds.maxY + outerPadding);
        }
      }
      return bounds;
    }
    containsPoint(point) {
      if (!this.bounds.containsPoint(point.x, point.y))
        return false;
      const instructions = this.instructions;
      let hasHit = false;
      for (let k2 = 0;k2 < instructions.length; k2++) {
        const instruction = instructions[k2];
        const data = instruction.data;
        const path2 = data.path;
        if (!instruction.action || !path2)
          continue;
        const style = data.style;
        const shapes = path2.shapePath.shapePrimitives;
        for (let i2 = 0;i2 < shapes.length; i2++) {
          const shape = shapes[i2].shape;
          if (!style || !shape)
            continue;
          const transform = shapes[i2].transform;
          const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;
          if (instruction.action === "fill") {
            hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
          } else {
            const strokeStyle = style;
            hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);
          }
          const holes = data.hole;
          if (holes) {
            const holeShapes = holes.shapePath?.shapePrimitives;
            if (holeShapes) {
              for (let j2 = 0;j2 < holeShapes.length; j2++) {
                if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                  hasHit = false;
                }
              }
            }
          }
          if (hasHit) {
            return true;
          }
        }
      }
      return hasHit;
    }
    destroy(options = false) {
      this._stateStack.length = 0;
      this._transform = null;
      this.emit("destroy", this);
      this.removeAllListeners();
      const destroyTexture = typeof options === "boolean" ? options : options?.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
        if (this._fillStyle.texture) {
          this._fillStyle.fill && "uid" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(destroyTextureSource);
        }
        if (this._strokeStyle.texture) {
          this._strokeStyle.fill && "uid" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(destroyTextureSource);
        }
      }
      this._fillStyle = null;
      this._strokeStyle = null;
      this.instructions = null;
      this._activePath = null;
      this._bounds = null;
      this._stateStack = null;
      this.customShader = null;
      this._transform = null;
    }
  };
  _GraphicsContext.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: Texture.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local"
  };
  _GraphicsContext.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: 0.5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: Texture.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
    pixelLine: false
  };
  GraphicsContext = _GraphicsContext;
});

// node_modules/pixi.js/lib/scene/text/TextStyle.mjs
function convertV7Tov8Style(style) {
  const oldStyle = style;
  if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
    const defaults = TextStyle.defaultDropShadow;
    style.dropShadow = {
      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,
      angle: oldStyle.dropShadowAngle ?? defaults.angle,
      blur: oldStyle.dropShadowBlur ?? defaults.blur,
      color: oldStyle.dropShadowColor ?? defaults.color,
      distance: oldStyle.dropShadowDistance ?? defaults.distance
    };
  }
  if (oldStyle.strokeThickness !== undefined) {
    deprecation(v8_0_0, "strokeThickness is now a part of stroke");
    const color = oldStyle.stroke;
    let obj = {};
    if (Color.isColorLike(color)) {
      obj.color = color;
    } else if (color instanceof FillGradient || color instanceof FillPattern) {
      obj.fill = color;
    } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
      obj = color;
    } else {
      throw new Error("Invalid stroke value.");
    }
    style.stroke = {
      ...obj,
      width: oldStyle.strokeThickness
    };
  }
  if (Array.isArray(oldStyle.fillGradientStops)) {
    deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0) {
      throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
    }
    if (oldStyle.fill.length !== oldStyle.fillGradientStops.length) {
      warn("The number of fill colors must match the number of fill gradient stops.");
    }
    const gradientFill = new FillGradient({
      start: { x: 0, y: 0 },
      end: { x: 0, y: 1 },
      textureSpace: "local"
    });
    const fillGradientStops = oldStyle.fillGradientStops.slice();
    const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());
    fillGradientStops.forEach((stop, index) => {
      gradientFill.addColorStop(stop, fills[index]);
    });
    style.fill = {
      fill: gradientFill
    };
  }
}
var _TextStyle, TextStyle;
var init_TextStyle = __esm(() => {
  init_eventemitter3();
  init_Color();
  init_uid();
  init_deprecation();
  init_warn();
  init_FillGradient();
  init_FillPattern();
  init_GraphicsContext();
  init_convertFillInputToFillStyle();
  _TextStyle = class _TextStyle2 extends eventemitter3_default {
    constructor(style = {}) {
      super();
      this.uid = uid("textStyle");
      this._tick = 0;
      convertV7Tov8Style(style);
      const fullStyle = { ..._TextStyle2.defaultTextStyle, ...style };
      for (const key in fullStyle) {
        const thisKey = key;
        this[thisKey] = fullStyle[key];
      }
      this.update();
      this._tick = 0;
    }
    get align() {
      return this._align;
    }
    set align(value) {
      this._align = value;
      this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(value) {
      this._breakWords = value;
      this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(value) {
      if (value !== null && typeof value === "object") {
        this._dropShadow = this._createProxy({ ..._TextStyle2.defaultDropShadow, ...value });
      } else {
        this._dropShadow = value ? this._createProxy({ ..._TextStyle2.defaultDropShadow }) : null;
      }
      this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(value) {
      this._fontFamily = value;
      this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(value) {
      if (typeof value === "string") {
        this._fontSize = parseInt(value, 10);
      } else {
        this._fontSize = value;
      }
      this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(value) {
      this._fontStyle = value.toLowerCase();
      this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(value) {
      this._fontVariant = value;
      this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(value) {
      this._fontWeight = value;
      this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(value) {
      this._leading = value;
      this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(value) {
      this._letterSpacing = value;
      this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(value) {
      this._lineHeight = value;
      this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(value) {
      this._padding = value;
      this.update();
    }
    get filters() {
      return this._filters;
    }
    set filters(value) {
      this._filters = Object.freeze(value);
      this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(value) {
      this._trim = value;
      this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(value) {
      this._textBaseline = value;
      this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(value) {
      this._whiteSpace = value;
      this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(value) {
      this._wordWrap = value;
      this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(value) {
      this._wordWrapWidth = value;
      this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(value) {
      if (value === this._originalFill)
        return;
      this._originalFill = value;
      if (this._isFillStyle(value)) {
        this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () => {
          this._fill = toFillStyle({ ...this._originalFill }, GraphicsContext.defaultFillStyle);
        });
      }
      this._fill = toFillStyle(value === 0 ? "black" : value, GraphicsContext.defaultFillStyle);
      this.update();
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(value) {
      if (value === this._originalStroke)
        return;
      this._originalStroke = value;
      if (this._isFillStyle(value)) {
        this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () => {
          this._stroke = toStrokeStyle({ ...this._originalStroke }, GraphicsContext.defaultStrokeStyle);
        });
      }
      this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);
      this.update();
    }
    update() {
      this._tick++;
      this.emit("update", this);
    }
    reset() {
      const defaultStyle = _TextStyle2.defaultTextStyle;
      for (const key in defaultStyle) {
        this[key] = defaultStyle[key];
      }
    }
    get styleKey() {
      return `${this.uid}-${this._tick}`;
    }
    clone() {
      return new _TextStyle2({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        leading: this.leading,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        textBaseline: this.textBaseline,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth,
        filters: this._filters ? [...this._filters] : undefined
      });
    }
    _getFinalPadding() {
      let filterPadding = 0;
      if (this._filters) {
        for (let i2 = 0;i2 < this._filters.length; i2++) {
          filterPadding += this._filters[i2].padding;
        }
      }
      return Math.max(this._padding, filterPadding);
    }
    destroy(options = false) {
      this.removeAllListeners();
      const destroyTexture = typeof options === "boolean" ? options : options?.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
        if (this._fill?.texture) {
          this._fill.texture.destroy(destroyTextureSource);
        }
        if (this._originalFill?.texture) {
          this._originalFill.texture.destroy(destroyTextureSource);
        }
        if (this._stroke?.texture) {
          this._stroke.texture.destroy(destroyTextureSource);
        }
        if (this._originalStroke?.texture) {
          this._originalStroke.texture.destroy(destroyTextureSource);
        }
      }
      this._fill = null;
      this._stroke = null;
      this.dropShadow = null;
      this._originalStroke = null;
      this._originalFill = null;
    }
    _createProxy(value, cb) {
      return new Proxy(value, {
        set: (target, property, newValue) => {
          target[property] = newValue;
          cb?.(property, newValue);
          this.update();
          return true;
        }
      });
    }
    _isFillStyle(value) {
      return (value ?? null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);
    }
  };
  _TextStyle.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
  };
  _TextStyle.defaultTextStyle = {
    align: "left",
    breakWords: false,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
  };
  TextStyle = _TextStyle;
});

// node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs
function getPo2TextureFromSource(image, width, height, resolution) {
  const bounds = tempBounds2;
  bounds.minX = 0;
  bounds.minY = 0;
  bounds.maxX = image.width / resolution | 0;
  bounds.maxY = image.height / resolution | 0;
  const texture = TexturePool.getOptimalTexture(bounds.width, bounds.height, resolution, false);
  texture.source.uploadMethodId = "image";
  texture.source.resource = image;
  texture.source.alphaMode = "premultiply-alpha-on-upload";
  texture.frame.width = width / resolution;
  texture.frame.height = height / resolution;
  texture.source.emit("update", texture.source);
  texture.updateUvs();
  return texture;
}
var tempBounds2;
var init_getPo2TextureFromSource = __esm(() => {
  init_TexturePool();
  init_Bounds();
  tempBounds2 = new Bounds;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
class CanvasPoolClass {
  constructor(canvasOptions) {
    this._canvasPool = /* @__PURE__ */ Object.create(null);
    this.canvasOptions = canvasOptions || {};
    this.enableFullScreen = false;
  }
  _createCanvasAndContext(pixelWidth, pixelHeight) {
    const canvas = DOMAdapter.get().createCanvas();
    canvas.width = pixelWidth;
    canvas.height = pixelHeight;
    const context2 = canvas.getContext("2d");
    return { canvas, context: context2 };
  }
  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
    minWidth = Math.ceil(minWidth * resolution - 0.000001);
    minHeight = Math.ceil(minHeight * resolution - 0.000001);
    minWidth = nextPow2(minWidth);
    minHeight = nextPow2(minHeight);
    const key = (minWidth << 17) + (minHeight << 1);
    if (!this._canvasPool[key]) {
      this._canvasPool[key] = [];
    }
    let canvasAndContext = this._canvasPool[key].pop();
    if (!canvasAndContext) {
      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
    }
    return canvasAndContext;
  }
  returnCanvasAndContext(canvasAndContext) {
    const canvas = canvasAndContext.canvas;
    const { width, height } = canvas;
    const key = (width << 17) + (height << 1);
    canvasAndContext.context.resetTransform();
    canvasAndContext.context.clearRect(0, 0, width, height);
    this._canvasPool[key].push(canvasAndContext);
  }
  clear() {
    this._canvasPool = {};
  }
}
var CanvasPool;
var init_CanvasPool = __esm(() => {
  init_adapter();
  init_pow2();
  init_GlobalResourceRegistry();
  CanvasPool = new CanvasPoolClass;
  GlobalResourceRegistry.register(CanvasPool);
});

// node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs
function ensureInternalCanvas(width, height) {
  if (!_internalCanvas) {
    _internalCanvas = DOMAdapter.get().createCanvas(256, 128);
    _internalContext = _internalCanvas.getContext("2d", { willReadFrequently: true });
    _internalContext.globalCompositeOperation = "copy";
    _internalContext.globalAlpha = 1;
  }
  if (_internalCanvas.width < width || _internalCanvas.height < height) {
    _internalCanvas.width = nextPow2(width);
    _internalCanvas.height = nextPow2(height);
  }
}
function checkRow(data, width, y2) {
  for (let x2 = 0, index = 4 * y2 * width;x2 < width; ++x2, index += 4) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x2, top, bottom) {
  const stride = 4 * width;
  for (let y2 = top, index = top * stride + 4 * x2;y2 <= bottom; ++y2, index += stride) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(...args) {
  let options = args[0];
  if (!options.canvas) {
    options = { canvas: args[0], resolution: args[1] };
  }
  const { canvas } = options;
  const resolution = Math.min(options.resolution ?? 1, 1);
  const width = options.width ?? canvas.width;
  const height = options.height ?? canvas.height;
  let output = options.output;
  ensureInternalCanvas(width, height);
  if (!_internalContext) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  _internalContext.drawImage(canvas, 0, 0, width, height, 0, 0, width * resolution, height * resolution);
  const imageData = _internalContext.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return Rectangle.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  _internalContext.globalCompositeOperation = "source-over";
  _internalContext.strokeRect(left, top, right - left, bottom - top);
  _internalContext.globalCompositeOperation = "copy";
  output ?? (output = new Rectangle);
  output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
  return output;
}
var _internalCanvas = null, _internalContext = null;
var init_getCanvasBoundingBox = __esm(() => {
  init_adapter();
  init_pow2();
  init_Rectangle();
});

// node_modules/tiny-lru/dist/tiny-lru.js
class LRU {
  constructor(max = 0, ttl = 0, resetTtl = false) {
    this.first = null;
    this.items = Object.create(null);
    this.last = null;
    this.max = max;
    this.resetTtl = resetTtl;
    this.size = 0;
    this.ttl = ttl;
  }
  clear() {
    this.first = null;
    this.items = Object.create(null);
    this.last = null;
    this.size = 0;
    return this;
  }
  delete(key) {
    if (this.has(key)) {
      const item = this.items[key];
      delete this.items[key];
      this.size--;
      if (item.prev !== null) {
        item.prev.next = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      }
      if (this.first === item) {
        this.first = item.next;
      }
      if (this.last === item) {
        this.last = item.prev;
      }
    }
    return this;
  }
  entries(keys = this.keys()) {
    return keys.map((key) => [key, this.get(key)]);
  }
  evict(bypass = false) {
    if (bypass || this.size > 0) {
      const item = this.first;
      delete this.items[item.key];
      if (--this.size === 0) {
        this.first = null;
        this.last = null;
      } else {
        this.first = item.next;
        this.first.prev = null;
      }
    }
    return this;
  }
  expiresAt(key) {
    let result;
    if (this.has(key)) {
      result = this.items[key].expiry;
    }
    return result;
  }
  get(key) {
    const item = this.items[key];
    if (item !== undefined) {
      if (this.ttl > 0) {
        if (item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
      }
      this.moveToEnd(item);
      return item.value;
    }
    return;
  }
  has(key) {
    return key in this.items;
  }
  moveToEnd(item) {
    if (this.last === item) {
      return;
    }
    if (item.prev !== null) {
      item.prev.next = item.next;
    }
    if (item.next !== null) {
      item.next.prev = item.prev;
    }
    if (this.first === item) {
      this.first = item.next;
    }
    item.prev = this.last;
    item.next = null;
    if (this.last !== null) {
      this.last.next = item;
    }
    this.last = item;
    if (this.first === null) {
      this.first = item;
    }
  }
  keys() {
    const result = [];
    let x2 = this.first;
    while (x2 !== null) {
      result.push(x2.key);
      x2 = x2.next;
    }
    return result;
  }
  setWithEvicted(key, value, resetTtl = this.resetTtl) {
    let evicted = null;
    if (this.has(key)) {
      this.set(key, value, true, resetTtl);
    } else {
      if (this.max > 0 && this.size === this.max) {
        evicted = { ...this.first };
        this.evict(true);
      }
      let item = this.items[key] = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
    return evicted;
  }
  set(key, value, bypass = false, resetTtl = this.resetTtl) {
    let item = this.items[key];
    if (bypass || item !== undefined) {
      item.value = value;
      if (bypass === false && resetTtl) {
        item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      }
      this.moveToEnd(item);
    } else {
      if (this.max > 0 && this.size === this.max) {
        this.evict(true);
      }
      item = this.items[key] = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
    return this;
  }
  values(keys = this.keys()) {
    return keys.map((key) => this.get(key));
  }
}
function lru(max = 1000, ttl = 0, resetTtl = false) {
  if (isNaN(max) || max < 0) {
    throw new TypeError("Invalid max value");
  }
  if (isNaN(ttl) || ttl < 0) {
    throw new TypeError("Invalid ttl value");
  }
  if (typeof resetTtl !== "boolean") {
    throw new TypeError("Invalid resetTtl value");
  }
  return new LRU(max, ttl, resetTtl);
}
var init_tiny_lru = () => {};

// node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
function fontStringFromTextStyle(style) {
  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
  let fontFamilies = style.fontFamily;
  if (!Array.isArray(style.fontFamily)) {
    fontFamilies = style.fontFamily.split(",");
  }
  for (let i2 = fontFamilies.length - 1;i2 >= 0; i2--) {
    let fontFamily = fontFamilies[i2].trim();
    if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
      fontFamily = `"${fontFamily}"`;
    }
    fontFamilies[i2] = fontFamily;
  }
  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}
var genericFontFamilies;
var init_fontStringFromTextStyle = __esm(() => {
  genericFontFamilies = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
var contextSettings, _CanvasTextMetrics = class _CanvasTextMetrics2 {
  static get experimentalLetterSpacingSupported() {
    let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
    if (result === undefined) {
      const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
      result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  static measureText(text = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
    const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;
    if (_CanvasTextMetrics2._measurementCache.has(textKey)) {
      return _CanvasTextMetrics2._measurementCache.get(textKey);
    }
    const font = fontStringFromTextStyle(style);
    const fontProperties = _CanvasTextMetrics2.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context2 = _CanvasTextMetrics2.__context;
    context2.font = font;
    const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i2 = 0;i2 < lines.length; i2++) {
      const lineWidth = _CanvasTextMetrics2._measureText(lines[i2], style.letterSpacing, context2);
      lineWidths[i2] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    const strokeWidth = style._stroke?.width || 0;
    let width = maxLineWidth + strokeWidth;
    if (style.dropShadow) {
      width += style.dropShadow.distance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize;
    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadow.distance;
    }
    const measurements = new _CanvasTextMetrics2(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    _CanvasTextMetrics2._measurementCache.set(textKey, measurements);
    return measurements;
  }
  static _measureText(text, letterSpacing, context2) {
    let useExperimentalLetterSpacing = false;
    if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
      if (_CanvasTextMetrics2.experimentalLetterSpacing) {
        context2.letterSpacing = `${letterSpacing}px`;
        context2.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context2.letterSpacing = "0px";
        context2.textLetterSpacing = "0px";
      }
    }
    const metrics = context2.measureText(text);
    let metricWidth = metrics.width;
    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
    if (metricWidth > 0) {
      if (useExperimentalLetterSpacing) {
        metricWidth -= letterSpacing;
        boundsWidth -= letterSpacing;
      } else {
        const val = (_CanvasTextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing;
        metricWidth += val;
        boundsWidth += val;
      }
    }
    return Math.max(metricWidth, boundsWidth);
  }
  static _wordWrap(text, style, canvas = _CanvasTextMetrics2._canvas) {
    const context2 = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache = /* @__PURE__ */ Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
    const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _CanvasTextMetrics2._tokenize(text);
    for (let i2 = 0;i2 < tokens.length; i2++) {
      let token = tokens[i2];
      if (_CanvasTextMetrics2._isNewline(token)) {
        if (!collapseNewlines) {
          lines += _CanvasTextMetrics2._addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
        const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context2);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _CanvasTextMetrics2._addLine(line);
          line = "";
          width = 0;
        }
        if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
          const characters = _CanvasTextMetrics2.wordWrapSplit(token);
          for (let j2 = 0;j2 < characters.length; j2++) {
            let char = characters[j2];
            let lastChar = char;
            let k2 = 1;
            while (characters[j2 + k2]) {
              const nextChar = characters[j2 + k2];
              if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k2++;
            }
            j2 += k2 - 1;
            const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context2);
            if (characterWidth + width > wordWrapWidth) {
              lines += _CanvasTextMetrics2._addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _CanvasTextMetrics2._addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i2 === tokens.length - 1;
          lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _CanvasTextMetrics2._addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _CanvasTextMetrics2._addLine(line, false);
    return lines;
  }
  static _addLine(line, newLine = true) {
    line = _CanvasTextMetrics2._trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  static _getFromCache(key, letterSpacing, cache, context2) {
    let width = cache[key];
    if (typeof width !== "number") {
      width = _CanvasTextMetrics2._measureText(key, letterSpacing, context2) + letterSpacing;
      cache[key] = width;
    }
    return width;
  }
  static _collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  static _collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  static _trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i2 = text.length - 1;i2 >= 0; i2--) {
      const char = text[i2];
      if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  static _isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
  }
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
  }
  static _tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i2 = 0;i2 < text.length; i2++) {
      const char = text[i2];
      const nextChar = text[i2 + 1];
      if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        if (char === "\r" && nextChar === `
`) {
          tokens.push(`\r
`);
          i2++;
        } else {
          tokens.push(char);
        }
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  static wordWrapSplit(token) {
    return _CanvasTextMetrics2.graphemeSegmenter(token);
  }
  static measureFont(font) {
    if (_CanvasTextMetrics2._fonts[font]) {
      return _CanvasTextMetrics2._fonts[font];
    }
    const context2 = _CanvasTextMetrics2._context;
    context2.font = font;
    const metrics = context2.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
    const properties = {
      ascent: metrics.actualBoundingBoxAscent,
      descent: metrics.actualBoundingBoxDescent,
      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
    };
    _CanvasTextMetrics2._fonts[font] = properties;
    return properties;
  }
  static clearMetrics(font = "") {
    if (font) {
      delete _CanvasTextMetrics2._fonts[font];
    } else {
      _CanvasTextMetrics2._fonts = {};
    }
  }
  static get _canvas() {
    if (!_CanvasTextMetrics2.__canvas) {
      let canvas;
      try {
        const c2 = new OffscreenCanvas(0, 0);
        const context2 = c2.getContext("2d", contextSettings);
        if (context2?.measureText) {
          _CanvasTextMetrics2.__canvas = c2;
          return c2;
        }
        canvas = DOMAdapter.get().createCanvas();
      } catch (_cx) {
        canvas = DOMAdapter.get().createCanvas();
      }
      canvas.width = canvas.height = 10;
      _CanvasTextMetrics2.__canvas = canvas;
    }
    return _CanvasTextMetrics2.__canvas;
  }
  static get _context() {
    if (!_CanvasTextMetrics2.__context) {
      _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
    }
    return _CanvasTextMetrics2.__context;
  }
}, CanvasTextMetrics;
var init_CanvasTextMetrics = __esm(() => {
  init_tiny_lru();
  init_adapter();
  init_fontStringFromTextStyle();
  contextSettings = {
    willReadFrequently: true
  };
  _CanvasTextMetrics.METRICS_STRING = "|ÉqÅ";
  _CanvasTextMetrics.BASELINE_SYMBOL = "M";
  _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
  _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
  _CanvasTextMetrics.graphemeSegmenter = (() => {
    if (typeof Intl?.Segmenter === "function") {
      const segmenter = new Intl.Segmenter;
      return (s2) => {
        const segments = segmenter.segment(s2);
        const result = [];
        let i2 = 0;
        for (const segment of segments) {
          result[i2++] = segment.segment;
        }
        return result;
      };
    }
    return (s2) => [...s2];
  })();
  _CanvasTextMetrics.experimentalLetterSpacing = false;
  _CanvasTextMetrics._fonts = {};
  _CanvasTextMetrics._newlines = [
    10,
    13
  ];
  _CanvasTextMetrics._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  _CanvasTextMetrics._measurementCache = lru(1000);
  CanvasTextMetrics = _CanvasTextMetrics;
});

// node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
function getCanvasFillStyle(fillStyle, context2, textMetrics, padding = 0) {
  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
    return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
  } else if (!fillStyle.fill) {
    const pattern = context2.createPattern(fillStyle.texture.source.resource, "repeat");
    const tempMatrix5 = fillStyle.matrix.copyTo(Matrix.shared);
    tempMatrix5.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
    pattern.setTransform(tempMatrix5);
    return pattern;
  } else if (fillStyle.fill instanceof FillPattern) {
    const fillPattern = fillStyle.fill;
    const pattern = context2.createPattern(fillPattern.texture.source.resource, "repeat");
    const tempMatrix5 = fillPattern.transform.copyTo(Matrix.shared);
    tempMatrix5.scale(fillPattern.texture.frame.width, fillPattern.texture.frame.height);
    pattern.setTransform(tempMatrix5);
    return pattern;
  } else if (fillStyle.fill instanceof FillGradient) {
    const fillGradient = fillStyle.fill;
    const isLinear = fillGradient.type === "linear";
    const isLocal = fillGradient.textureSpace === "local";
    let width = 1;
    let height = 1;
    if (isLocal && textMetrics) {
      width = textMetrics.width + padding;
      height = textMetrics.height + padding;
    }
    let gradient;
    let isNearlyVertical = false;
    if (isLinear) {
      const { start, end } = fillGradient;
      gradient = context2.createLinearGradient(start.x * width, start.y * height, end.x * width, end.y * height);
      isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);
    } else {
      const { center, innerRadius, outerCenter, outerRadius } = fillGradient;
      gradient = context2.createRadialGradient(center.x * width, center.y * height, innerRadius * width, outerCenter.x * width, outerCenter.y * height, outerRadius * width);
    }
    if (isNearlyVertical && isLocal && textMetrics) {
      const ratio = textMetrics.lineHeight / height;
      for (let i2 = 0;i2 < textMetrics.lines.length; i2++) {
        const start = (i2 * textMetrics.lineHeight + padding / 2) / height;
        fillGradient.colorStops.forEach((stop) => {
          const globalStop = start + stop.offset * ratio;
          gradient.addColorStop(Math.floor(globalStop * PRECISION) / PRECISION, Color.shared.setValue(stop.color).toHex());
        });
      }
    } else {
      fillGradient.colorStops.forEach((stop) => {
        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
      });
    }
    return gradient;
  }
  warn("FillStyle not recognised", fillStyle);
  return "red";
}
var PRECISION = 1e5;
var init_getCanvasFillStyle = __esm(() => {
  init_Color();
  init_Matrix();
  init_Texture();
  init_warn();
  init_FillGradient();
  init_FillPattern();
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs
class CanvasTextGeneratorClass {
  getCanvasAndContext(options) {
    const { text, style, resolution = 1 } = options;
    const padding = style._getFinalPadding();
    const measured = CanvasTextMetrics.measureText(text || " ", style);
    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + padding * 2) * resolution);
    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + padding * 2) * resolution);
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
    this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);
    const frame = style.trim ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect4 }) : tempRect4.set(0, 0, width, height);
    return {
      canvasAndContext,
      frame
    };
  }
  returnCanvasAndContext(canvasAndContext) {
    CanvasPool.returnCanvasAndContext(canvasAndContext);
  }
  _renderTextToCanvas(text, style, padding, resolution, canvasAndContext) {
    const { canvas, context: context2 } = canvasAndContext;
    const font = fontStringFromTextStyle(style);
    const measured = CanvasTextMetrics.measureText(text || " ", style);
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    const height = canvas.height;
    context2.resetTransform();
    context2.scale(resolution, resolution);
    context2.textBaseline = style.textBaseline;
    if (style._stroke?.width) {
      const strokeStyle = style._stroke;
      context2.lineWidth = strokeStyle.width;
      context2.miterLimit = strokeStyle.miterLimit;
      context2.lineJoin = strokeStyle.join;
      context2.lineCap = strokeStyle.cap;
    }
    context2.font = font;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i2 = 0;i2 < passesCount; ++i2) {
      const isShadowPass = style.dropShadow && i2 === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * resolution;
      if (isShadowPass) {
        context2.fillStyle = "black";
        context2.strokeStyle = "black";
        const shadowOptions = style.dropShadow;
        const dropShadowColor = shadowOptions.color;
        const dropShadowAlpha = shadowOptions.alpha;
        context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
        const dropShadowBlur = shadowOptions.blur * resolution;
        const dropShadowDistance = shadowOptions.distance * resolution;
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context2.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context2, measured, padding * 2) : null;
        if (style._stroke?.width) {
          const strokePadding = style._stroke.width * 0.5 + padding * 2;
          context2.strokeStyle = getCanvasFillStyle(style._stroke, context2, measured, strokePadding);
        }
        context2.shadowColor = "black";
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      const strokeWidth = style._stroke?.width ?? 0;
      for (let i22 = 0;i22 < lines.length; i22++) {
        linePositionX = strokeWidth / 2;
        linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i22];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
        }
        if (style._stroke?.width) {
          this._drawLetterSpacing(lines[i22], style, canvasAndContext, linePositionX + padding, linePositionY + padding - dsOffsetText, true);
        }
        if (style._fill !== undefined) {
          this._drawLetterSpacing(lines[i22], style, canvasAndContext, linePositionX + padding, linePositionY + padding - dsOffsetText);
        }
      }
    }
  }
  _drawLetterSpacing(text, style, canvasAndContext, x2, y2, isStroke = false) {
    const { context: context2 } = canvasAndContext;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
      if (CanvasTextMetrics.experimentalLetterSpacing) {
        context2.letterSpacing = `${letterSpacing}px`;
        context2.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context2.letterSpacing = "0px";
        context2.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        context2.strokeText(text, x2, y2);
      } else {
        context2.fillText(text, x2, y2);
      }
      return;
    }
    let currentPosition = x2;
    const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
    let previousWidth = context2.measureText(text).width;
    let currentWidth = 0;
    for (let i2 = 0;i2 < stringArray.length; ++i2) {
      const currentChar = stringArray[i2];
      if (isStroke) {
        context2.strokeText(currentChar, currentPosition, y2);
      } else {
        context2.fillText(currentChar, currentPosition, y2);
      }
      let textStr = "";
      for (let j2 = i2 + 1;j2 < stringArray.length; ++j2) {
        textStr += stringArray[j2];
      }
      currentWidth = context2.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
}
var tempRect4, CanvasTextGenerator;
var init_CanvasTextGenerator = __esm(() => {
  init_Color();
  init_Rectangle();
  init_CanvasPool();
  init_getCanvasBoundingBox();
  init_CanvasTextMetrics();
  init_fontStringFromTextStyle();
  init_getCanvasFillStyle();
  tempRect4 = new Rectangle;
  CanvasTextGenerator = new CanvasTextGeneratorClass;
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
class CanvasTextSystem {
  constructor(_renderer) {
    this._activeTextures = {};
    this._renderer = _renderer;
  }
  getTexture(options, _resolution, _style, _textKey) {
    if (typeof options === "string") {
      deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
      options = {
        text: options,
        style: _style,
        resolution: _resolution
      };
    }
    if (!(options.style instanceof TextStyle)) {
      options.style = new TextStyle(options.style);
    }
    if (!(options.textureStyle instanceof TextureStyle)) {
      options.textureStyle = new TextureStyle(options.textureStyle);
    }
    if (typeof options.text !== "string") {
      options.text = options.text.toString();
    }
    const { text, style, textureStyle } = options;
    const resolution = options.resolution ?? this._renderer.resolution;
    const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({
      text,
      style,
      resolution
    });
    const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);
    if (textureStyle)
      texture.source.style = textureStyle;
    if (style.trim) {
      frame.pad(style.padding);
      texture.frame.copyFrom(frame);
      texture.frame.scale(1 / resolution);
      texture.updateUvs();
    }
    if (style.filters) {
      const filteredTexture = this._applyFilters(texture, style.filters);
      this.returnTexture(texture);
      CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
      return filteredTexture;
    }
    this._renderer.texture.initSource(texture._source);
    CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
    return texture;
  }
  returnTexture(texture) {
    const source = texture.source;
    source.resource = null;
    source.uploadMethodId = "unknown";
    source.alphaMode = "no-premultiply-alpha";
    TexturePool.returnTexture(texture, true);
  }
  renderTextToCanvas() {
    deprecation("8.10.0", "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead");
  }
  getManagedTexture(text) {
    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
    const textKey = text.styleKey;
    if (this._activeTextures[textKey]) {
      this._increaseReferenceCount(textKey);
      return this._activeTextures[textKey].texture;
    }
    const texture = this.getTexture({
      text: text.text,
      style: text.style,
      resolution: text._resolution,
      textureStyle: text.textureStyle
    });
    this._activeTextures[textKey] = {
      texture,
      usageCount: 1
    };
    return texture;
  }
  decreaseReferenceCount(textKey) {
    const activeTexture = this._activeTextures[textKey];
    activeTexture.usageCount--;
    if (activeTexture.usageCount === 0) {
      this.returnTexture(activeTexture.texture);
      this._activeTextures[textKey] = null;
    }
  }
  getReferenceCount(textKey) {
    return this._activeTextures[textKey]?.usageCount ?? 0;
  }
  _increaseReferenceCount(textKey) {
    this._activeTextures[textKey].usageCount++;
  }
  _applyFilters(texture, filters) {
    const currentRenderTarget = this._renderer.renderTarget.renderTarget;
    const resultTexture = this._renderer.filter.generateFilteredTexture({
      texture,
      filters
    });
    this._renderer.renderTarget.bind(currentRenderTarget, false);
    return resultTexture;
  }
  destroy() {
    this._renderer = null;
    for (const key in this._activeTextures) {
      if (this._activeTextures[key])
        this.returnTexture(this._activeTextures[key].texture);
    }
    this._activeTextures = null;
  }
}
var init_CanvasTextSystem = __esm(() => {
  init_Extensions();
  init_TexturePool();
  init_TextureStyle();
  init_deprecation();
  init_TextStyle();
  init_getPo2TextureFromSource();
  init_CanvasTextGenerator();
  CanvasTextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "canvasText"
  };
});

// node_modules/pixi.js/lib/scene/text/init.mjs
var init_init10 = __esm(() => {
  init_Extensions();
  init_CanvasTextPipe();
  init_CanvasTextSystem();
  extensions.add(CanvasTextSystem);
  extensions.add(CanvasTextPipe);
});

// node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
var Graphics;
var init_Graphics = __esm(() => {
  init_deprecation();
  init_ViewContainer();
  init_GraphicsContext();
  Graphics = class Graphics extends ViewContainer {
    constructor(options) {
      if (options instanceof GraphicsContext) {
        options = { context: options };
      }
      const { context: context2, roundPixels, ...rest } = options || {};
      super({
        label: "Graphics",
        ...rest
      });
      this.renderPipeId = "graphics";
      if (!context2) {
        this._context = this._ownedContext = new GraphicsContext;
      } else {
        this._context = context2;
      }
      this._context.on("update", this.onViewUpdate, this);
      this.didViewUpdate = true;
      this.allowChildren = false;
      this.roundPixels = roundPixels ?? false;
    }
    set context(context2) {
      if (context2 === this._context)
        return;
      this._context.off("update", this.onViewUpdate, this);
      this._context = context2;
      this._context.on("update", this.onViewUpdate, this);
      this.onViewUpdate();
    }
    get context() {
      return this._context;
    }
    get bounds() {
      return this._context.bounds;
    }
    updateBounds() {}
    containsPoint(point) {
      return this._context.containsPoint(point);
    }
    destroy(options) {
      if (this._ownedContext && !options) {
        this._ownedContext.destroy(options);
      } else if (options === true || options?.context === true) {
        this._context.destroy(options);
      }
      this._ownedContext = null;
      this._context = null;
      super.destroy(options);
    }
    _callContextMethod(method, args) {
      this.context[method](...args);
      return this;
    }
    setFillStyle(...args) {
      return this._callContextMethod("setFillStyle", args);
    }
    setStrokeStyle(...args) {
      return this._callContextMethod("setStrokeStyle", args);
    }
    fill(...args) {
      return this._callContextMethod("fill", args);
    }
    stroke(...args) {
      return this._callContextMethod("stroke", args);
    }
    texture(...args) {
      return this._callContextMethod("texture", args);
    }
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...args) {
      return this._callContextMethod("arc", args);
    }
    arcTo(...args) {
      return this._callContextMethod("arcTo", args);
    }
    arcToSvg(...args) {
      return this._callContextMethod("arcToSvg", args);
    }
    bezierCurveTo(...args) {
      return this._callContextMethod("bezierCurveTo", args);
    }
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...args) {
      return this._callContextMethod("ellipse", args);
    }
    circle(...args) {
      return this._callContextMethod("circle", args);
    }
    path(...args) {
      return this._callContextMethod("path", args);
    }
    lineTo(...args) {
      return this._callContextMethod("lineTo", args);
    }
    moveTo(...args) {
      return this._callContextMethod("moveTo", args);
    }
    quadraticCurveTo(...args) {
      return this._callContextMethod("quadraticCurveTo", args);
    }
    rect(...args) {
      return this._callContextMethod("rect", args);
    }
    roundRect(...args) {
      return this._callContextMethod("roundRect", args);
    }
    poly(...args) {
      return this._callContextMethod("poly", args);
    }
    regularPoly(...args) {
      return this._callContextMethod("regularPoly", args);
    }
    roundPoly(...args) {
      return this._callContextMethod("roundPoly", args);
    }
    roundShape(...args) {
      return this._callContextMethod("roundShape", args);
    }
    filletRect(...args) {
      return this._callContextMethod("filletRect", args);
    }
    chamferRect(...args) {
      return this._callContextMethod("chamferRect", args);
    }
    star(...args) {
      return this._callContextMethod("star", args);
    }
    svg(...args) {
      return this._callContextMethod("svg", args);
    }
    restore(...args) {
      return this._callContextMethod("restore", args);
    }
    save() {
      return this._callContextMethod("save", []);
    }
    getTransform() {
      return this.context.getTransform();
    }
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...args) {
      return this._callContextMethod("rotate", args);
    }
    scaleTransform(...args) {
      return this._callContextMethod("scale", args);
    }
    setTransform(...args) {
      return this._callContextMethod("setTransform", args);
    }
    transform(...args) {
      return this._callContextMethod("transform", args);
    }
    translateTransform(...args) {
      return this._callContextMethod("translate", args);
    }
    clear() {
      return this._callContextMethod("clear", []);
    }
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(value) {
      this._context.fillStyle = value;
    }
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(value) {
      this._context.strokeStyle = value;
    }
    clone(deep = false) {
      if (deep) {
        return new Graphics(this._context.clone());
      }
      this._ownedContext = null;
      const clone = new Graphics(this._context);
      return clone;
    }
    lineStyle(width, color, alpha) {
      deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
      const strokeStyle = {};
      width && (strokeStyle.width = width);
      color && (strokeStyle.color = color);
      alpha && (strokeStyle.alpha = alpha);
      this.context.strokeStyle = strokeStyle;
      return this;
    }
    beginFill(color, alpha) {
      deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      const fillStyle = {};
      if (color !== undefined)
        fillStyle.color = color;
      if (alpha !== undefined)
        fillStyle.alpha = alpha;
      this.context.fillStyle = fillStyle;
      return this;
    }
    endFill() {
      deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      this.context.fill();
      const strokeStyle = this.context.strokeStyle;
      if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
        this.context.stroke();
      }
      return this;
    }
    drawCircle(...args) {
      deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
      return this._callContextMethod("circle", args);
    }
    drawEllipse(...args) {
      deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
      return this._callContextMethod("ellipse", args);
    }
    drawPolygon(...args) {
      deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
      return this._callContextMethod("poly", args);
    }
    drawRect(...args) {
      deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
      return this._callContextMethod("rect", args);
    }
    drawRoundedRect(...args) {
      deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
      return this._callContextMethod("roundRect", args);
    }
    drawStar(...args) {
      deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
      return this._callContextMethod("star", args);
    }
  };
});

// node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
var localUniformMSDFBit, localUniformMSDFBitGl;
var init_localUniformMSDFBit = __esm(() => {
  localUniformMSDFBit = {
    name: "local-uniform-msdf-bit",
    vertex: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    },
    fragment: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
      main: `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
    }
  };
  localUniformMSDFBitGl = {
    name: "local-uniform-msdf-bit",
    vertex: {
      header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
      main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
      end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    },
    fragment: {
      header: `
            uniform float uDistance;
         `,
      main: `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
    }
  };
});

// node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
var mSDFBit, mSDFBitGl;
var init_mSDFBit = __esm(() => {
  mSDFBit = {
    name: "msdf-bit",
    fragment: {
      header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `
    }
  };
  mSDFBitGl = {
    name: "msdf-bit",
    fragment: {
      header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `
    }
  };
});

// node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
var gpuProgram, glProgram, SdfShader;
var init_SdfShader = __esm(() => {
  init_Matrix();
  init_compileHighShaderToProgram();
  init_colorBit();
  init_generateTextureBatchBit();
  init_roundPixelsBit();
  init_getBatchSamplersUniformGroup();
  init_Shader();
  init_UniformGroup();
  init_localUniformMSDFBit();
  init_mSDFBit();
  SdfShader = class SdfShader extends Shader {
    constructor(maxTextures) {
      const uniforms = new UniformGroup({
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uTransformMatrix: { value: new Matrix, type: "mat3x3<f32>" },
        uDistance: { value: 4, type: "f32" },
        uRound: { value: 0, type: "f32" }
      });
      gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({
        name: "sdf-shader",
        bits: [
          colorBit,
          generateTextureBatchBit(maxTextures),
          localUniformMSDFBit,
          mSDFBit,
          roundPixelsBit
        ]
      }));
      glProgram ?? (glProgram = compileHighShaderGlProgram({
        name: "sdf-shader",
        bits: [
          colorBitGl,
          generateTextureBatchBitGl(maxTextures),
          localUniformMSDFBitGl,
          mSDFBitGl,
          roundPixelsBitGl
        ]
      }));
      super({
        glProgram,
        gpuProgram,
        resources: {
          localUniforms: uniforms,
          batchSamplers: getBatchSamplersUniformGroup(maxTextures)
        }
      });
    }
  };
});

// node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs
var AbstractBitmapFont;
var init_AbstractBitmapFont = __esm(() => {
  init_eventemitter3();
  init_deprecation();
  AbstractBitmapFont = class AbstractBitmapFont extends eventemitter3_default {
    constructor() {
      super(...arguments);
      this.chars = /* @__PURE__ */ Object.create(null);
      this.lineHeight = 0;
      this.fontFamily = "";
      this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
      this.baseLineOffset = 0;
      this.distanceField = { type: "none", range: 0 };
      this.pages = [];
      this.applyFillAsTint = true;
      this.baseMeasurementFontSize = 100;
      this.baseRenderedFontSize = 100;
    }
    get font() {
      deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
      return this.fontFamily;
    }
    get pageTextures() {
      deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
      return this.pages;
    }
    get size() {
      deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
      return this.fontMetrics.fontSize;
    }
    get distanceFieldRange() {
      deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
      return this.distanceField.range;
    }
    get distanceFieldType() {
      deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
      return this.distanceField.type;
    }
    destroy(destroyTextures = false) {
      this.emit("destroy", this);
      this.removeAllListeners();
      for (const i2 in this.chars) {
        this.chars[i2].texture?.destroy();
      }
      this.chars = null;
      if (destroyTextures) {
        this.pages.forEach((page) => page.texture.destroy(true));
        this.pages = null;
      }
    }
  };
});

// node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs
var _DynamicBitmapFont, DynamicBitmapFont;
var init_DynamicBitmapFont = __esm(() => {
  init_Color();
  init_Rectangle();
  init_CanvasPool();
  init_ImageSource();
  init_Texture();
  init_TextureStyle();
  init_deprecation();
  init_CanvasTextMetrics();
  init_fontStringFromTextStyle();
  init_getCanvasFillStyle();
  init_TextStyle();
  init_AbstractBitmapFont();
  _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
    constructor(options) {
      super();
      this.resolution = 1;
      this.pages = [];
      this._padding = 0;
      this._measureCache = /* @__PURE__ */ Object.create(null);
      this._currentChars = [];
      this._currentX = 0;
      this._currentY = 0;
      this._currentMaxCharHeight = 0;
      this._currentPageIndex = -1;
      this._skipKerning = false;
      const dynamicOptions = { ..._DynamicBitmapFont2.defaultOptions, ...options };
      this._textureSize = dynamicOptions.textureSize;
      this._mipmap = dynamicOptions.mipmap;
      const style = dynamicOptions.style.clone();
      if (dynamicOptions.overrideFill) {
        style._fill.color = 16777215;
        style._fill.alpha = 1;
        style._fill.texture = Texture.WHITE;
        style._fill.fill = null;
      }
      this.applyFillAsTint = dynamicOptions.overrideFill;
      const requestedFontSize = style.fontSize;
      style.fontSize = this.baseMeasurementFontSize;
      const font = fontStringFromTextStyle(style);
      if (dynamicOptions.overrideSize) {
        if (style._stroke) {
          style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
        }
      } else {
        style.fontSize = this.baseRenderedFontSize = requestedFontSize;
      }
      this._style = style;
      this._skipKerning = dynamicOptions.skipKerning ?? false;
      this.resolution = dynamicOptions.resolution ?? 1;
      this._padding = dynamicOptions.padding ?? 4;
      if (dynamicOptions.textureStyle) {
        this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle ? dynamicOptions.textureStyle : new TextureStyle(dynamicOptions.textureStyle);
      }
      this.fontMetrics = CanvasTextMetrics.measureFont(font);
      this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
    }
    ensureCharacters(chars) {
      const charList = CanvasTextMetrics.graphemeSegmenter(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
      if (!charList.length)
        return;
      this._currentChars = [...this._currentChars, ...charList];
      let pageData;
      if (this._currentPageIndex === -1) {
        pageData = this._nextPage();
      } else {
        pageData = this.pages[this._currentPageIndex];
      }
      let { canvas, context: context2 } = pageData.canvasAndContext;
      let textureSource = pageData.texture.source;
      const style = this._style;
      let currentX = this._currentX;
      let currentY = this._currentY;
      let currentMaxCharHeight = this._currentMaxCharHeight;
      const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
      const padding = this._padding * fontScale;
      let skipTexture = false;
      const maxTextureWidth = canvas.width / this.resolution;
      const maxTextureHeight = canvas.height / this.resolution;
      for (let i2 = 0;i2 < charList.length; i2++) {
        const char = charList[i2];
        const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
        metrics.lineHeight = metrics.height;
        const width = metrics.width * fontScale;
        const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
        const height = metrics.height * fontScale;
        const paddedWidth = textureGlyphWidth + padding * 2;
        const paddedHeight = height + padding * 2;
        skipTexture = false;
        if (char !== `
` && char !== "\r" && char !== "\t" && char !== " ") {
          skipTexture = true;
          currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));
        }
        if (currentX + paddedWidth > maxTextureWidth) {
          currentY += currentMaxCharHeight;
          currentMaxCharHeight = paddedHeight;
          currentX = 0;
          if (currentY + currentMaxCharHeight > maxTextureHeight) {
            textureSource.update();
            const pageData2 = this._nextPage();
            canvas = pageData2.canvasAndContext.canvas;
            context2 = pageData2.canvasAndContext.context;
            textureSource = pageData2.texture.source;
            currentX = 0;
            currentY = 0;
            currentMaxCharHeight = 0;
          }
        }
        const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
        this.chars[char] = {
          id: char.codePointAt(0),
          xOffset: -this._padding,
          yOffset: -this._padding,
          xAdvance,
          kerning: {}
        };
        if (skipTexture) {
          this._drawGlyph(context2, metrics, currentX + padding, currentY + padding, fontScale, style);
          const px = textureSource.width * fontScale;
          const py = textureSource.height * fontScale;
          const frame = new Rectangle(currentX / px * textureSource.width, currentY / py * textureSource.height, paddedWidth / px * textureSource.width, paddedHeight / py * textureSource.height);
          this.chars[char].texture = new Texture({
            source: textureSource,
            frame
          });
          currentX += Math.ceil(paddedWidth);
        }
      }
      textureSource.update();
      this._currentX = currentX;
      this._currentY = currentY;
      this._currentMaxCharHeight = currentMaxCharHeight;
      this._skipKerning && this._applyKerning(charList, context2);
    }
    get pageTextures() {
      deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
      return this.pages;
    }
    _applyKerning(newChars, context2) {
      const measureCache = this._measureCache;
      for (let i2 = 0;i2 < newChars.length; i2++) {
        const first = newChars[i2];
        for (let j2 = 0;j2 < this._currentChars.length; j2++) {
          const second = this._currentChars[j2];
          let c1 = measureCache[first];
          if (!c1)
            c1 = measureCache[first] = context2.measureText(first).width;
          let c2 = measureCache[second];
          if (!c2)
            c2 = measureCache[second] = context2.measureText(second).width;
          let total = context2.measureText(first + second).width;
          let amount = total - (c1 + c2);
          if (amount) {
            this.chars[first].kerning[second] = amount;
          }
          total = context2.measureText(first + second).width;
          amount = total - (c1 + c2);
          if (amount) {
            this.chars[second].kerning[first] = amount;
          }
        }
      }
    }
    _nextPage() {
      this._currentPageIndex++;
      const textureResolution = this.resolution;
      const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(this._textureSize, this._textureSize, textureResolution);
      this._setupContext(canvasAndContext.context, this._style, textureResolution);
      const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
      const texture = new Texture({
        source: new ImageSource({
          resource: canvasAndContext.canvas,
          resolution,
          alphaMode: "premultiply-alpha-on-upload",
          autoGenerateMipmaps: this._mipmap
        })
      });
      if (this._textureStyle) {
        texture.source.style = this._textureStyle;
      }
      const pageData = {
        canvasAndContext,
        texture
      };
      this.pages[this._currentPageIndex] = pageData;
      return pageData;
    }
    _setupContext(context2, style, resolution) {
      style.fontSize = this.baseRenderedFontSize;
      context2.scale(resolution, resolution);
      context2.font = fontStringFromTextStyle(style);
      style.fontSize = this.baseMeasurementFontSize;
      context2.textBaseline = style.textBaseline;
      const stroke = style._stroke;
      const strokeThickness = stroke?.width ?? 0;
      if (stroke) {
        context2.lineWidth = strokeThickness;
        context2.lineJoin = stroke.join;
        context2.miterLimit = stroke.miterLimit;
        context2.strokeStyle = getCanvasFillStyle(stroke, context2);
      }
      if (style._fill) {
        context2.fillStyle = getCanvasFillStyle(style._fill, context2);
      }
      if (style.dropShadow) {
        const shadowOptions = style.dropShadow;
        const rgb = Color.shared.setValue(shadowOptions.color).toArray();
        const dropShadowBlur = shadowOptions.blur * resolution;
        const dropShadowDistance = shadowOptions.distance * resolution;
        context2.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
      } else {
        context2.shadowColor = "black";
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
    }
    _drawGlyph(context2, metrics, x2, y2, fontScale, style) {
      const char = metrics.text;
      const fontProperties = metrics.fontProperties;
      const stroke = style._stroke;
      const strokeThickness = (stroke?.width ?? 0) * fontScale;
      const tx = x2 + strokeThickness / 2;
      const ty = y2 - strokeThickness / 2;
      const descent = fontProperties.descent * fontScale;
      const lineHeight = metrics.lineHeight * fontScale;
      let removeShadow = false;
      if (style.stroke && strokeThickness) {
        removeShadow = true;
        context2.strokeText(char, tx, ty + lineHeight - descent);
      }
      const { shadowBlur, shadowOffsetX, shadowOffsetY } = context2;
      if (style._fill) {
        if (removeShadow) {
          context2.shadowBlur = 0;
          context2.shadowOffsetX = 0;
          context2.shadowOffsetY = 0;
        }
        context2.fillText(char, tx, ty + lineHeight - descent);
      }
      if (removeShadow) {
        context2.shadowBlur = shadowBlur;
        context2.shadowOffsetX = shadowOffsetX;
        context2.shadowOffsetY = shadowOffsetY;
      }
    }
    destroy() {
      super.destroy();
      for (let i2 = 0;i2 < this.pages.length; i2++) {
        const { canvasAndContext, texture } = this.pages[i2];
        CanvasPool.returnCanvasAndContext(canvasAndContext);
        texture.destroy(true);
      }
      this.pages = null;
    }
  };
  _DynamicBitmapFont.defaultOptions = {
    textureSize: 512,
    style: new TextStyle,
    mipmap: true
  };
  DynamicBitmapFont = _DynamicBitmapFont;
});

// node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
function getBitmapTextLayout(chars, style, font, trimEnd) {
  const layoutData = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: style.fontSize / font.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  layoutData.offsetY = font.baseLineOffset;
  let currentLine = layoutData.lines[0];
  let previousChar = null;
  let firstWord = true;
  const currentWord = {
    spaceWord: false,
    width: 0,
    start: 0,
    index: 0,
    positions: [],
    chars: []
  };
  const scale = font.baseMeasurementFontSize / style.fontSize;
  const adjustedLetterSpacing = style.letterSpacing * scale;
  const adjustedWordWrapWidth = style.wordWrapWidth * scale;
  const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;
  const breakWords = style.wordWrap && style.breakWords;
  const nextWord = (word) => {
    const start = currentLine.width;
    for (let j2 = 0;j2 < currentWord.index; j2++) {
      const position = word.positions[j2];
      currentLine.chars.push(word.chars[j2]);
      currentLine.charPositions.push(position + start);
    }
    currentLine.width += word.width;
    firstWord = false;
    currentWord.width = 0;
    currentWord.index = 0;
    currentWord.chars.length = 0;
  };
  const nextLine = () => {
    let index = currentLine.chars.length - 1;
    if (trimEnd) {
      let lastChar = currentLine.chars[index];
      while (lastChar === " ") {
        currentLine.width -= font.chars[lastChar].xAdvance;
        lastChar = currentLine.chars[--index];
      }
    }
    layoutData.width = Math.max(layoutData.width, currentLine.width);
    currentLine = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    };
    firstWord = true;
    layoutData.lines.push(currentLine);
    layoutData.height += adjustedLineHeight;
  };
  const checkIsOverflow = (lineWidth) => lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;
  for (let i2 = 0;i2 < chars.length + 1; i2++) {
    let char;
    const isEnd = i2 === chars.length;
    if (!isEnd) {
      char = chars[i2];
    }
    const charData = font.chars[char] || font.chars[" "];
    const isSpace = /(?:\s)/.test(char);
    const isWordBreak = isSpace || char === "\r" || char === `
` || isEnd;
    if (isWordBreak) {
      const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);
      if (addWordToNextLine) {
        nextLine();
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      } else {
        currentWord.start = currentLine.width;
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      }
      if (char === "\r" || char === `
`) {
        nextLine();
      } else if (!isEnd) {
        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
        currentLine.width += spaceWidth;
        currentLine.spaceWidth = spaceWidth;
        currentLine.spacesIndex.push(currentLine.charPositions.length);
        currentLine.chars.push(char);
      }
    } else {
      const kerning = charData.kerning[previousChar] || 0;
      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
      const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);
      if (addWordToNextLine) {
        nextWord(currentWord);
        nextLine();
      }
      currentWord.positions[currentWord.index++] = currentWord.width + kerning;
      currentWord.chars.push(char);
      currentWord.width += nextCharWidth;
    }
    previousChar = char;
  }
  nextLine();
  if (style.align === "center") {
    alignCenter(layoutData);
  } else if (style.align === "right") {
    alignRight(layoutData);
  } else if (style.align === "justify") {
    alignJustify(layoutData);
  }
  return layoutData;
}
function alignCenter(measurementData) {
  for (let i2 = 0;i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width / 2 - line.width / 2;
    for (let j2 = 0;j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignRight(measurementData) {
  for (let i2 = 0;i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width - line.width;
    for (let j2 = 0;j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignJustify(measurementData) {
  const width = measurementData.width;
  for (let i2 = 0;i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    let indy = 0;
    let spaceIndex = line.spacesIndex[indy++];
    let offset = 0;
    const totalSpaces = line.spacesIndex.length;
    const newSpaceWidth = (width - line.width) / totalSpaces;
    const spaceWidth = newSpaceWidth;
    for (let j2 = 0;j2 < line.charPositions.length; j2++) {
      if (j2 === spaceIndex) {
        spaceIndex = line.spacesIndex[indy++];
        offset += spaceWidth;
      }
      line.charPositions[j2] += offset;
    }
  }
}
var init_getBitmapTextLayout = () => {};

// node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs
function resolveCharacters(chars) {
  if (chars === "") {
    return [];
  }
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i2 = 0, j2 = chars.length;i2 < j2; i2++) {
    const item = chars[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      if (item[0].length === 0 || item[1].length === 0) {
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode;i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...Array.from(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
var init_resolveCharacters = () => {};

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs
class BitmapFontManagerClass {
  constructor() {
    this.ALPHA = [["a", "z"], ["A", "Z"], " "];
    this.NUMERIC = [["0", "9"]];
    this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
    this.ASCII = [[" ", "~"]];
    this.defaultOptions = {
      chars: this.ALPHANUMERIC,
      resolution: 1,
      padding: 4,
      skipKerning: false,
      textureStyle: null
    };
    this.measureCache = lru(1000);
  }
  getFont(text, style) {
    let fontFamilyKey = `${style.fontFamily}-bitmap`;
    let overrideFill = true;
    if (style._fill.fill && !style._stroke) {
      fontFamilyKey += style._fill.fill.styleKey;
      overrideFill = false;
    } else if (style._stroke || style.dropShadow) {
      fontFamilyKey = `${style.styleKey}-bitmap`;
      overrideFill = false;
    }
    if (!Cache.has(fontFamilyKey)) {
      const styleCopy = Object.create(style);
      styleCopy.lineHeight = 0;
      const fnt = new DynamicBitmapFont({
        style: styleCopy,
        overrideFill,
        overrideSize: true,
        ...this.defaultOptions
      });
      fontCount++;
      if (fontCount > 50) {
        warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
      }
      fnt.once("destroy", () => {
        fontCount--;
        Cache.remove(fontFamilyKey);
      });
      Cache.set(fontFamilyKey, fnt);
    }
    const dynamicFont = Cache.get(fontFamilyKey);
    dynamicFont.ensureCharacters?.(text);
    return dynamicFont;
  }
  getLayout(text, style, trimEnd = true) {
    const bitmapFont = this.getFont(text, style);
    const id = `${text}-${style.styleKey}-${trimEnd}`;
    if (this.measureCache.has(id)) {
      return this.measureCache.get(id);
    }
    const segments = CanvasTextMetrics.graphemeSegmenter(text);
    const layoutData = getBitmapTextLayout(segments, style, bitmapFont, trimEnd);
    this.measureCache.set(id, layoutData);
    return layoutData;
  }
  measureText(text, style, trimEnd = true) {
    return this.getLayout(text, style, trimEnd);
  }
  install(...args) {
    let options = args[0];
    if (typeof options === "string") {
      options = {
        name: options,
        style: args[1],
        chars: args[2]?.chars,
        resolution: args[2]?.resolution,
        padding: args[2]?.padding,
        skipKerning: args[2]?.skipKerning
      };
      deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
    }
    const name = options?.name;
    if (!name) {
      throw new Error("[BitmapFontManager] Property `name` is required.");
    }
    options = { ...this.defaultOptions, ...options };
    const textStyle = options.style;
    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    const overrideFill = options.dynamicFill ?? this._canUseTintForStyle(style);
    const font = new DynamicBitmapFont({
      style,
      overrideFill,
      skipKerning: options.skipKerning,
      padding: options.padding,
      resolution: options.resolution,
      overrideSize: false,
      textureStyle: options.textureStyle
    });
    const flatChars = resolveCharacters(options.chars);
    font.ensureCharacters(flatChars.join(""));
    Cache.set(`${name}-bitmap`, font);
    font.once("destroy", () => Cache.remove(`${name}-bitmap`));
    return font;
  }
  uninstall(name) {
    const cacheKey = `${name}-bitmap`;
    const font = Cache.get(cacheKey);
    if (font) {
      font.destroy();
    }
  }
  _canUseTintForStyle(style) {
    return !style._stroke && (!style.dropShadow || style.dropShadow.color === 0) && !style._fill.fill && style._fill.color === 16777215;
  }
}
var fontCount = 0, BitmapFontManager;
var init_BitmapFontManager = __esm(() => {
  init_tiny_lru();
  init_Cache();
  init_deprecation();
  init_warn();
  init_CanvasTextMetrics();
  init_TextStyle();
  init_DynamicBitmapFont();
  init_getBitmapTextLayout();
  init_resolveCharacters();
  BitmapFontManager = new BitmapFontManagerClass;
});

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs
class BitmapTextPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  validateRenderable(bitmapText) {
    const graphicsRenderable = this._getGpuBitmapText(bitmapText);
    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
  }
  addRenderable(bitmapText, instructionSet) {
    const graphicsRenderable = this._getGpuBitmapText(bitmapText);
    syncWithProxy(bitmapText, graphicsRenderable);
    if (bitmapText._didTextUpdate) {
      bitmapText._didTextUpdate = false;
      this._updateContext(bitmapText, graphicsRenderable);
    }
    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
    if (graphicsRenderable.context.customShader) {
      this._updateDistanceField(bitmapText);
    }
  }
  updateRenderable(bitmapText) {
    const graphicsRenderable = this._getGpuBitmapText(bitmapText);
    syncWithProxy(bitmapText, graphicsRenderable);
    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
    if (graphicsRenderable.context.customShader) {
      this._updateDistanceField(bitmapText);
    }
  }
  _updateContext(bitmapText, proxyGraphics) {
    const { context: context2 } = proxyGraphics;
    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
    context2.clear();
    if (bitmapFont.distanceField.type !== "none") {
      if (!context2.customShader) {
        context2.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);
      }
    }
    const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);
    const style = bitmapText._style;
    let currentY = bitmapFont.baseLineOffset;
    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);
    const padding = style.padding;
    const scale = bitmapTextLayout.scale;
    let tx = bitmapTextLayout.width;
    let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
    if (style._stroke) {
      tx += style._stroke.width / scale;
      ty += style._stroke.width / scale;
    }
    context2.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
    const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
    let fontSize = bitmapFont.fontMetrics.fontSize;
    let lineHeight = bitmapFont.lineHeight;
    if (style.lineHeight) {
      fontSize = style.fontSize / scale;
      lineHeight = style.lineHeight / scale;
    }
    let linePositionYShift = (lineHeight - fontSize) / 2;
    if (linePositionYShift - bitmapFont.baseLineOffset < 0) {
      linePositionYShift = 0;
    }
    for (let i2 = 0;i2 < bitmapTextLayout.lines.length; i2++) {
      const line = bitmapTextLayout.lines[i2];
      for (let j2 = 0;j2 < line.charPositions.length; j2++) {
        const char = line.chars[j2];
        const charData = bitmapFont.chars[char];
        if (charData?.texture) {
          const texture = charData.texture;
          context2.texture(texture, tint ? tint : "black", Math.round(line.charPositions[j2] + charData.xOffset), Math.round(currentY + charData.yOffset + linePositionYShift), texture.orig.width, texture.orig.height);
        }
      }
      currentY += lineHeight;
    }
  }
  _getGpuBitmapText(bitmapText) {
    return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);
  }
  initGpuText(bitmapText) {
    const proxyRenderable = new BitmapTextGraphics;
    bitmapText._gpuData[this._renderer.uid] = proxyRenderable;
    this._updateContext(bitmapText, proxyRenderable);
    return proxyRenderable;
  }
  _updateDistanceField(bitmapText) {
    const context2 = this._getGpuBitmapText(bitmapText).context;
    const fontFamily = bitmapText._style.fontFamily;
    const dynamicFont = Cache.get(`${fontFamily}-bitmap`);
    const { a: a2, b: b2, c: c2, d: d2 } = bitmapText.groupTransform;
    const dx = Math.sqrt(a2 * a2 + b2 * b2);
    const dy = Math.sqrt(c2 * c2 + d2 * d2);
    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
    context2.customShader.resources.localUniforms.uniforms.uDistance = distance;
  }
  destroy() {
    this._renderer = null;
  }
}
function syncWithProxy(container, proxy) {
  proxy.groupTransform = container.groupTransform;
  proxy.groupColorAlpha = container.groupColorAlpha;
  proxy.groupColor = container.groupColor;
  proxy.groupBlendMode = container.groupBlendMode;
  proxy.globalDisplayStatus = container.globalDisplayStatus;
  proxy.groupTransform = container.groupTransform;
  proxy.localDisplayStatus = container.localDisplayStatus;
  proxy.groupAlpha = container.groupAlpha;
  proxy._roundPixels = container._roundPixels;
}
var BitmapTextGraphics;
var init_BitmapTextPipe = __esm(() => {
  init_Cache();
  init_Extensions();
  init_Graphics();
  init_CanvasTextMetrics();
  init_SdfShader();
  init_BitmapFontManager();
  init_getBitmapTextLayout();
  BitmapTextGraphics = class BitmapTextGraphics extends Graphics {
    destroy() {
      if (this.context.customShader) {
        this.context.customShader.destroy();
      }
      super.destroy();
    }
  };
  BitmapTextPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "bitmapText"
  };
});

// node_modules/pixi.js/lib/scene/text-bitmap/init.mjs
var init_init11 = __esm(() => {
  init_Extensions();
  init_BitmapTextPipe();
  extensions.add(BitmapTextPipe);
});

// node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs
var BatchableHTMLText;
var init_BatchableHTMLText = __esm(() => {
  init_BatchableSprite();
  BatchableHTMLText = class BatchableHTMLText extends BatchableSprite {
    constructor(renderer) {
      super();
      this.generatingTexture = false;
      this.currentKey = "--";
      this._renderer = renderer;
      renderer.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      const text = this.renderable;
      if (text._autoResolution) {
        text.onViewUpdate();
      }
    }
    destroy() {
      const { htmlText } = this._renderer;
      htmlText.getReferenceCount(this.currentKey) === null ? htmlText.returnTexturePromise(this.texturePromise) : htmlText.decreaseReferenceCount(this.currentKey);
      this._renderer.runners.resolutionChange.remove(this);
      this.texturePromise = null;
      this._renderer = null;
    }
  };
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs
class HTMLTextPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  validateRenderable(htmlText) {
    const gpuText = this._getGpuText(htmlText);
    const newKey = htmlText.styleKey;
    if (gpuText.currentKey !== newKey) {
      return true;
    }
    return false;
  }
  addRenderable(htmlText, instructionSet) {
    const batchableHTMLText = this._getGpuText(htmlText);
    if (htmlText._didTextUpdate) {
      const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
      if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution) {
        this._updateGpuText(htmlText).catch((e2) => {
          console.error(e2);
        });
      }
      htmlText._didTextUpdate = false;
      updateTextBounds(batchableHTMLText, htmlText);
    }
    this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);
  }
  updateRenderable(htmlText) {
    const batchableHTMLText = this._getGpuText(htmlText);
    batchableHTMLText._batcher.updateElement(batchableHTMLText);
  }
  async _updateGpuText(htmlText) {
    htmlText._didTextUpdate = false;
    const batchableHTMLText = this._getGpuText(htmlText);
    if (batchableHTMLText.generatingTexture)
      return;
    const oldTexturePromise = batchableHTMLText.texturePromise;
    batchableHTMLText.texturePromise = null;
    batchableHTMLText.generatingTexture = true;
    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
    let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);
    if (oldTexturePromise) {
      texturePromise = texturePromise.finally(() => {
        this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);
        this._renderer.htmlText.returnTexturePromise(oldTexturePromise);
      });
    }
    batchableHTMLText.texturePromise = texturePromise;
    batchableHTMLText.currentKey = htmlText.styleKey;
    batchableHTMLText.texture = await texturePromise;
    const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;
    if (renderGroup) {
      renderGroup.structureDidChange = true;
    }
    batchableHTMLText.generatingTexture = false;
    updateTextBounds(batchableHTMLText, htmlText);
  }
  _getGpuText(htmlText) {
    return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);
  }
  initGpuText(htmlText) {
    const batchableHTMLText = new BatchableHTMLText(this._renderer);
    batchableHTMLText.renderable = htmlText;
    batchableHTMLText.transform = htmlText.groupTransform;
    batchableHTMLText.texture = Texture.EMPTY;
    batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
    batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
    htmlText._gpuData[this._renderer.uid] = batchableHTMLText;
    return batchableHTMLText;
  }
  destroy() {
    this._renderer = null;
  }
}
var init_HTMLTextPipe = __esm(() => {
  init_Extensions();
  init_Texture();
  init_updateTextBounds();
  init_BatchableHTMLText();
  HTMLTextPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "htmlText"
  };
});

// node_modules/pixi.js/lib/utils/browser/isSafari.mjs
function isSafari() {
  const { userAgent } = DOMAdapter.get().getNavigator();
  return /^((?!chrome|android).)*safari/i.test(userAgent);
}
var init_isSafari = __esm(() => {
  init_adapter();
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs
class HTMLTextRenderData {
  constructor() {
    this.svgRoot = document.createElementNS(nssvg, "svg");
    this.foreignObject = document.createElementNS(nssvg, "foreignObject");
    this.domElement = document.createElementNS(nsxhtml, "div");
    this.styleElement = document.createElementNS(nsxhtml, "style");
    const { foreignObject, svgRoot, styleElement, domElement } = this;
    foreignObject.setAttribute("width", "10000");
    foreignObject.setAttribute("height", "10000");
    foreignObject.style.overflow = "hidden";
    svgRoot.appendChild(foreignObject);
    foreignObject.appendChild(styleElement);
    foreignObject.appendChild(domElement);
    this.image = DOMAdapter.get().createImage();
  }
  destroy() {
    this.svgRoot.remove();
    this.foreignObject.remove();
    this.styleElement.remove();
    this.domElement.remove();
    this.image.src = "";
    this.image.remove();
    this.svgRoot = null;
    this.foreignObject = null;
    this.styleElement = null;
    this.domElement = null;
    this.image = null;
    this.canvasAndContext = null;
  }
}
var nssvg = "http://www.w3.org/2000/svg", nsxhtml = "http://www.w3.org/1999/xhtml";
var init_HTMLTextRenderData = __esm(() => {
  init_adapter();
});

// node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs
function extractFontFamilies(text, style) {
  const fontFamily = style.fontFamily;
  const fontFamilies = [];
  const dedupe = {};
  const regex = /font-family:([^;"\s]+)/g;
  const matches = text.match(regex);
  function addFontFamily(fontFamily2) {
    if (!dedupe[fontFamily2]) {
      fontFamilies.push(fontFamily2);
      dedupe[fontFamily2] = true;
    }
  }
  if (Array.isArray(fontFamily)) {
    for (let i2 = 0;i2 < fontFamily.length; i2++) {
      addFontFamily(fontFamily[i2]);
    }
  } else {
    addFontFamily(fontFamily);
  }
  if (matches) {
    matches.forEach((match) => {
      const fontFamily2 = match.split(":")[1].trim();
      addFontFamily(fontFamily2);
    });
  }
  for (const i2 in style.tagStyles) {
    const fontFamily2 = style.tagStyles[i2].fontFamily;
    addFontFamily(fontFamily2);
  }
  return fontFamilies;
}
var init_extractFontFamilies = () => {};

// node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs
async function loadFontAsBase64(url) {
  const response = await DOMAdapter.get().fetch(url);
  const blob = await response.blob();
  const reader = new FileReader;
  const dataSrc = await new Promise((resolve, reject) => {
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
  return dataSrc;
}
var init_loadFontAsBase64 = __esm(() => {
  init_adapter();
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs
async function loadFontCSS(style, url) {
  const dataSrc = await loadFontAsBase64(url);
  return `@font-face {
        font-family: "${style.fontFamily}";
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
        src: url('${dataSrc}');
    }`;
}
var init_loadFontCSS = __esm(() => {
  init_loadFontAsBase64();
});

// node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs
async function getFontCss(fontFamilies) {
  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily) => {
    if (!FontStylePromiseCache.has(fontFamily)) {
      const { entries } = Cache.get(`${fontFamily}-and-url`);
      const promises = [];
      entries.forEach((entry) => {
        const url = entry.url;
        const faces = entry.faces;
        const out2 = faces.map((face) => ({ weight: face.weight, style: face.style }));
        promises.push(...out2.map((style) => loadFontCSS({
          fontWeight: style.weight,
          fontStyle: style.style,
          fontFamily
        }, url)));
      });
      FontStylePromiseCache.set(fontFamily, Promise.all(promises).then((css) => css.join(`
`)));
    }
    return FontStylePromiseCache.get(fontFamily);
  });
  return (await Promise.all(fontPromises)).join(`
`);
}
var FontStylePromiseCache;
var init_getFontCss = __esm(() => {
  init_Cache();
  init_loadFontCSS();
  FontStylePromiseCache = /* @__PURE__ */ new Map;
});

// node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs
function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
  const { domElement, styleElement, svgRoot } = htmlTextData;
  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
  styleElement.textContent = fontCSS;
  const { width, height } = htmlTextData.image;
  svgRoot.setAttribute("width", width.toString());
  svgRoot.setAttribute("height", height.toString());
  return new XMLSerializer().serializeToString(svgRoot);
}
var init_getSVGUrl = () => {};

// node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
function getTemporaryCanvasFromImage(image, resolution) {
  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(image.width, image.height, resolution);
  const { context: context2 } = canvasAndContext;
  context2.clearRect(0, 0, image.width, image.height);
  context2.drawImage(image, 0, 0);
  return canvasAndContext;
}
var init_getTemporaryCanvasFromImage = __esm(() => {
  init_CanvasPool();
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs
function loadSVGImage(image, url, delay) {
  return new Promise(async (resolve) => {
    if (delay) {
      await new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    image.onload = () => {
      resolve();
    };
    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
    image.crossOrigin = "anonymous";
  });
}
var init_loadSVGImage = () => {};

// node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs
function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData));
  const { domElement, styleElement, svgRoot } = htmlTextRenderData;
  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
  if (fontStyleCSS) {
    styleElement.textContent = fontStyleCSS;
  }
  document.body.appendChild(svgRoot);
  const contentBounds = domElement.getBoundingClientRect();
  svgRoot.remove();
  const doublePadding = style.padding * 2;
  return {
    width: contentBounds.width - doublePadding,
    height: contentBounds.height - doublePadding
  };
}
var tempHTMLTextRenderData;
var init_measureHtmlText = __esm(() => {
  init_HTMLTextRenderData();
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs
class HTMLTextSystem {
  constructor(renderer) {
    this._activeTextures = {};
    this._renderer = renderer;
    this._createCanvas = renderer.type === RendererType.WEBGPU;
  }
  getTexture(options) {
    return this.getTexturePromise(options);
  }
  getManagedTexture(text) {
    const textKey = text.styleKey;
    if (this._activeTextures[textKey]) {
      this._increaseReferenceCount(textKey);
      return this._activeTextures[textKey].promise;
    }
    const promise2 = this._buildTexturePromise(text).then((texture) => {
      this._activeTextures[textKey].texture = texture;
      return texture;
    });
    this._activeTextures[textKey] = {
      texture: null,
      promise: promise2,
      usageCount: 1
    };
    return promise2;
  }
  getReferenceCount(textKey) {
    return this._activeTextures[textKey]?.usageCount ?? null;
  }
  _increaseReferenceCount(textKey) {
    this._activeTextures[textKey].usageCount++;
  }
  decreaseReferenceCount(textKey) {
    const activeTexture = this._activeTextures[textKey];
    if (!activeTexture)
      return;
    activeTexture.usageCount--;
    if (activeTexture.usageCount === 0) {
      if (activeTexture.texture) {
        this._cleanUp(activeTexture.texture);
      } else {
        activeTexture.promise.then((texture) => {
          activeTexture.texture = texture;
          this._cleanUp(activeTexture.texture);
        }).catch(() => {
          warn("HTMLTextSystem: Failed to clean texture");
        });
      }
      this._activeTextures[textKey] = null;
    }
  }
  getTexturePromise(options) {
    return this._buildTexturePromise(options);
  }
  async _buildTexturePromise(options) {
    const { text, style, resolution, textureStyle } = options;
    const htmlTextData = BigPool.get(HTMLTextRenderData);
    const fontFamilies = extractFontFamilies(text, style);
    const fontCSS = await getFontCss(fontFamilies);
    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
    const image = htmlTextData.image;
    const uvSafeOffset = 2;
    image.width = (width | 0) + uvSafeOffset;
    image.height = (height | 0) + uvSafeOffset;
    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
    const resource = image;
    let canvasAndContext;
    if (this._createCanvas) {
      canvasAndContext = getTemporaryCanvasFromImage(image, resolution);
    }
    const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource, image.width - uvSafeOffset, image.height - uvSafeOffset, resolution);
    if (textureStyle)
      texture.source.style = textureStyle;
    if (this._createCanvas) {
      this._renderer.texture.initSource(texture.source);
      CanvasPool.returnCanvasAndContext(canvasAndContext);
    }
    BigPool.return(htmlTextData);
    return texture;
  }
  returnTexturePromise(texturePromise) {
    texturePromise.then((texture) => {
      this._cleanUp(texture);
    }).catch(() => {
      warn("HTMLTextSystem: Failed to clean texture");
    });
  }
  _cleanUp(texture) {
    TexturePool.returnTexture(texture, true);
    texture.source.resource = null;
    texture.source.uploadMethodId = "unknown";
  }
  destroy() {
    this._renderer = null;
    for (const key in this._activeTextures) {
      if (this._activeTextures[key])
        this.returnTexturePromise(this._activeTextures[key].promise);
    }
    this._activeTextures = null;
  }
}
var init_HTMLTextSystem = __esm(() => {
  init_Extensions();
  init_CanvasPool();
  init_TexturePool();
  init_types2();
  init_isSafari();
  init_warn();
  init_PoolGroup();
  init_getPo2TextureFromSource();
  init_HTMLTextRenderData();
  init_extractFontFamilies();
  init_getFontCss();
  init_getSVGUrl();
  init_getTemporaryCanvasFromImage();
  init_loadSVGImage();
  init_measureHtmlText();
  HTMLTextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "htmlText"
  };
});

// node_modules/pixi.js/lib/scene/text-html/init.mjs
var init_init12 = __esm(() => {
  init_Extensions();
  init_HTMLTextPipe();
  init_HTMLTextSystem();
  extensions.add(HTMLTextSystem);
  extensions.add(HTMLTextPipe);
});

// node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
var _MeshGeometry, MeshGeometry;
var init_MeshGeometry = __esm(() => {
  init_Buffer();
  init_const4();
  init_Geometry();
  init_deprecation();
  _MeshGeometry = class _MeshGeometry2 extends Geometry {
    constructor(...args) {
      let options = args[0] ?? {};
      if (options instanceof Float32Array) {
        deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
        options = {
          positions: options,
          uvs: args[1],
          indices: args[2]
        };
      }
      options = { ..._MeshGeometry2.defaultOptions, ...options };
      const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      let uvs = options.uvs;
      if (!uvs) {
        if (options.positions) {
          uvs = new Float32Array(positions.length);
        } else {
          uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        }
      }
      const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
      const shrinkToFit = options.shrinkBuffersToFit;
      const positionBuffer = new Buffer({
        data: positions,
        label: "attribute-mesh-positions",
        shrinkToFit,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      const uvBuffer = new Buffer({
        data: uvs,
        label: "attribute-mesh-uvs",
        shrinkToFit,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      const indexBuffer = new Buffer({
        data: indices,
        label: "index-mesh-buffer",
        shrinkToFit,
        usage: BufferUsage.INDEX | BufferUsage.COPY_DST
      });
      super({
        attributes: {
          aPosition: {
            buffer: positionBuffer,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          },
          aUV: {
            buffer: uvBuffer,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer,
        topology: options.topology
      });
      this.batchMode = "auto";
    }
    get positions() {
      return this.attributes.aPosition.buffer.data;
    }
    set positions(value) {
      this.attributes.aPosition.buffer.data = value;
    }
    get uvs() {
      return this.attributes.aUV.buffer.data;
    }
    set uvs(value) {
      this.attributes.aUV.buffer.data = value;
    }
    get indices() {
      return this.indexBuffer.data;
    }
    set indices(value) {
      this.indexBuffer.data = value;
    }
  };
  _MeshGeometry.defaultOptions = {
    topology: "triangle-list",
    shrinkBuffersToFit: false
  };
  MeshGeometry = _MeshGeometry;
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
var localUniformBit, localUniformBitGroup2, localUniformBitGl;
var init_localUniformBit = __esm(() => {
  localUniformBit = {
    name: "local-uniform-bit",
    vertex: {
      header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    }
  };
  localUniformBitGroup2 = {
    ...localUniformBit,
    vertex: {
      ...localUniformBit.vertex,
      header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
    }
  };
  localUniformBitGl = {
    name: "local-uniform-bit",
    vertex: {
      header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
      main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
      end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    }
  };
});

// node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
var tilingBit, tilingBitGl;
var init_tilingBit = __esm(() => {
  tilingBit = {
    name: "tiling-bit",
    vertex: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
    },
    fragment: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
    }
  };
  tilingBitGl = {
    name: "tiling-bit",
    vertex: {
      header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,
      main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
    },
    fragment: {
      header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
      main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `
    }
  };
});

// node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
var gpuProgram2, glProgram2, TilingSpriteShader;
var init_TilingSpriteShader = __esm(() => {
  init_Matrix();
  init_compileHighShaderToProgram();
  init_localUniformBit();
  init_roundPixelsBit();
  init_Shader();
  init_UniformGroup();
  init_Texture();
  init_tilingBit();
  TilingSpriteShader = class TilingSpriteShader extends Shader {
    constructor() {
      gpuProgram2 ?? (gpuProgram2 = compileHighShaderGpuProgram({
        name: "tiling-sprite-shader",
        bits: [
          localUniformBit,
          tilingBit,
          roundPixelsBit
        ]
      }));
      glProgram2 ?? (glProgram2 = compileHighShaderGlProgram({
        name: "tiling-sprite-shader",
        bits: [
          localUniformBitGl,
          tilingBitGl,
          roundPixelsBitGl
        ]
      }));
      const tilingUniforms = new UniformGroup({
        uMapCoord: { value: new Matrix, type: "mat3x3<f32>" },
        uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
        uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
        uTextureTransform: { value: new Matrix, type: "mat3x3<f32>" },
        uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
      });
      super({
        glProgram: glProgram2,
        gpuProgram: gpuProgram2,
        resources: {
          localUniforms: new UniformGroup({
            uTransformMatrix: { value: new Matrix, type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          }),
          tilingUniforms,
          uTexture: Texture.EMPTY.source,
          uSampler: Texture.EMPTY.source.style
        }
      });
    }
    updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
      const tilingUniforms = this.resources.tilingUniforms;
      const textureWidth = texture.width;
      const textureHeight = texture.height;
      const textureMatrix = texture.textureMatrix;
      const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
      uTextureTransform.set(matrix.a * textureWidth / width, matrix.b * textureWidth / height, matrix.c * textureHeight / width, matrix.d * textureHeight / height, matrix.tx / width, matrix.ty / height);
      uTextureTransform.invert();
      tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
      tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
      tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
      tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
      tilingUniforms.uniforms.uSizeAnchor[0] = width;
      tilingUniforms.uniforms.uSizeAnchor[1] = height;
      tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
      tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
      if (texture) {
        this.resources.uTexture = texture.source;
        this.resources.uSampler = texture.source.style;
      }
    }
  };
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
var QuadGeometry;
var init_QuadGeometry = __esm(() => {
  init_MeshGeometry();
  QuadGeometry = class QuadGeometry extends MeshGeometry {
    constructor() {
      super({
        positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        indices: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
    }
  };
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs
function setPositions(tilingSprite, positions) {
  const anchorX = tilingSprite.anchor.x;
  const anchorY = tilingSprite.anchor.y;
  positions[0] = -anchorX * tilingSprite.width;
  positions[1] = -anchorY * tilingSprite.height;
  positions[2] = (1 - anchorX) * tilingSprite.width;
  positions[3] = -anchorY * tilingSprite.height;
  positions[4] = (1 - anchorX) * tilingSprite.width;
  positions[5] = (1 - anchorY) * tilingSprite.height;
  positions[6] = -anchorX * tilingSprite.width;
  positions[7] = (1 - anchorY) * tilingSprite.height;
}
var init_setPositions = () => {};

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs
function applyMatrix(array, stride, offset, matrix) {
  let index = 0;
  const size = array.length / (stride || 2);
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  offset *= stride;
  while (index < size) {
    const x2 = array[offset];
    const y2 = array[offset + 1];
    array[offset] = a2 * x2 + c2 * y2 + tx;
    array[offset + 1] = b2 * x2 + d2 * y2 + ty;
    offset += stride;
    index++;
  }
}
var init_applyMatrix = () => {};

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs
function setUvs(tilingSprite, uvs) {
  const texture = tilingSprite.texture;
  const width = texture.frame.width;
  const height = texture.frame.height;
  let anchorX = 0;
  let anchorY = 0;
  if (tilingSprite.applyAnchorToTexture) {
    anchorX = tilingSprite.anchor.x;
    anchorY = tilingSprite.anchor.y;
  }
  uvs[0] = uvs[6] = -anchorX;
  uvs[2] = uvs[4] = 1 - anchorX;
  uvs[1] = uvs[3] = -anchorY;
  uvs[5] = uvs[7] = 1 - anchorY;
  const textureMatrix = Matrix.shared;
  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
  textureMatrix.tx /= tilingSprite.width;
  textureMatrix.ty /= tilingSprite.height;
  textureMatrix.invert();
  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
  applyMatrix(uvs, 2, 0, textureMatrix);
}
var init_setUvs = __esm(() => {
  init_Matrix();
  init_applyMatrix();
});

// node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
class TilingSpriteGpuData {
  constructor() {
    this.canBatch = true;
    this.geometry = new MeshGeometry({
      indices: sharedQuad.indices.slice(),
      positions: sharedQuad.positions.slice(),
      uvs: sharedQuad.uvs.slice()
    });
  }
  destroy() {
    this.geometry.destroy();
    this.shader?.destroy();
  }
}

class TilingSpritePipe {
  constructor(renderer) {
    this._state = State.default2d;
    this._renderer = renderer;
  }
  validateRenderable(renderable) {
    const tilingSpriteData = this._getTilingSpriteData(renderable);
    const couldBatch = tilingSpriteData.canBatch;
    this._updateCanBatch(renderable);
    const canBatch = tilingSpriteData.canBatch;
    if (canBatch && canBatch === couldBatch) {
      const { batchableMesh } = tilingSpriteData;
      return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);
    }
    return couldBatch !== canBatch;
  }
  addRenderable(tilingSprite, instructionSet) {
    const batcher = this._renderer.renderPipes.batch;
    this._updateCanBatch(tilingSprite);
    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
    const { geometry, canBatch } = tilingSpriteData;
    if (canBatch) {
      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh);
      const batchableMesh = tilingSpriteData.batchableMesh;
      if (tilingSprite.didViewUpdate) {
        this._updateBatchableMesh(tilingSprite);
        batchableMesh.geometry = geometry;
        batchableMesh.renderable = tilingSprite;
        batchableMesh.transform = tilingSprite.groupTransform;
        batchableMesh.setTexture(tilingSprite._texture);
      }
      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
      batcher.addToBatch(batchableMesh, instructionSet);
    } else {
      batcher.break(instructionSet);
      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader);
      this.updateRenderable(tilingSprite);
      instructionSet.add(tilingSprite);
    }
  }
  execute(tilingSprite) {
    const { shader } = this._getTilingSpriteData(tilingSprite);
    shader.groups[0] = this._renderer.globalUniforms.bindGroup;
    const localUniforms = shader.resources.localUniforms.uniforms;
    localUniforms.uTransformMatrix = tilingSprite.groupTransform;
    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
    color32BitToUniform(tilingSprite.groupColorAlpha, localUniforms.uColor, 0);
    this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
    this._renderer.encoder.draw({
      geometry: sharedQuad,
      shader,
      state: this._state
    });
  }
  updateRenderable(tilingSprite) {
    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
    const { canBatch } = tilingSpriteData;
    if (canBatch) {
      const { batchableMesh } = tilingSpriteData;
      if (tilingSprite.didViewUpdate)
        this._updateBatchableMesh(tilingSprite);
      batchableMesh._batcher.updateElement(batchableMesh);
    } else if (tilingSprite.didViewUpdate) {
      const { shader } = tilingSpriteData;
      shader.updateUniforms(tilingSprite.width, tilingSprite.height, tilingSprite._tileTransform.matrix, tilingSprite.anchor.x, tilingSprite.anchor.y, tilingSprite.texture);
    }
  }
  _getTilingSpriteData(renderable) {
    return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);
  }
  _initTilingSpriteData(tilingSprite) {
    const gpuData = new TilingSpriteGpuData;
    gpuData.renderable = tilingSprite;
    tilingSprite._gpuData[this._renderer.uid] = gpuData;
    return gpuData;
  }
  _updateBatchableMesh(tilingSprite) {
    const renderableData = this._getTilingSpriteData(tilingSprite);
    const { geometry } = renderableData;
    const style = tilingSprite.texture.source.style;
    if (style.addressMode !== "repeat") {
      style.addressMode = "repeat";
      style.update();
    }
    setUvs(tilingSprite, geometry.uvs);
    setPositions(tilingSprite, geometry.positions);
  }
  destroy() {
    this._renderer = null;
  }
  _updateCanBatch(tilingSprite) {
    const renderableData = this._getTilingSpriteData(tilingSprite);
    const texture = tilingSprite.texture;
    let _nonPowOf2wrapping = true;
    if (this._renderer.type === RendererType.WEBGL) {
      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
    }
    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
    return renderableData.canBatch;
  }
}
var sharedQuad;
var init_TilingSpritePipe = __esm(() => {
  init_Extensions();
  init_getAdjustedBlendModeBlend();
  init_State();
  init_types2();
  init_colorToUniform();
  init_BatchableMesh();
  init_MeshGeometry();
  init_TilingSpriteShader();
  init_QuadGeometry();
  init_setPositions();
  init_setUvs();
  sharedQuad = new QuadGeometry;
  TilingSpritePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "tilingSprite"
  };
});

// node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs
var init_init13 = __esm(() => {
  init_Extensions();
  init_TilingSpritePipe();
  extensions.add(TilingSpritePipe);
});

// node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs
var _PlaneGeometry, PlaneGeometry;
var init_PlaneGeometry = __esm(() => {
  init_deprecation();
  init_MeshGeometry();
  _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry {
    constructor(...args) {
      super({});
      let options = args[0] ?? {};
      if (typeof options === "number") {
        deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
        options = {
          width: options,
          height: args[1],
          verticesX: args[2],
          verticesY: args[3]
        };
      }
      this.build(options);
    }
    build(options) {
      options = { ..._PlaneGeometry2.defaultOptions, ...options };
      this.verticesX = this.verticesX ?? options.verticesX;
      this.verticesY = this.verticesY ?? options.verticesY;
      this.width = this.width ?? options.width;
      this.height = this.height ?? options.height;
      const total = this.verticesX * this.verticesY;
      const verts = [];
      const uvs = [];
      const indices = [];
      const verticesX = this.verticesX - 1;
      const verticesY = this.verticesY - 1;
      const sizeX = this.width / verticesX;
      const sizeY = this.height / verticesY;
      for (let i2 = 0;i2 < total; i2++) {
        const x2 = i2 % this.verticesX;
        const y2 = i2 / this.verticesX | 0;
        verts.push(x2 * sizeX, y2 * sizeY);
        uvs.push(x2 / verticesX, y2 / verticesY);
      }
      const totalSub = verticesX * verticesY;
      for (let i2 = 0;i2 < totalSub; i2++) {
        const xpos = i2 % verticesX;
        const ypos = i2 / verticesX | 0;
        const value = ypos * this.verticesX + xpos;
        const value2 = ypos * this.verticesX + xpos + 1;
        const value3 = (ypos + 1) * this.verticesX + xpos;
        const value4 = (ypos + 1) * this.verticesX + xpos + 1;
        indices.push(value, value2, value3, value2, value4, value3);
      }
      this.buffers[0].data = new Float32Array(verts);
      this.buffers[1].data = new Float32Array(uvs);
      this.indexBuffer.data = new Uint32Array(indices);
      this.buffers[0].update();
      this.buffers[1].update();
      this.indexBuffer.update();
    }
  };
  _PlaneGeometry.defaultOptions = {
    width: 100,
    height: 100,
    verticesX: 10,
    verticesY: 10
  };
  PlaneGeometry = _PlaneGeometry;
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
var _NineSliceGeometry, NineSliceGeometry;
var init_NineSliceGeometry = __esm(() => {
  init_PlaneGeometry();
  _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry {
    constructor(options = {}) {
      options = { ..._NineSliceGeometry2.defaultOptions, ...options };
      super({
        width: options.width,
        height: options.height,
        verticesX: 4,
        verticesY: 4
      });
      this.update(options);
    }
    update(options) {
      this.width = options.width ?? this.width;
      this.height = options.height ?? this.height;
      this._originalWidth = options.originalWidth ?? this._originalWidth;
      this._originalHeight = options.originalHeight ?? this._originalHeight;
      this._leftWidth = options.leftWidth ?? this._leftWidth;
      this._rightWidth = options.rightWidth ?? this._rightWidth;
      this._topHeight = options.topHeight ?? this._topHeight;
      this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
      this._anchorX = options.anchor?.x;
      this._anchorY = options.anchor?.y;
      this.updateUvs();
      this.updatePositions();
    }
    updatePositions() {
      const p2 = this.positions;
      const {
        width,
        height,
        _leftWidth,
        _rightWidth,
        _topHeight,
        _bottomHeight,
        _anchorX,
        _anchorY
      } = this;
      const w2 = _leftWidth + _rightWidth;
      const scaleW = width > w2 ? 1 : width / w2;
      const h2 = _topHeight + _bottomHeight;
      const scaleH = height > h2 ? 1 : height / h2;
      const scale = Math.min(scaleW, scaleH);
      const anchorOffsetX = _anchorX * width;
      const anchorOffsetY = _anchorY * height;
      p2[0] = p2[8] = p2[16] = p2[24] = -anchorOffsetX;
      p2[2] = p2[10] = p2[18] = p2[26] = _leftWidth * scale - anchorOffsetX;
      p2[4] = p2[12] = p2[20] = p2[28] = width - _rightWidth * scale - anchorOffsetX;
      p2[6] = p2[14] = p2[22] = p2[30] = width - anchorOffsetX;
      p2[1] = p2[3] = p2[5] = p2[7] = -anchorOffsetY;
      p2[9] = p2[11] = p2[13] = p2[15] = _topHeight * scale - anchorOffsetY;
      p2[17] = p2[19] = p2[21] = p2[23] = height - _bottomHeight * scale - anchorOffsetY;
      p2[25] = p2[27] = p2[29] = p2[31] = height - anchorOffsetY;
      this.getBuffer("aPosition").update();
    }
    updateUvs() {
      const uvs = this.uvs;
      uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
      uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
      uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
      uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
      const _uvw = 1 / this._originalWidth;
      const _uvh = 1 / this._originalHeight;
      uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
      uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
      uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
      uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
      this.getBuffer("aUV").update();
    }
  };
  _NineSliceGeometry.defaultOptions = {
    width: 100,
    height: 100,
    leftWidth: 10,
    topHeight: 10,
    rightWidth: 10,
    bottomHeight: 10,
    originalWidth: 100,
    originalHeight: 100
  };
  NineSliceGeometry = _NineSliceGeometry;
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
class NineSliceSpritePipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  addRenderable(sprite, instructionSet) {
    const gpuSprite = this._getGpuSprite(sprite);
    if (sprite.didViewUpdate)
      this._updateBatchableSprite(sprite, gpuSprite);
    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
  }
  updateRenderable(sprite) {
    const gpuSprite = this._getGpuSprite(sprite);
    if (sprite.didViewUpdate)
      this._updateBatchableSprite(sprite, gpuSprite);
    gpuSprite._batcher.updateElement(gpuSprite);
  }
  validateRenderable(sprite) {
    const gpuSprite = this._getGpuSprite(sprite);
    return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, sprite._texture);
  }
  _updateBatchableSprite(sprite, batchableSprite) {
    batchableSprite.geometry.update(sprite);
    batchableSprite.setTexture(sprite._texture);
  }
  _getGpuSprite(sprite) {
    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
  }
  _initGPUSprite(sprite) {
    const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData;
    const batchableMesh = gpuData;
    batchableMesh.renderable = sprite;
    batchableMesh.transform = sprite.groupTransform;
    batchableMesh.texture = sprite._texture;
    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
    if (!sprite.didViewUpdate) {
      this._updateBatchableSprite(sprite, batchableMesh);
    }
    return gpuData;
  }
  destroy() {
    this._renderer = null;
  }
}
var NineSliceSpriteGpuData;
var init_NineSliceSpritePipe = __esm(() => {
  init_Extensions();
  init_BatchableMesh();
  init_NineSliceGeometry();
  NineSliceSpriteGpuData = class NineSliceSpriteGpuData extends BatchableMesh {
    constructor() {
      super();
      this.geometry = new NineSliceGeometry;
    }
    destroy() {
      this.geometry.destroy();
    }
  };
  NineSliceSpritePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "nineSliceSprite"
  };
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs
var init_init14 = __esm(() => {
  init_Extensions();
  init_NineSliceSpritePipe();
  extensions.add(NineSliceSpritePipe);
});

// node_modules/pixi.js/lib/filters/FilterPipe.mjs
class FilterPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  push(filterEffect, container, instructionSet) {
    const renderPipes = this._renderer.renderPipes;
    renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "filter",
      canBundle: false,
      action: "pushFilter",
      container,
      filterEffect
    });
  }
  pop(_filterEffect, _container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "filter",
      action: "popFilter",
      canBundle: false
    });
  }
  execute(instruction) {
    if (instruction.action === "pushFilter") {
      this._renderer.filter.push(instruction);
    } else if (instruction.action === "popFilter") {
      this._renderer.filter.pop();
    }
  }
  destroy() {
    this._renderer = null;
  }
}
var init_FilterPipe = __esm(() => {
  init_Extensions();
  FilterPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "filter"
  };
});

// node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
function getGlobalRenderableBounds(renderables, bounds) {
  bounds.clear();
  const actualMatrix = bounds.matrix;
  for (let i2 = 0;i2 < renderables.length; i2++) {
    const renderable = renderables[i2];
    if (renderable.globalDisplayStatus < 7) {
      continue;
    }
    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
    if (renderGroup?.isCachedAsTexture) {
      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);
    } else if (renderGroup?._parentCacheAsTextureRenderGroup) {
      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);
    } else {
      bounds.matrix = renderable.worldTransform;
    }
    bounds.addBounds(renderable.bounds);
  }
  bounds.matrix = actualMatrix;
  return bounds;
}
var tempProjectionMatrix;
var init_getRenderableBounds = __esm(() => {
  init_Matrix();
  tempProjectionMatrix = new Matrix;
});

// node_modules/pixi.js/lib/filters/FilterSystem.mjs
class FilterData {
  constructor() {
    this.skip = false;
    this.inputTexture = null;
    this.backTexture = null;
    this.filters = null;
    this.bounds = new Bounds;
    this.container = null;
    this.blendRequired = false;
    this.outputRenderSurface = null;
    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };
  }
}

class FilterSystem {
  constructor(renderer) {
    this._filterStackIndex = 0;
    this._filterStack = [];
    this._filterGlobalUniforms = new UniformGroup({
      uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
      uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
      uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
      uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
      uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
      uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
    });
    this._globalFilterBindGroup = new BindGroup({});
    this.renderer = renderer;
  }
  get activeBackTexture() {
    return this._activeFilterData?.backTexture;
  }
  push(instruction) {
    const renderer = this.renderer;
    const filters = instruction.filterEffect.filters;
    const filterData = this._pushFilterData();
    filterData.skip = false;
    filterData.filters = filters;
    filterData.container = instruction.container;
    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;
    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
    const rootResolution = colorTextureSource.resolution;
    const rootAntialias = colorTextureSource.antialias;
    if (filters.length === 0) {
      filterData.skip = true;
      return;
    }
    const bounds = filterData.bounds;
    this._calculateFilterArea(instruction, bounds);
    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);
    if (filterData.skip) {
      return;
    }
    const previousFilterData = this._getPreviousFilterData();
    const globalResolution = this._findFilterResolution(rootResolution);
    let offsetX = 0;
    let offsetY = 0;
    if (previousFilterData) {
      offsetX = previousFilterData.bounds.minX;
      offsetY = previousFilterData.bounds.minY;
    }
    this._calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, colorTextureSource.width, colorTextureSource.height);
    this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);
  }
  generateFilteredTexture({ texture, filters }) {
    const filterData = this._pushFilterData();
    this._activeFilterData = filterData;
    filterData.skip = false;
    filterData.filters = filters;
    const colorTextureSource = texture.source;
    const rootResolution = colorTextureSource.resolution;
    const rootAntialias = colorTextureSource.antialias;
    if (filters.length === 0) {
      filterData.skip = true;
      return texture;
    }
    const bounds = filterData.bounds;
    bounds.addRect(texture.frame);
    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);
    if (filterData.skip) {
      return texture;
    }
    const globalResolution = rootResolution;
    const offsetX = 0;
    const offsetY = 0;
    this._calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, colorTextureSource.width, colorTextureSource.height);
    filterData.outputRenderSurface = TexturePool.getOptimalTexture(bounds.width, bounds.height, filterData.resolution, filterData.antialias);
    filterData.backTexture = Texture.EMPTY;
    filterData.inputTexture = texture;
    const renderer = this.renderer;
    renderer.renderTarget.finishRenderPass();
    this._applyFiltersToTexture(filterData, true);
    const outputTexture = filterData.outputRenderSurface;
    outputTexture.source.alphaMode = "premultiplied-alpha";
    return outputTexture;
  }
  pop() {
    const renderer = this.renderer;
    const filterData = this._popFilterData();
    if (filterData.skip) {
      return;
    }
    renderer.globalUniforms.pop();
    renderer.renderTarget.finishRenderPass();
    this._activeFilterData = filterData;
    this._applyFiltersToTexture(filterData, false);
    if (filterData.blendRequired) {
      TexturePool.returnTexture(filterData.backTexture);
    }
    TexturePool.returnTexture(filterData.inputTexture);
  }
  getBackTexture(lastRenderSurface, bounds, previousBounds) {
    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
    const backTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, backgroundResolution, false);
    let x2 = bounds.minX;
    let y2 = bounds.minY;
    if (previousBounds) {
      x2 -= previousBounds.minX;
      y2 -= previousBounds.minY;
    }
    x2 = Math.floor(x2 * backgroundResolution);
    y2 = Math.floor(y2 * backgroundResolution);
    const width = Math.ceil(bounds.width * backgroundResolution);
    const height = Math.ceil(bounds.height * backgroundResolution);
    this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, { x: x2, y: y2 }, { width, height }, { x: 0, y: 0 });
    return backTexture;
  }
  applyFilter(filter, input, output, clear) {
    const renderer = this.renderer;
    const filterData = this._activeFilterData;
    const outputRenderSurface = filterData.outputRenderSurface;
    const isFinalTarget = outputRenderSurface === output;
    const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
    const resolution = this._findFilterResolution(rootResolution);
    let offsetX = 0;
    let offsetY = 0;
    if (isFinalTarget) {
      const offset = this._findPreviousFilterOffset();
      offsetX = offset.x;
      offsetY = offset.y;
    }
    this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);
    this._setupBindGroupsAndRender(filter, input, renderer);
  }
  calculateSpriteMatrix(outputMatrix, sprite) {
    const data = this._activeFilterData;
    const mappedMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);
    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;
    if (renderGroup && renderGroup.cacheToLocalTransform) {
      worldTransform.prepend(renderGroup.cacheToLocalTransform);
    }
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / sprite.texture.orig.width, 1 / sprite.texture.orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  }
  destroy() {}
  _setupBindGroupsAndRender(filter, input, renderer) {
    if (renderer.renderPipes.uniformBatch) {
      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
      this._globalFilterBindGroup.setResource(batchUniforms, 0);
    } else {
      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
    }
    this._globalFilterBindGroup.setResource(input.source, 1);
    this._globalFilterBindGroup.setResource(input.source.style, 2);
    filter.groups[0] = this._globalFilterBindGroup;
    renderer.encoder.draw({
      geometry: quadGeometry,
      shader: filter,
      state: filter._state,
      topology: "triangle-list"
    });
    if (renderer.type === RendererType.WEBGL) {
      renderer.renderTarget.finishRenderPass();
    }
  }
  _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {
    filterData.backTexture = Texture.EMPTY;
    filterData.inputTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, filterData.resolution, filterData.antialias);
    if (filterData.blendRequired) {
      renderer.renderTarget.finishRenderPass();
      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);
      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);
    }
    renderer.renderTarget.bind(filterData.inputTexture, true);
    renderer.globalUniforms.push({
      offset: bounds
    });
  }
  _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {
    const globalFrame = filterData.globalFrame;
    globalFrame.x = offsetX * globalResolution;
    globalFrame.y = offsetY * globalResolution;
    globalFrame.width = sourceWidth * globalResolution;
    globalFrame.height = sourceHeight * globalResolution;
  }
  _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {
    const uniforms = this._filterGlobalUniforms.uniforms;
    const outputFrame = uniforms.uOutputFrame;
    const inputSize = uniforms.uInputSize;
    const inputPixel = uniforms.uInputPixel;
    const inputClamp = uniforms.uInputClamp;
    const globalFrame = uniforms.uGlobalFrame;
    const outputTexture = uniforms.uOutputTexture;
    if (isFinalTarget) {
      outputFrame[0] = filterData.bounds.minX - offsetX;
      outputFrame[1] = filterData.bounds.minY - offsetY;
    } else {
      outputFrame[0] = 0;
      outputFrame[1] = 0;
    }
    outputFrame[2] = input.frame.width;
    outputFrame[3] = input.frame.height;
    inputSize[0] = input.source.width;
    inputSize[1] = input.source.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = input.source.pixelWidth;
    inputPixel[1] = input.source.pixelHeight;
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
    globalFrame[0] = offsetX * resolution;
    globalFrame[1] = offsetY * resolution;
    globalFrame[2] = rootTexture.source.width * resolution;
    globalFrame[3] = rootTexture.source.height * resolution;
    if (output instanceof Texture)
      output.source.resource = null;
    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
    this.renderer.renderTarget.bind(output, !!clear);
    if (output instanceof Texture) {
      outputTexture[0] = output.frame.width;
      outputTexture[1] = output.frame.height;
    } else {
      outputTexture[0] = renderTarget.width;
      outputTexture[1] = renderTarget.height;
    }
    outputTexture[2] = renderTarget.isRoot ? -1 : 1;
    this._filterGlobalUniforms.update();
  }
  _findFilterResolution(rootResolution) {
    let currentIndex = this._filterStackIndex - 1;
    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
      --currentIndex;
    }
    return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;
  }
  _findPreviousFilterOffset() {
    let offsetX = 0;
    let offsetY = 0;
    let lastIndex = this._filterStackIndex;
    while (lastIndex > 0) {
      lastIndex--;
      const prevFilterData = this._filterStack[lastIndex];
      if (!prevFilterData.skip) {
        offsetX = prevFilterData.bounds.minX;
        offsetY = prevFilterData.bounds.minY;
        break;
      }
    }
    return { x: offsetX, y: offsetY };
  }
  _calculateFilterArea(instruction, bounds) {
    if (instruction.renderables) {
      getGlobalRenderableBounds(instruction.renderables, bounds);
    } else if (instruction.filterEffect.filterArea) {
      bounds.clear();
      bounds.addRect(instruction.filterEffect.filterArea);
      bounds.applyMatrix(instruction.container.worldTransform);
    } else {
      instruction.container.getFastGlobalBounds(true, bounds);
    }
    if (instruction.container) {
      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;
      const filterFrameTransform = renderGroup.cacheToLocalTransform;
      if (filterFrameTransform) {
        bounds.applyMatrix(filterFrameTransform);
      }
    }
  }
  _applyFiltersToTexture(filterData, clear) {
    const inputTexture = filterData.inputTexture;
    const bounds = filterData.bounds;
    const filters = filterData.filters;
    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);
    if (filters.length === 1) {
      filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);
    } else {
      let flip = filterData.inputTexture;
      const tempTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, flip.source._resolution, false);
      let flop = tempTexture;
      let i2 = 0;
      for (i2 = 0;i2 < filters.length - 1; ++i2) {
        const filter = filters[i2];
        filter.apply(this, flip, flop, true);
        const t2 = flip;
        flip = flop;
        flop = t2;
      }
      filters[i2].apply(this, flip, filterData.outputRenderSurface, clear);
      TexturePool.returnTexture(tempTexture);
    }
  }
  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {
    const renderer = this.renderer;
    const bounds = filterData.bounds;
    const filters = filterData.filters;
    let resolution = Infinity;
    let padding = 0;
    let antialias = true;
    let blendRequired = false;
    let enabled = false;
    let clipToViewport = true;
    for (let i2 = 0;i2 < filters.length; i2++) {
      const filter = filters[i2];
      resolution = Math.min(resolution, filter.resolution === "inherit" ? rootResolution : filter.resolution);
      padding += filter.padding;
      if (filter.antialias === "off") {
        antialias = false;
      } else if (filter.antialias === "inherit") {
        antialias && (antialias = rootAntialias);
      }
      if (!filter.clipToViewport) {
        clipToViewport = false;
      }
      const isCompatible = !!(filter.compatibleRenderers & renderer.type);
      if (!isCompatible) {
        enabled = false;
        break;
      }
      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
        warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
        enabled = false;
        break;
      }
      enabled = filter.enabled || enabled;
      blendRequired || (blendRequired = filter.blendRequired);
    }
    if (!enabled) {
      filterData.skip = true;
      return;
    }
    if (clipToViewport) {
      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);
    }
    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);
    if (!bounds.isPositive) {
      filterData.skip = true;
      return;
    }
    filterData.antialias = antialias;
    filterData.resolution = resolution;
    filterData.blendRequired = blendRequired;
  }
  _popFilterData() {
    this._filterStackIndex--;
    return this._filterStack[this._filterStackIndex];
  }
  _getPreviousFilterData() {
    let previousFilterData;
    let index = this._filterStackIndex - 1;
    while (index > 0) {
      index--;
      previousFilterData = this._filterStack[index];
      if (!previousFilterData.skip) {
        break;
      }
    }
    return previousFilterData;
  }
  _pushFilterData() {
    let filterData = this._filterStack[this._filterStackIndex];
    if (!filterData) {
      filterData = this._filterStack[this._filterStackIndex] = new FilterData;
    }
    this._filterStackIndex++;
    return filterData;
  }
}
var quadGeometry;
var init_FilterSystem = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_BindGroup();
  init_Geometry();
  init_UniformGroup();
  init_Texture();
  init_TexturePool();
  init_types2();
  init_Bounds();
  init_getRenderableBounds();
  init_warn();
  quadGeometry = new Geometry({
    attributes: {
      aPosition: {
        buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        format: "float32x2",
        stride: 2 * 4,
        offset: 0
      }
    },
    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
  });
  FilterSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "filter"
  };
});

// node_modules/pixi.js/lib/filters/init.mjs
var init_init15 = __esm(() => {
  init_Extensions();
  init_FilterPipe();
  init_FilterSystem();
  extensions.add(FilterSystem);
  extensions.add(FilterPipe);
});

// node_modules/pixi.js/lib/environment-browser/browserAll.mjs
var exports_browserAll = {};
var init_browserAll = __esm(() => {
  init_init();
  init_init2();
  init_init3();
  init_init4();
  init_init5();
  init_init6();
  init_init7();
  init_init8();
  init_init9();
  init_init10();
  init_init11();
  init_init12();
  init_init13();
  init_init14();
  init_init15();
});

// node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs
var exports_webworkerAll = {};
var init_webworkerAll = __esm(() => {
  init_init2();
  init_init5();
  init_init6();
  init_init7();
  init_init8();
  init_init9();
  init_init10();
  init_init11();
  init_init12();
  init_init13();
  init_init14();
  init_init15();
});

// node_modules/pixi.js/lib/filters/Filter.mjs
var _Filter, Filter;
var init_Filter = __esm(() => {
  init_GlProgram();
  init_GpuProgram();
  init_Shader();
  init_State();
  _Filter = class _Filter2 extends Shader {
    constructor(options) {
      options = { ..._Filter2.defaultOptions, ...options };
      super(options);
      this.enabled = true;
      this._state = State.for2d();
      this.blendMode = options.blendMode;
      this.padding = options.padding;
      if (typeof options.antialias === "boolean") {
        this.antialias = options.antialias ? "on" : "off";
      } else {
        this.antialias = options.antialias;
      }
      this.resolution = options.resolution;
      this.blendRequired = options.blendRequired;
      this.clipToViewport = options.clipToViewport;
      this.addResource("uTexture", 0, 1);
    }
    apply(filterManager, input, output, clearMode) {
      filterManager.applyFilter(this, input, output, clearMode);
    }
    get blendMode() {
      return this._state.blendMode;
    }
    set blendMode(value) {
      this._state.blendMode = value;
    }
    static from(options) {
      const { gpu, gl, ...rest } = options;
      let gpuProgram3;
      let glProgram3;
      if (gpu) {
        gpuProgram3 = GpuProgram.from(gpu);
      }
      if (gl) {
        glProgram3 = GlProgram.from(gl);
      }
      return new _Filter2({
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        ...rest
      });
    }
  };
  _Filter.defaultOptions = {
    blendMode: "normal",
    resolution: 1,
    padding: 0,
    antialias: "off",
    blendRequired: false,
    clipToViewport: true
  };
  Filter = _Filter;
});

// node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs
async function loadEnvironmentExtensions(skip) {
  if (skip)
    return;
  for (let i2 = 0;i2 < environments.length; i2++) {
    const env = environments[i2];
    if (env.value.test()) {
      await env.value.load();
      return;
    }
  }
}
var environments;
var init_autoDetectEnvironment = __esm(() => {
  init_Extensions();
  environments = [];
  extensions.handleByNamedList(ExtensionType.Environment, environments);
});

// node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (_e) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var unsafeEval;
var init_unsafeEvalSupported = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
var CLEAR;
var init_const7 = __esm(() => {
  CLEAR = /* @__PURE__ */ ((CLEAR2) => {
    CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
    CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
    CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
    CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
    CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
    CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
    CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
    CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
    return CLEAR2;
  })(CLEAR || {});
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
class SystemRunner {
  constructor(name) {
    this.items = [];
    this._name = name;
  }
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    const { name, items } = this;
    for (let i2 = 0, len = items.length;i2 < len; i2++) {
      items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    return this;
  }
  add(item) {
    if (item[this._name]) {
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  remove(item) {
    const index = this.items.indexOf(item);
    if (index !== -1) {
      this.items.splice(index, 1);
    }
    return this;
  }
  contains(item) {
    return this.items.indexOf(item) !== -1;
  }
  removeAll() {
    this.items.length = 0;
    return this;
  }
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  get empty() {
    return this.items.length === 0;
  }
  get name() {
    return this._name;
  }
}
var init_SystemRunner = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
var defaultRunners, _AbstractRenderer, AbstractRenderer;
var init_AbstractRenderer = __esm(() => {
  init_Color();
  init_autoDetectEnvironment();
  init_Container();
  init_unsafeEvalSupported();
  init_uid();
  init_deprecation();
  init_GlobalResourceRegistry();
  init_const7();
  init_SystemRunner();
  init_eventemitter3();
  defaultRunners = [
    "init",
    "destroy",
    "contextChange",
    "resolutionChange",
    "resetState",
    "renderEnd",
    "renderStart",
    "render",
    "update",
    "postrender",
    "prerender"
  ];
  _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
    constructor(config) {
      super();
      this.uid = uid("renderer");
      this.runners = /* @__PURE__ */ Object.create(null);
      this.renderPipes = /* @__PURE__ */ Object.create(null);
      this._initOptions = {};
      this._systemsHash = /* @__PURE__ */ Object.create(null);
      this.type = config.type;
      this.name = config.name;
      this.config = config;
      const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
      this._addRunners(...combinedRunners);
      this._unsafeEvalCheck();
    }
    async init(options = {}) {
      const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
      await loadEnvironmentExtensions(skip);
      this._addSystems(this.config.systems);
      this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
      for (const systemName in this._systemsHash) {
        const system = this._systemsHash[systemName];
        const defaultSystemOptions = system.constructor.defaultOptions;
        options = { ...defaultSystemOptions, ...options };
      }
      options = { ..._AbstractRenderer2.defaultOptions, ...options };
      this._roundPixels = options.roundPixels ? 1 : 0;
      for (let i2 = 0;i2 < this.runners.init.items.length; i2++) {
        await this.runners.init.items[i2].init(options);
      }
      this._initOptions = options;
    }
    render(args, deprecated) {
      let options = args;
      if (options instanceof Container) {
        options = { container: options };
        if (deprecated) {
          deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
          options.target = deprecated.renderTexture;
        }
      }
      options.target || (options.target = this.view.renderTarget);
      if (options.target === this.view.renderTarget) {
        this._lastObjectRendered = options.container;
        options.clearColor ?? (options.clearColor = this.background.colorRgba);
        options.clear ?? (options.clear = this.background.clearBeforeRender);
      }
      if (options.clearColor) {
        const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
        options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
      }
      if (!options.transform) {
        options.container.updateLocalTransform();
        options.transform = options.container.localTransform;
      }
      if (!options.container.visible) {
        return;
      }
      options.container.enableRenderGroup();
      this.runners.prerender.emit(options);
      this.runners.renderStart.emit(options);
      this.runners.render.emit(options);
      this.runners.renderEnd.emit(options);
      this.runners.postrender.emit(options);
    }
    resize(desiredScreenWidth, desiredScreenHeight, resolution) {
      const previousResolution = this.view.resolution;
      this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
      this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
      if (resolution !== undefined && resolution !== previousResolution) {
        this.runners.resolutionChange.emit(resolution);
      }
    }
    clear(options = {}) {
      const renderer = this;
      options.target || (options.target = renderer.renderTarget.renderTarget);
      options.clearColor || (options.clearColor = this.background.colorRgba);
      options.clear ?? (options.clear = CLEAR.ALL);
      const { clear, clearColor, target } = options;
      Color.shared.setValue(clearColor ?? this.background.colorRgba);
      renderer.renderTarget.clear(target, clear, Color.shared.toArray());
    }
    get resolution() {
      return this.view.resolution;
    }
    set resolution(value) {
      this.view.resolution = value;
      this.runners.resolutionChange.emit(value);
    }
    get width() {
      return this.view.texture.frame.width;
    }
    get height() {
      return this.view.texture.frame.height;
    }
    get canvas() {
      return this.view.canvas;
    }
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    get renderingToScreen() {
      const renderer = this;
      return renderer.renderTarget.renderingToScreen;
    }
    get screen() {
      return this.view.screen;
    }
    _addRunners(...runnerIds) {
      runnerIds.forEach((runnerId) => {
        this.runners[runnerId] = new SystemRunner(runnerId);
      });
    }
    _addSystems(systems) {
      let i2;
      for (i2 in systems) {
        const val = systems[i2];
        this._addSystem(val.value, val.name);
      }
    }
    _addSystem(ClassRef, name) {
      const system = new ClassRef(this);
      if (this[name]) {
        throw new Error(`Whoops! The name "${name}" is already in use`);
      }
      this[name] = system;
      this._systemsHash[name] = system;
      for (const i2 in this.runners) {
        this.runners[i2].add(system);
      }
      return this;
    }
    _addPipes(pipes, pipeAdaptors) {
      const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
        acc[adaptor.name] = adaptor.value;
        return acc;
      }, {});
      pipes.forEach((pipe) => {
        const PipeClass = pipe.value;
        const name = pipe.name;
        const Adaptor = adaptors[name];
        this.renderPipes[name] = new PipeClass(this, Adaptor ? new Adaptor : null);
        this.runners.destroy.add(this.renderPipes[name]);
      });
    }
    destroy(options = false) {
      this.runners.destroy.items.reverse();
      this.runners.destroy.emit(options);
      Object.values(this.runners).forEach((runner) => {
        runner.destroy();
      });
      if (options === true || typeof options === "object" && options.releaseGlobalResources) {
        GlobalResourceRegistry.release();
      }
      this._systemsHash = null;
      this.renderPipes = null;
    }
    generateTexture(options) {
      return this.textureGenerator.generateTexture(options);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    _unsafeEvalCheck() {
      if (!unsafeEvalSupported()) {
        throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
      }
    }
    resetState() {
      this.runners.resetState.emit();
    }
  };
  _AbstractRenderer.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: false,
    roundPixels: false
  };
  AbstractRenderer = _AbstractRenderer;
});

// node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
class GpuGraphicsAdaptor {
  constructor() {
    this._maxTextures = 0;
  }
  contextChange(renderer) {
    const localUniforms = new UniformGroup({
      uTransformMatrix: { value: new Matrix, type: "mat3x3<f32>" },
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    this._maxTextures = renderer.limits.maxBatchableTextures;
    const gpuProgram3 = compileHighShaderGpuProgram({
      name: "graphics",
      bits: [
        colorBit,
        generateTextureBatchBit(this._maxTextures),
        localUniformBitGroup2,
        roundPixelsBit
      ]
    });
    this.shader = new Shader({
      gpuProgram: gpuProgram3,
      resources: {
        localUniforms
      }
    });
  }
  execute(graphicsPipe, renderable) {
    const context2 = renderable.context;
    const shader = context2.customShader || this.shader;
    const renderer = graphicsPipe.renderer;
    const contextSystem = renderer.graphicsContext;
    const {
      batcher,
      instructions
    } = contextSystem.getContextRenderData(context2);
    const encoder = renderer.encoder;
    encoder.setGeometry(batcher.geometry, shader.gpuProgram);
    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
    const batches = instructions.instructions;
    let topology = null;
    for (let i2 = 0;i2 < instructions.instructionSize; i2++) {
      const batch = batches[i2];
      if (batch.topology !== topology) {
        topology = batch.topology;
        encoder.setPipelineFromGeometryProgramAndState(batcher.geometry, shader.gpuProgram, graphicsPipe.state, batch.topology);
      }
      shader.groups[1] = batch.bindGroup;
      if (!batch.gpuBindGroup) {
        const textureBatch = batch.textures;
        batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count, this._maxTextures);
        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, shader.gpuProgram, 1);
      }
      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
    }
  }
  destroy() {
    this.shader.destroy(true);
    this.shader = null;
  }
}
var init_GpuGraphicsAdaptor = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_getTextureBatchBindGroup();
  init_compileHighShaderToProgram();
  init_colorBit();
  init_generateTextureBatchBit();
  init_localUniformBit();
  init_roundPixelsBit();
  init_Shader();
  init_UniformGroup();
  GpuGraphicsAdaptor.extension = {
    type: [
      ExtensionType.WebGPUPipesAdaptor
    ],
    name: "graphics"
  };
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
var textureBit, textureBitGl;
var init_textureBit = __esm(() => {
  textureBit = {
    name: "texture-bit",
    vertex: {
      header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
      main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    },
    fragment: {
      header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,
      main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
    }
  };
  textureBitGl = {
    name: "texture-bit",
    vertex: {
      header: `
            uniform mat3 uTextureMatrix;
        `,
      main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    },
    fragment: {
      header: `
        uniform sampler2D uTexture;


        `,
      main: `
            outColor = texture(uTexture, vUV);
        `
    }
  };
});

// node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
class GpuMeshAdapter {
  init() {
    const gpuProgram3 = compileHighShaderGpuProgram({
      name: "mesh",
      bits: [
        localUniformBit,
        textureBit,
        roundPixelsBit
      ]
    });
    this._shader = new Shader({
      gpuProgram: gpuProgram3,
      resources: {
        uTexture: Texture.EMPTY._source,
        uSampler: Texture.EMPTY._source.style,
        textureUniforms: {
          uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix }
        }
      }
    });
  }
  execute(meshPipe, mesh) {
    const renderer = meshPipe.renderer;
    let shader = mesh._shader;
    if (!shader) {
      shader = this._shader;
      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
    } else if (!shader.gpuProgram) {
      warn("Mesh shader has no gpuProgram", mesh.shader);
      return;
    }
    const gpuProgram3 = shader.gpuProgram;
    if (gpuProgram3.autoAssignGlobalUniforms) {
      shader.groups[0] = renderer.globalUniforms.bindGroup;
    }
    if (gpuProgram3.autoAssignLocalUniforms) {
      const localUniforms = meshPipe.localUniforms;
      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
    }
    renderer.encoder.draw({
      geometry: mesh._geometry,
      shader,
      state: mesh.state
    });
  }
  destroy() {
    this._shader.destroy(true);
    this._shader = null;
  }
}
var init_GpuMeshAdapter = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_compileHighShaderToProgram();
  init_localUniformBit();
  init_roundPixelsBit();
  init_textureBit();
  init_Shader();
  init_Texture();
  init_warn();
  GpuMeshAdapter.extension = {
    type: [
      ExtensionType.WebGPUPipesAdaptor
    ],
    name: "mesh"
  };
});

// node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
class GpuBatchAdaptor {
  start(batchPipe, geometry, shader) {
    const renderer = batchPipe.renderer;
    const encoder = renderer.encoder;
    const program = shader.gpuProgram;
    this._shader = shader;
    this._geometry = geometry;
    encoder.setGeometry(geometry, program);
    tempState.blendMode = "normal";
    renderer.pipeline.getPipeline(geometry, program, tempState);
    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
    encoder.resetBindGroup(1);
    encoder.setBindGroup(0, globalUniformsBindGroup, program);
  }
  execute(batchPipe, batch) {
    const program = this._shader.gpuProgram;
    const renderer = batchPipe.renderer;
    const encoder = renderer.encoder;
    if (!batch.bindGroup) {
      const textureBatch = batch.textures;
      batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count, renderer.limits.maxBatchableTextures);
    }
    tempState.blendMode = batch.blendMode;
    const gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, program, 1);
    const pipeline = renderer.pipeline.getPipeline(this._geometry, program, tempState, batch.topology);
    batch.bindGroup._touch(renderer.textureGC.count);
    encoder.setPipeline(pipeline);
    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
  }
}
var tempState;
var init_GpuBatchAdaptor = __esm(() => {
  init_Extensions();
  init_State();
  init_getTextureBatchBindGroup();
  tempState = State.for2d();
  GpuBatchAdaptor.extension = {
    type: [
      ExtensionType.WebGPUPipesAdaptor
    ],
    name: "batch"
  };
});

// node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs
class CustomRenderPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  updateRenderable() {}
  destroyRenderable() {}
  validateRenderable() {
    return false;
  }
  addRenderable(container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add(container);
  }
  execute(container) {
    if (!container.isRenderable)
      return;
    container.render(this._renderer);
  }
  destroy() {
    this._renderer = null;
  }
}
var init_CustomRenderPipe = __esm(() => {
  init_Extensions();
  CustomRenderPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "customRender"
  };
});

// node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
function executeInstructions(renderGroup, renderer) {
  const instructionSet = renderGroup.instructionSet;
  const instructions = instructionSet.instructions;
  for (let i2 = 0;i2 < instructionSet.instructionSize; i2++) {
    const instruction = instructions[i2];
    renderer[instruction.renderPipeId].execute(instruction);
  }
}
var init_executeInstructions = () => {};

// node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs
class RenderGroupPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  addRenderGroup(renderGroup, instructionSet) {
    if (renderGroup.isCachedAsTexture) {
      this._addRenderableCacheAsTexture(renderGroup, instructionSet);
    } else {
      this._addRenderableDirect(renderGroup, instructionSet);
    }
  }
  execute(renderGroup) {
    if (!renderGroup.isRenderable)
      return;
    if (renderGroup.isCachedAsTexture) {
      this._executeCacheAsTexture(renderGroup);
    } else {
      this._executeDirect(renderGroup);
    }
  }
  destroy() {
    this._renderer = null;
  }
  _addRenderableDirect(renderGroup, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    if (renderGroup._batchableRenderGroup) {
      BigPool.return(renderGroup._batchableRenderGroup);
      renderGroup._batchableRenderGroup = null;
    }
    instructionSet.add(renderGroup);
  }
  _addRenderableCacheAsTexture(renderGroup, instructionSet) {
    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));
    batchableRenderGroup.renderable = renderGroup.root;
    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;
    batchableRenderGroup.texture = renderGroup.texture;
    batchableRenderGroup.bounds = renderGroup._textureBounds;
    instructionSet.add(renderGroup);
    this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);
    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);
    this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);
  }
  _executeCacheAsTexture(renderGroup) {
    if (renderGroup.textureNeedsUpdate) {
      renderGroup.textureNeedsUpdate = false;
      const worldTransformMatrix = tempMatrix5.identity().translate(-renderGroup._textureBounds.x, -renderGroup._textureBounds.y);
      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);
      this._renderer.globalUniforms.push({
        worldTransformMatrix,
        worldColor: 4294967295,
        offset: { x: 0, y: 0 }
      });
      executeInstructions(renderGroup, this._renderer.renderPipes);
      this._renderer.renderTarget.finishRenderPass();
      this._renderer.renderTarget.pop();
      this._renderer.globalUniforms.pop();
    }
    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);
    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();
  }
  _executeDirect(renderGroup) {
    this._renderer.globalUniforms.push({
      worldTransformMatrix: renderGroup.inverseParentTextureTransform,
      worldColor: renderGroup.worldColorAlpha
    });
    executeInstructions(renderGroup, this._renderer.renderPipes);
    this._renderer.globalUniforms.pop();
  }
}
var tempMatrix5;
var init_RenderGroupPipe = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_PoolGroup();
  init_BatchableSprite();
  init_executeInstructions();
  tempMatrix5 = new Matrix;
  RenderGroupPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "renderGroup"
  };
});

// node_modules/pixi.js/lib/scene/container/utils/clearList.mjs
function clearList(list, index) {
  index || (index = 0);
  for (let j2 = index;j2 < list.length; j2++) {
    if (list[j2]) {
      list[j2] = null;
    } else {
      break;
    }
  }
}
var init_clearList = () => {};

// node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs
function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
  updateRenderGroupTransform(renderGroup);
  const childrenToUpdate = renderGroup.childrenToUpdate;
  const updateTick = renderGroup.updateTick++;
  for (const j2 in childrenToUpdate) {
    const renderGroupDepth = Number(j2);
    const childrenAtDepth = childrenToUpdate[j2];
    const list = childrenAtDepth.list;
    const index = childrenAtDepth.index;
    for (let i2 = 0;i2 < index; i2++) {
      const child = list[i2];
      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
        updateTransformAndChildren(child, updateTick, 0);
      }
    }
    clearList(list, index);
    childrenAtDepth.index = 0;
  }
  if (updateChildRenderGroups) {
    for (let i2 = 0;i2 < renderGroup.renderGroupChildren.length; i2++) {
      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i2], updateChildRenderGroups);
    }
  }
}
function updateRenderGroupTransform(renderGroup) {
  const root = renderGroup.root;
  let worldAlpha;
  if (renderGroup.renderGroupParent) {
    const renderGroupParent = renderGroup.renderGroupParent;
    renderGroup.worldTransform.appendFrom(root.relativeGroupTransform, renderGroupParent.worldTransform);
    renderGroup.worldColor = multiplyColors(root.groupColor, renderGroupParent.worldColor);
    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
  } else {
    renderGroup.worldTransform.copyFrom(root.localTransform);
    renderGroup.worldColor = root.localColor;
    worldAlpha = root.localAlpha;
  }
  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
  renderGroup.worldAlpha = worldAlpha;
  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
  if (updateTick === container.updateTick)
    return;
  container.updateTick = updateTick;
  container.didChange = false;
  const localTransform = container.localTransform;
  container.updateLocalTransform();
  const parent = container.parent;
  if (parent && !parent.renderGroup) {
    updateFlags |= container._updateFlags;
    container.relativeGroupTransform.appendFrom(localTransform, parent.relativeGroupTransform);
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, parent, updateFlags);
    }
  } else {
    updateFlags = container._updateFlags;
    container.relativeGroupTransform.copyFrom(localTransform);
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, tempContainer, updateFlags);
    }
  }
  if (!container.renderGroup) {
    const children = container.children;
    const length = children.length;
    for (let i2 = 0;i2 < length; i2++) {
      updateTransformAndChildren(children[i2], updateTick, updateFlags);
    }
    const renderGroup = container.parentRenderGroup;
    const renderable = container;
    if (renderable.renderPipeId && !renderGroup.structureDidChange) {
      renderGroup.updateRenderable(renderable);
    }
  }
}
function updateColorBlendVisibility(container, parent, updateFlags) {
  if (updateFlags & UPDATE_COLOR) {
    container.groupColor = multiplyColors(container.localColor, parent.groupColor);
    let groupAlpha = container.localAlpha * parent.groupAlpha;
    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
    container.groupAlpha = groupAlpha;
    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
  }
  if (updateFlags & UPDATE_BLEND) {
    container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
  }
  if (updateFlags & UPDATE_VISIBLE) {
    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
  }
  container._updateFlags = 0;
}
var tempContainer, UPDATE_BLEND_COLOR_VISIBLE;
var init_updateRenderGroupTransforms = __esm(() => {
  init_Container();
  init_clearList();
  init_multiplyColors();
  tempContainer = new Container;
  UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
});

// node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
function validateRenderables(renderGroup, renderPipes) {
  const { list, index } = renderGroup.childrenRenderablesToUpdate;
  let rebuildRequired = false;
  for (let i2 = 0;i2 < index; i2++) {
    const container = list[i2];
    const renderable = container;
    const pipe = renderPipes[renderable.renderPipeId];
    rebuildRequired = pipe.validateRenderable(container);
    if (rebuildRequired) {
      break;
    }
  }
  renderGroup.structureDidChange = rebuildRequired;
  return rebuildRequired;
}
var init_validateRenderables = () => {};

// node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs
class RenderGroupSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  render({ container, transform }) {
    const parent = container.parent;
    const renderGroupParent = container.renderGroup.renderGroupParent;
    container.parent = null;
    container.renderGroup.renderGroupParent = null;
    const renderer = this._renderer;
    const originalLocalTransform = tempMatrix6;
    if (transform) {
      originalLocalTransform.copyFrom(container.renderGroup.localTransform);
      container.renderGroup.localTransform.copyFrom(transform);
    }
    const renderPipes = renderer.renderPipes;
    this._updateCachedRenderGroups(container.renderGroup, null);
    this._updateRenderGroups(container.renderGroup);
    renderer.globalUniforms.start({
      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
      worldColor: container.renderGroup.worldColorAlpha
    });
    executeInstructions(container.renderGroup, renderPipes);
    if (renderPipes.uniformBatch) {
      renderPipes.uniformBatch.renderEnd();
    }
    if (transform) {
      container.renderGroup.localTransform.copyFrom(originalLocalTransform);
    }
    container.parent = parent;
    container.renderGroup.renderGroupParent = renderGroupParent;
  }
  destroy() {
    this._renderer = null;
  }
  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {
    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;
    if (renderGroup.isCachedAsTexture) {
      if (!renderGroup.textureNeedsUpdate)
        return;
      closestCacheAsTexture = renderGroup;
    }
    for (let i2 = renderGroup.renderGroupChildren.length - 1;i2 >= 0; i2--) {
      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i2], closestCacheAsTexture);
    }
    renderGroup.invalidateMatrices();
    if (renderGroup.isCachedAsTexture) {
      if (renderGroup.textureNeedsUpdate) {
        const bounds = renderGroup.root.getLocalBounds();
        bounds.ceil();
        const lastTexture = renderGroup.texture;
        if (renderGroup.texture) {
          TexturePool.returnTexture(renderGroup.texture, true);
        }
        const renderer = this._renderer;
        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;
        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;
        const scaleMode = renderGroup.textureOptions.scaleMode ?? "linear";
        const texture = TexturePool.getOptimalTexture(bounds.width, bounds.height, resolution, antialias);
        texture._source.style = new TextureStyle({ scaleMode });
        renderGroup.texture = texture;
        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds);
        renderGroup._textureBounds.copyFrom(bounds);
        if (lastTexture !== renderGroup.texture) {
          if (renderGroup.renderGroupParent) {
            renderGroup.renderGroupParent.structureDidChange = true;
          }
        }
      }
    } else if (renderGroup.texture) {
      TexturePool.returnTexture(renderGroup.texture, true);
      renderGroup.texture = null;
    }
  }
  _updateRenderGroups(renderGroup) {
    const renderer = this._renderer;
    const renderPipes = renderer.renderPipes;
    renderGroup.runOnRender(renderer);
    renderGroup.instructionSet.renderPipes = renderPipes;
    if (!renderGroup.structureDidChange) {
      validateRenderables(renderGroup, renderPipes);
    } else {
      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
    }
    updateRenderGroupTransforms(renderGroup);
    if (renderGroup.structureDidChange) {
      renderGroup.structureDidChange = false;
      this._buildInstructions(renderGroup, renderer);
    } else {
      this._updateRenderables(renderGroup);
    }
    renderGroup.childrenRenderablesToUpdate.index = 0;
    renderer.renderPipes.batch.upload(renderGroup.instructionSet);
    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)
      return;
    for (let i2 = 0;i2 < renderGroup.renderGroupChildren.length; i2++) {
      this._updateRenderGroups(renderGroup.renderGroupChildren[i2]);
    }
  }
  _updateRenderables(renderGroup) {
    const { list, index } = renderGroup.childrenRenderablesToUpdate;
    for (let i2 = 0;i2 < index; i2++) {
      const container = list[i2];
      if (container.didViewUpdate) {
        renderGroup.updateRenderable(container);
      }
    }
    clearList(list, index);
  }
  _buildInstructions(renderGroup, rendererOrPipes) {
    const root = renderGroup.root;
    const instructionSet = renderGroup.instructionSet;
    instructionSet.reset();
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    const renderPipes = renderer.renderPipes;
    renderPipes.batch.buildStart(instructionSet);
    renderPipes.blendMode.buildStart();
    renderPipes.colorMask.buildStart();
    if (root.sortableChildren) {
      root.sortChildren();
    }
    root.collectRenderablesWithEffects(instructionSet, renderer, null);
    renderPipes.batch.buildEnd(instructionSet);
    renderPipes.blendMode.buildEnd(instructionSet);
  }
}
var tempMatrix6;
var init_RenderGroupSystem = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_TexturePool();
  init_TextureStyle();
  init_Bounds();
  init_clearList();
  init_executeInstructions();
  init_updateRenderGroupTransforms();
  init_validateRenderables();
  tempMatrix6 = new Matrix;
  RenderGroupSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "renderGroup"
  };
});

// node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
class SpritePipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  addRenderable(sprite, instructionSet) {
    const gpuSprite = this._getGpuSprite(sprite);
    if (sprite.didViewUpdate)
      this._updateBatchableSprite(sprite, gpuSprite);
    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
  }
  updateRenderable(sprite) {
    const gpuSprite = this._getGpuSprite(sprite);
    if (sprite.didViewUpdate)
      this._updateBatchableSprite(sprite, gpuSprite);
    gpuSprite._batcher.updateElement(gpuSprite);
  }
  validateRenderable(sprite) {
    const gpuSprite = this._getGpuSprite(sprite);
    return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, sprite._texture);
  }
  _updateBatchableSprite(sprite, batchableSprite) {
    batchableSprite.bounds = sprite.visualBounds;
    batchableSprite.texture = sprite._texture;
  }
  _getGpuSprite(sprite) {
    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
  }
  _initGPUSprite(sprite) {
    const batchableSprite = new BatchableSprite;
    batchableSprite.renderable = sprite;
    batchableSprite.transform = sprite.groupTransform;
    batchableSprite.texture = sprite._texture;
    batchableSprite.bounds = sprite.visualBounds;
    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
    sprite._gpuData[this._renderer.uid] = batchableSprite;
    return batchableSprite;
  }
  destroy() {
    this._renderer = null;
  }
}
var init_SpritePipe = __esm(() => {
  init_Extensions();
  init_BatchableSprite();
  SpritePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "sprite"
  };
});

// node_modules/pixi.js/lib/utils/const.mjs
var VERSION = "8.13.2";
var init_const8 = __esm(() => {
  init_eventemitter3();
});

// node_modules/pixi.js/lib/utils/global/globalHooks.mjs
class ApplicationInitHook {
  static init() {
    globalThis.__PIXI_APP_INIT__?.(this, VERSION);
  }
  static destroy() {}
}

class RendererInitHook {
  constructor(renderer) {
    this._renderer = renderer;
  }
  init() {
    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);
  }
  destroy() {
    this._renderer = null;
  }
}
var init_globalHooks = __esm(() => {
  init_Extensions();
  init_const8();
  ApplicationInitHook.extension = ExtensionType.Application;
  RendererInitHook.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "initHook",
    priority: -10
  };
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
var _BatcherPipe = class _BatcherPipe2 {
  constructor(renderer, adaptor) {
    this.state = State.for2d();
    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
    this._activeBatches = /* @__PURE__ */ Object.create(null);
    this.renderer = renderer;
    this._adaptor = adaptor;
    this._adaptor.init?.(this);
  }
  static getBatcher(name) {
    return new this._availableBatchers[name];
  }
  buildStart(instructionSet) {
    let batchers = this._batchersByInstructionSet[instructionSet.uid];
    if (!batchers) {
      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
      batchers.default || (batchers.default = new DefaultBatcher({
        maxTextures: this.renderer.limits.maxBatchableTextures
      }));
    }
    this._activeBatches = batchers;
    this._activeBatch = this._activeBatches.default;
    for (const i2 in this._activeBatches) {
      this._activeBatches[i2].begin();
    }
  }
  addToBatch(batchableObject, instructionSet) {
    if (this._activeBatch.name !== batchableObject.batcherName) {
      this._activeBatch.break(instructionSet);
      let batch = this._activeBatches[batchableObject.batcherName];
      if (!batch) {
        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe2.getBatcher(batchableObject.batcherName);
        batch.begin();
      }
      this._activeBatch = batch;
    }
    this._activeBatch.add(batchableObject);
  }
  break(instructionSet) {
    this._activeBatch.break(instructionSet);
  }
  buildEnd(instructionSet) {
    this._activeBatch.break(instructionSet);
    const batches = this._activeBatches;
    for (const i2 in batches) {
      const batch = batches[i2];
      const geometry = batch.geometry;
      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
    }
  }
  upload(instructionSet) {
    const batchers = this._batchersByInstructionSet[instructionSet.uid];
    for (const i2 in batchers) {
      const batcher = batchers[i2];
      const geometry = batcher.geometry;
      if (batcher.dirty) {
        batcher.dirty = false;
        geometry.buffers[0].update(batcher.attributeSize * 4);
      }
    }
  }
  execute(batch) {
    if (batch.action === "startBatch") {
      const batcher = batch.batcher;
      const geometry = batcher.geometry;
      const shader = batcher.shader;
      this._adaptor.start(this, geometry, shader);
    }
    this._adaptor.execute(this, batch);
  }
  destroy() {
    this.state = null;
    this.renderer = null;
    this._adaptor = null;
    for (const i2 in this._activeBatches) {
      this._activeBatches[i2].destroy();
    }
    this._activeBatches = null;
  }
}, BatcherPipe;
var init_BatcherPipe = __esm(() => {
  init_Extensions();
  init_State();
  init_DefaultBatcher();
  _BatcherPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "batch"
  };
  _BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
  BatcherPipe = _BatcherPipe;
  extensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);
  extensions.add(DefaultBatcher);
});

// node_modules/pixi.js/lib/filters/mask/mask.frag.mjs
var fragment2 = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`;
var init_mask_frag = () => {};

// node_modules/pixi.js/lib/filters/mask/mask.vert.mjs
var vertex2 = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`;
var init_mask_vert = () => {};

// node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs
var source = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
var init_mask_wgsl = () => {};

// node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
var MaskFilter;
var init_MaskFilter = __esm(() => {
  init_Matrix();
  init_GlProgram();
  init_GpuProgram();
  init_UniformGroup();
  init_TextureMatrix();
  init_Filter();
  init_mask_frag();
  init_mask_vert();
  init_mask_wgsl();
  MaskFilter = class MaskFilter extends Filter {
    constructor(options) {
      const { sprite, ...rest } = options;
      const textureMatrix = new TextureMatrix(sprite.texture);
      const filterUniforms = new UniformGroup({
        uFilterMatrix: { value: new Matrix, type: "mat3x3<f32>" },
        uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
        uAlpha: { value: 1, type: "f32" },
        uInverse: { value: options.inverse ? 1 : 0, type: "f32" }
      });
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source,
          entryPoint: "mainVertex"
        },
        fragment: {
          source,
          entryPoint: "mainFragment"
        }
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex2,
        fragment: fragment2,
        name: "mask-filter"
      });
      super({
        ...rest,
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        clipToViewport: false,
        resources: {
          filterUniforms,
          uMaskTexture: sprite.texture.source
        }
      });
      this.sprite = sprite;
      this._textureMatrix = textureMatrix;
    }
    set inverse(value) {
      this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;
    }
    get inverse() {
      return this.resources.filterUniforms.uniforms.uInverse === 1;
    }
    apply(filterManager, input, output, clearMode) {
      this._textureMatrix.texture = this.sprite.texture;
      filterManager.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord);
      this.resources.uMaskTexture = this.sprite.texture.source;
      filterManager.applyFilter(this, input, output, clearMode);
    }
  };
});

// node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
class AlphaMaskPipe {
  constructor(renderer) {
    this._activeMaskStage = [];
    this._renderer = renderer;
  }
  push(mask, maskedContainer, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "alphaMask",
      action: "pushMaskBegin",
      mask,
      inverse: maskedContainer._maskOptions.inverse,
      canBundle: false,
      maskedContainer
    });
    mask.inverse = maskedContainer._maskOptions.inverse;
    if (mask.renderMaskToTexture) {
      const maskContainer = mask.mask;
      maskContainer.includeInBuild = true;
      maskContainer.collectRenderables(instructionSet, renderer, null);
      maskContainer.includeInBuild = false;
    }
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "alphaMask",
      action: "pushMaskEnd",
      mask,
      maskedContainer,
      inverse: maskedContainer._maskOptions.inverse,
      canBundle: false
    });
  }
  pop(mask, _maskedContainer, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "alphaMask",
      action: "popMaskEnd",
      mask,
      inverse: _maskedContainer._maskOptions.inverse,
      canBundle: false
    });
  }
  execute(instruction) {
    const renderer = this._renderer;
    const renderMask = instruction.mask.renderMaskToTexture;
    if (instruction.action === "pushMaskBegin") {
      const filterEffect = BigPool.get(AlphaMaskEffect);
      filterEffect.inverse = instruction.inverse;
      if (renderMask) {
        instruction.mask.mask.measurable = true;
        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
        instruction.mask.mask.measurable = false;
        bounds.ceil();
        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
        const filterTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, colorTextureSource._resolution, colorTextureSource.antialias);
        renderer.renderTarget.push(filterTexture, true);
        renderer.globalUniforms.push({
          offset: bounds,
          worldColor: 4294967295
        });
        const sprite = filterEffect.sprite;
        sprite.texture = filterTexture;
        sprite.worldTransform.tx = bounds.minX;
        sprite.worldTransform.ty = bounds.minY;
        this._activeMaskStage.push({
          filterEffect,
          maskedContainer: instruction.maskedContainer,
          filterTexture
        });
      } else {
        filterEffect.sprite = instruction.mask.mask;
        this._activeMaskStage.push({
          filterEffect,
          maskedContainer: instruction.maskedContainer
        });
      }
    } else if (instruction.action === "pushMaskEnd") {
      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
      if (renderMask) {
        if (renderer.type === RendererType.WEBGL) {
          renderer.renderTarget.finishRenderPass();
        }
        renderer.renderTarget.pop();
        renderer.globalUniforms.pop();
      }
      renderer.filter.push({
        renderPipeId: "filter",
        action: "pushFilter",
        container: maskData.maskedContainer,
        filterEffect: maskData.filterEffect,
        canBundle: false
      });
    } else if (instruction.action === "popMaskEnd") {
      renderer.filter.pop();
      const maskData = this._activeMaskStage.pop();
      if (renderMask) {
        TexturePool.returnTexture(maskData.filterTexture);
      }
      BigPool.return(maskData.filterEffect);
    }
  }
  destroy() {
    this._renderer = null;
    this._activeMaskStage = null;
  }
}
var tempBounds3, AlphaMaskEffect;
var init_AlphaMaskPipe = __esm(() => {
  init_Extensions();
  init_FilterEffect();
  init_MaskFilter();
  init_Bounds();
  init_getGlobalBounds();
  init_Sprite();
  init_PoolGroup();
  init_Texture();
  init_TexturePool();
  init_types2();
  tempBounds3 = new Bounds;
  AlphaMaskEffect = class AlphaMaskEffect extends FilterEffect {
    constructor() {
      super();
      this.filters = [new MaskFilter({
        sprite: new Sprite(Texture.EMPTY),
        inverse: false,
        resolution: "inherit",
        antialias: "inherit"
      })];
    }
    get sprite() {
      return this.filters[0].sprite;
    }
    set sprite(value) {
      this.filters[0].sprite = value;
    }
    get inverse() {
      return this.filters[0].inverse;
    }
    set inverse(value) {
      this.filters[0].inverse = value;
    }
  };
  AlphaMaskPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "alphaMask"
  };
});

// node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
class ColorMaskPipe {
  constructor(renderer) {
    this._colorStack = [];
    this._colorStackIndex = 0;
    this._currentColor = 0;
    this._renderer = renderer;
  }
  buildStart() {
    this._colorStack[0] = 15;
    this._colorStackIndex = 1;
    this._currentColor = 15;
  }
  push(mask, _container, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    const colorStack = this._colorStack;
    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
    const currentColor = this._colorStack[this._colorStackIndex];
    if (currentColor !== this._currentColor) {
      this._currentColor = currentColor;
      instructionSet.add({
        renderPipeId: "colorMask",
        colorMask: currentColor,
        canBundle: false
      });
    }
    this._colorStackIndex++;
  }
  pop(_mask, _container, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    const colorStack = this._colorStack;
    this._colorStackIndex--;
    const currentColor = colorStack[this._colorStackIndex - 1];
    if (currentColor !== this._currentColor) {
      this._currentColor = currentColor;
      instructionSet.add({
        renderPipeId: "colorMask",
        colorMask: currentColor,
        canBundle: false
      });
    }
  }
  execute(instruction) {
    const renderer = this._renderer;
    renderer.colorMask.setMask(instruction.colorMask);
  }
  destroy() {
    this._renderer = null;
    this._colorStack = null;
  }
}
var init_ColorMaskPipe = __esm(() => {
  init_Extensions();
  ColorMaskPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "colorMask"
  };
});

// node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
class StencilMaskPipe {
  constructor(renderer) {
    this._maskStackHash = {};
    this._maskHash = /* @__PURE__ */ new WeakMap;
    this._renderer = renderer;
  }
  push(mask, _container, instructionSet) {
    var _a;
    const effect = mask;
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "pushMaskBegin",
      mask,
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
    const maskContainer = effect.mask;
    maskContainer.includeInBuild = true;
    if (!this._maskHash.has(effect)) {
      this._maskHash.set(effect, {
        instructionsStart: 0,
        instructionsLength: 0
      });
    }
    const maskData = this._maskHash.get(effect);
    maskData.instructionsStart = instructionSet.instructionSize;
    maskContainer.collectRenderables(instructionSet, renderer, null);
    maskContainer.includeInBuild = false;
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "pushMaskEnd",
      mask,
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
    maskData.instructionsLength = instructionsLength;
    const renderTargetUid = renderer.renderTarget.renderTarget.uid;
    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
  }
  pop(mask, _container, instructionSet) {
    const effect = mask;
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "popMaskBegin",
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
    const maskData = this._maskHash.get(mask);
    for (let i2 = 0;i2 < maskData.instructionsLength; i2++) {
      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
    }
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "popMaskEnd",
      canBundle: false
    });
  }
  execute(instruction) {
    var _a;
    const renderer = this._renderer;
    const renderTargetUid = renderer.renderTarget.renderTarget.uid;
    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
    if (instruction.action === "pushMaskBegin") {
      renderer.renderTarget.ensureDepthStencil();
      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
      maskStackIndex++;
      renderer.colorMask.setMask(0);
    } else if (instruction.action === "pushMaskEnd") {
      if (instruction.inverse) {
        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
      } else {
        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
      }
      renderer.colorMask.setMask(15);
    } else if (instruction.action === "popMaskBegin") {
      renderer.colorMask.setMask(0);
      if (maskStackIndex !== 0) {
        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
      } else {
        renderer.renderTarget.clear(null, CLEAR.STENCIL);
        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
      }
      maskStackIndex--;
    } else if (instruction.action === "popMaskEnd") {
      if (instruction.inverse) {
        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
      } else {
        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
      }
      renderer.colorMask.setMask(15);
    }
    this._maskStackHash[renderTargetUid] = maskStackIndex;
  }
  destroy() {
    this._renderer = null;
    this._maskStackHash = null;
    this._maskHash = null;
  }
}
var init_StencilMaskPipe = __esm(() => {
  init_Extensions();
  init_const7();
  init_const3();
  StencilMaskPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "stencilMask"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
var _BackgroundSystem = class _BackgroundSystem2 {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new Color(0);
    this.color = this._backgroundColor;
    this.alpha = 1;
  }
  init(options) {
    options = { ..._BackgroundSystem2.defaultOptions, ...options };
    this.clearBeforeRender = options.clearBeforeRender;
    this.color = options.background || options.backgroundColor || this._backgroundColor;
    this.alpha = options.backgroundAlpha;
    this._backgroundColor.setAlpha(options.backgroundAlpha);
  }
  get color() {
    return this._backgroundColor;
  }
  set color(value) {
    const incoming = Color.shared.setValue(value);
    if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {
      warn("Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application.");
    }
    this._backgroundColor.setValue(value);
  }
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  get colorRgba() {
    return this._backgroundColor.toArray();
  }
  destroy() {}
}, BackgroundSystem;
var init_BackgroundSystem = __esm(() => {
  init_Color();
  init_Extensions();
  init_warn();
  _BackgroundSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "background",
    priority: 0
  };
  _BackgroundSystem.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: true
  };
  BackgroundSystem = _BackgroundSystem;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
class BlendModePipe {
  constructor(renderer) {
    this._blendModeStack = [];
    this._isAdvanced = false;
    this._filterHash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    this._renderer.runners.prerender.add(this);
  }
  prerender() {
    this._activeBlendMode = "normal";
    this._isAdvanced = false;
  }
  pushBlendMode(renderable, blendMode, instructionSet) {
    this._blendModeStack.push(blendMode);
    this.setBlendMode(renderable, blendMode, instructionSet);
  }
  popBlendMode(instructionSet) {
    this._blendModeStack.pop();
    const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? "normal";
    this.setBlendMode(null, blendMode, instructionSet);
  }
  setBlendMode(renderable, blendMode, instructionSet) {
    const isRenderGroup = renderable instanceof RenderGroup;
    if (this._activeBlendMode === blendMode) {
      if (this._isAdvanced && renderable && !isRenderGroup) {
        this._renderableList?.push(renderable);
      }
      return;
    }
    if (this._isAdvanced)
      this._endAdvancedBlendMode(instructionSet);
    this._activeBlendMode = blendMode;
    if (!renderable)
      return;
    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
    if (this._isAdvanced)
      this._beginAdvancedBlendMode(renderable, instructionSet);
  }
  _beginAdvancedBlendMode(renderable, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    const blendMode = this._activeBlendMode;
    if (!BLEND_MODE_FILTERS[blendMode]) {
      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
      return;
    }
    const filterEffect = this._ensureFilterEffect(blendMode);
    const isRenderGroup = renderable instanceof RenderGroup;
    const instruction = {
      renderPipeId: "filter",
      action: "pushFilter",
      filterEffect,
      renderables: isRenderGroup ? null : [renderable],
      container: isRenderGroup ? renderable.root : null,
      canBundle: false
    };
    this._renderableList = instruction.renderables;
    instructionSet.add(instruction);
  }
  _ensureFilterEffect(blendMode) {
    let filterEffect = this._filterHash[blendMode];
    if (!filterEffect) {
      filterEffect = this._filterHash[blendMode] = new FilterEffect;
      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]];
    }
    return filterEffect;
  }
  _endAdvancedBlendMode(instructionSet) {
    this._isAdvanced = false;
    this._renderableList = null;
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "filter",
      action: "popFilter",
      canBundle: false
    });
  }
  buildStart() {
    this._isAdvanced = false;
  }
  buildEnd(instructionSet) {
    if (!this._isAdvanced)
      return;
    this._endAdvancedBlendMode(instructionSet);
  }
  destroy() {
    this._renderer = null;
    this._renderableList = null;
    for (const i2 in this._filterHash) {
      this._filterHash[i2].destroy();
    }
    this._filterHash = null;
  }
}
var BLEND_MODE_FILTERS;
var init_BlendModePipe = __esm(() => {
  init_Extensions();
  init_FilterEffect();
  init_RenderGroup();
  init_warn();
  BLEND_MODE_FILTERS = {};
  extensions.handle(ExtensionType.BlendMode, (value) => {
    if (!value.name) {
      throw new Error("BlendMode extension must have a name property");
    }
    BLEND_MODE_FILTERS[value.name] = value.ref;
  }, (value) => {
    delete BLEND_MODE_FILTERS[value.name];
  });
  BlendModePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "blendMode"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
var imageTypes, _ExtractSystem = class _ExtractSystem2 {
  constructor(renderer) {
    this._renderer = renderer;
  }
  _normalizeOptions(options, defaults = {}) {
    if (options instanceof Container || options instanceof Texture) {
      return {
        target: options,
        ...defaults
      };
    }
    return {
      ...defaults,
      ...options
    };
  }
  async image(options) {
    const image = DOMAdapter.get().createImage();
    image.src = await this.base64(options);
    return image;
  }
  async base64(options) {
    options = this._normalizeOptions(options, _ExtractSystem2.defaultImageOptions);
    const { format, quality } = options;
    const canvas = this.canvas(options);
    if (canvas.toBlob !== undefined) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader;
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, imageTypes[format], quality);
      });
    }
    if (canvas.toDataURL !== undefined) {
      return canvas.toDataURL(imageTypes[format], quality);
    }
    if (canvas.convertToBlob !== undefined) {
      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader;
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  canvas(options) {
    options = this._normalizeOptions(options);
    const target = options.target;
    const renderer = this._renderer;
    if (target instanceof Texture) {
      return renderer.texture.generateCanvas(target);
    }
    const texture = renderer.textureGenerator.generateTexture(options);
    const canvas = renderer.texture.generateCanvas(texture);
    texture.destroy(true);
    return canvas;
  }
  pixels(options) {
    options = this._normalizeOptions(options);
    const target = options.target;
    const renderer = this._renderer;
    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
    const pixelInfo = renderer.texture.getPixels(texture);
    if (target instanceof Container) {
      texture.destroy(true);
    }
    return pixelInfo;
  }
  texture(options) {
    options = this._normalizeOptions(options);
    if (options.target instanceof Texture)
      return options.target;
    return this._renderer.textureGenerator.generateTexture(options);
  }
  download(options) {
    options = this._normalizeOptions(options);
    const canvas = this.canvas(options);
    const link = document.createElement("a");
    link.download = options.filename ?? "image.png";
    link.href = canvas.toDataURL("image/png");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
  log(options) {
    const width = options.width ?? 200;
    options = this._normalizeOptions(options);
    const canvas = this.canvas(options);
    const base64 = canvas.toDataURL();
    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
    const style = [
      "font-size: 1px;",
      `padding: ${width}px ${300}px;`,
      `background: url(${base64}) no-repeat;`,
      "background-size: contain;"
    ].join(" ");
    console.log("%c ", style);
  }
  destroy() {
    this._renderer = null;
  }
}, ExtractSystem;
var init_ExtractSystem = __esm(() => {
  init_adapter();
  init_Extensions();
  init_Container();
  init_Texture();
  imageTypes = {
    png: "image/png",
    jpg: "image/jpeg",
    webp: "image/webp"
  };
  _ExtractSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "extract"
  };
  _ExtractSystem.defaultImageOptions = {
    format: "png",
    quality: 1
  };
  ExtractSystem = _ExtractSystem;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
var RenderTexture;
var init_RenderTexture = __esm(() => {
  init_TextureSource();
  init_Texture();
  RenderTexture = class RenderTexture extends Texture {
    static create(options) {
      return new RenderTexture({
        source: new TextureSource(options)
      });
    }
    resize(width, height, resolution) {
      this.source.resize(width, height, resolution);
      return this;
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
class GenerateTextureSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  generateTexture(options) {
    if (options instanceof Container) {
      options = {
        target: options,
        frame: undefined,
        textureSourceOptions: {},
        resolution: undefined
      };
    }
    const resolution = options.resolution || this._renderer.resolution;
    const antialias = options.antialias || this._renderer.view.antialias;
    const container = options.target;
    let clearColor = options.clearColor;
    if (clearColor) {
      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
    } else {
      clearColor = noColor;
    }
    const region = options.frame?.copyTo(tempRect5) || getLocalBounds(container, tempBounds4).rectangle;
    region.width = Math.max(region.width, 1 / resolution) | 0;
    region.height = Math.max(region.height, 1 / resolution) | 0;
    const target = RenderTexture.create({
      ...options.textureSourceOptions,
      width: region.width,
      height: region.height,
      resolution,
      antialias
    });
    const transform = Matrix.shared.translate(-region.x, -region.y);
    this._renderer.render({
      container,
      transform,
      target,
      clearColor
    });
    target.source.updateMipmaps();
    return target;
  }
  destroy() {
    this._renderer = null;
  }
}
var tempRect5, tempBounds4, noColor;
var init_GenerateTextureSystem = __esm(() => {
  init_Color();
  init_Extensions();
  init_Matrix();
  init_Rectangle();
  init_Bounds();
  init_getLocalBounds();
  init_Container();
  init_RenderTexture();
  tempRect5 = new Rectangle;
  tempBounds4 = new Bounds;
  noColor = [0, 0, 0, 0];
  GenerateTextureSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "textureGenerator"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
class GlobalUniformSystem {
  constructor(renderer) {
    this._stackIndex = 0;
    this._globalUniformDataStack = [];
    this._uniformsPool = [];
    this._activeUniforms = [];
    this._bindGroupPool = [];
    this._activeBindGroups = [];
    this._renderer = renderer;
  }
  reset() {
    this._stackIndex = 0;
    for (let i2 = 0;i2 < this._activeUniforms.length; i2++) {
      this._uniformsPool.push(this._activeUniforms[i2]);
    }
    for (let i2 = 0;i2 < this._activeBindGroups.length; i2++) {
      this._bindGroupPool.push(this._activeBindGroups[i2]);
    }
    this._activeUniforms.length = 0;
    this._activeBindGroups.length = 0;
  }
  start(options) {
    this.reset();
    this.push(options);
  }
  bind({
    size,
    projectionMatrix,
    worldTransformMatrix,
    worldColor,
    offset
  }) {
    const renderTarget = this._renderer.renderTarget.renderTarget;
    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
      projectionData: renderTarget,
      worldTransformMatrix: new Matrix,
      worldColor: 4294967295,
      offset: new Point
    };
    const globalUniformData = {
      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
      resolution: size || renderTarget.size,
      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
      worldColor: worldColor || currentGlobalUniformData.worldColor,
      offset: offset || currentGlobalUniformData.offset,
      bindGroup: null
    };
    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
    this._activeUniforms.push(uniformGroup);
    const uniforms = uniformGroup.uniforms;
    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
    uniforms.uResolution = globalUniformData.resolution;
    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
    color32BitToUniform(globalUniformData.worldColor, uniforms.uWorldColorAlpha, 0);
    uniformGroup.update();
    let bindGroup;
    if (this._renderer.renderPipes.uniformBatch) {
      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
    } else {
      bindGroup = this._bindGroupPool.pop() || new BindGroup;
      this._activeBindGroups.push(bindGroup);
      bindGroup.setResource(uniformGroup, 0);
    }
    globalUniformData.bindGroup = bindGroup;
    this._currentGlobalUniformData = globalUniformData;
  }
  push(options) {
    this.bind(options);
    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
  }
  pop() {
    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
    if (this._renderer.type === RendererType.WEBGL) {
      this._currentGlobalUniformData.bindGroup.resources[0].update();
    }
  }
  get bindGroup() {
    return this._currentGlobalUniformData.bindGroup;
  }
  get globalUniformData() {
    return this._currentGlobalUniformData;
  }
  get uniformGroup() {
    return this._currentGlobalUniformData.bindGroup.resources[0];
  }
  _createUniforms() {
    const globalUniforms = new UniformGroup({
      uProjectionMatrix: { value: new Matrix, type: "mat3x3<f32>" },
      uWorldTransformMatrix: { value: new Matrix, type: "mat3x3<f32>" },
      uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
      uResolution: { value: [0, 0], type: "vec2<f32>" }
    }, {
      isStatic: true
    });
    return globalUniforms;
  }
  destroy() {
    this._renderer = null;
    this._globalUniformDataStack.length = 0;
    this._uniformsPool.length = 0;
    this._activeUniforms.length = 0;
    this._bindGroupPool.length = 0;
    this._activeBindGroups.length = 0;
    this._currentGlobalUniformData = null;
  }
}
var init_GlobalUniformSystem = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_Point();
  init_colorToUniform();
  init_BindGroup();
  init_types2();
  init_UniformGroup();
  GlobalUniformSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "globalUniforms"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs
class SchedulerSystem {
  constructor() {
    this._tasks = [];
    this._offset = 0;
  }
  init() {
    Ticker.system.add(this._update, this);
  }
  repeat(func, duration, useOffset = true) {
    const id = uid2++;
    let offset = 0;
    if (useOffset) {
      this._offset += 1000;
      offset = this._offset;
    }
    this._tasks.push({
      func,
      duration,
      start: performance.now(),
      offset,
      last: performance.now(),
      repeat: true,
      id
    });
    return id;
  }
  cancel(id) {
    for (let i2 = 0;i2 < this._tasks.length; i2++) {
      if (this._tasks[i2].id === id) {
        this._tasks.splice(i2, 1);
        return;
      }
    }
  }
  _update() {
    const now = performance.now();
    for (let i2 = 0;i2 < this._tasks.length; i2++) {
      const task = this._tasks[i2];
      if (now - task.offset - task.last >= task.duration) {
        const elapsed = now - task.start;
        task.func(elapsed);
        task.last = now;
      }
    }
  }
  destroy() {
    Ticker.system.remove(this._update, this);
    this._tasks.length = 0;
  }
}
var uid2 = 1;
var init_SchedulerSystem = __esm(() => {
  init_Extensions();
  init_Ticker();
  SchedulerSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "scheduler",
    priority: 0
  };
});

// node_modules/pixi.js/lib/utils/sayHello.mjs
function sayHello(type) {
  if (saidHello) {
    return;
  }
  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    const args = [
      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
      "background: #E72264; padding:5px 0;",
      "background: #6CA2EA; padding:5px 0;",
      "background: #B5D33D; padding:5px 0;",
      "background: #FED23F; padding:5px 0;",
      "color: #FFFFFF; background: #E72264; padding:5px 0;",
      "color: #E72264; background: #FFFFFF; padding:5px 0;"
    ];
    globalThis.console.log(...args);
  } else if (globalThis.console) {
    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
  }
  saidHello = true;
}
var saidHello = false;
var init_sayHello = __esm(() => {
  init_adapter();
  init_const8();
});

// node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
class HelloSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  init(options) {
    if (options.hello) {
      let name = this._renderer.name;
      if (this._renderer.type === RendererType.WEBGL) {
        name += ` ${this._renderer.context.webGLVersion}`;
      }
      sayHello(name);
    }
  }
}
var init_HelloSystem = __esm(() => {
  init_Extensions();
  init_sayHello();
  init_types2();
  HelloSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "hello",
    priority: -2
  };
  HelloSystem.defaultOptions = {
    hello: false
  };
});

// node_modules/pixi.js/lib/utils/data/clean.mjs
function cleanHash(hash) {
  let clean = false;
  for (const i2 in hash) {
    if (hash[i2] == undefined) {
      clean = true;
      break;
    }
  }
  if (!clean)
    return hash;
  const cleanHash2 = /* @__PURE__ */ Object.create(null);
  for (const i2 in hash) {
    const value = hash[i2];
    if (value) {
      cleanHash2[i2] = value;
    }
  }
  return cleanHash2;
}
function cleanArray(arr) {
  let offset = 0;
  for (let i2 = 0;i2 < arr.length; i2++) {
    if (arr[i2] == undefined) {
      offset++;
    } else {
      arr[i2 - offset] = arr[i2];
    }
  }
  arr.length -= offset;
  return arr;
}
var init_clean = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs
var renderableGCTick = 0, _RenderableGCSystem = class _RenderableGCSystem2 {
  constructor(renderer) {
    this._managedRenderables = [];
    this._managedHashes = [];
    this._managedArrays = [];
    this._renderer = renderer;
  }
  init(options) {
    options = { ..._RenderableGCSystem2.defaultOptions, ...options };
    this.maxUnusedTime = options.renderableGCMaxUnusedTime;
    this._frequency = options.renderableGCFrequency;
    this.enabled = options.renderableGCActive;
  }
  get enabled() {
    return !!this._handler;
  }
  set enabled(value) {
    if (this.enabled === value)
      return;
    if (value) {
      this._handler = this._renderer.scheduler.repeat(() => this.run(), this._frequency, false);
      this._hashHandler = this._renderer.scheduler.repeat(() => {
        for (const hash of this._managedHashes) {
          hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);
        }
      }, this._frequency);
      this._arrayHandler = this._renderer.scheduler.repeat(() => {
        for (const array of this._managedArrays) {
          cleanArray(array.context[array.hash]);
        }
      }, this._frequency);
    } else {
      this._renderer.scheduler.cancel(this._handler);
      this._renderer.scheduler.cancel(this._hashHandler);
      this._renderer.scheduler.cancel(this._arrayHandler);
    }
  }
  addManagedHash(context2, hash) {
    this._managedHashes.push({ context: context2, hash });
  }
  addManagedArray(context2, hash) {
    this._managedArrays.push({ context: context2, hash });
  }
  prerender({
    container
  }) {
    this._now = performance.now();
    container.renderGroup.gcTick = renderableGCTick++;
    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);
  }
  addRenderable(renderable) {
    if (!this.enabled)
      return;
    if (renderable._lastUsed === -1) {
      this._managedRenderables.push(renderable);
      renderable.once("destroyed", this._removeRenderable, this);
    }
    renderable._lastUsed = this._now;
  }
  run() {
    const now = this._now;
    const managedRenderables = this._managedRenderables;
    const renderPipes = this._renderer.renderPipes;
    let offset = 0;
    for (let i2 = 0;i2 < managedRenderables.length; i2++) {
      const renderable = managedRenderables[i2];
      if (renderable === null) {
        offset++;
        continue;
      }
      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
      const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;
      if ((renderGroup?.gcTick ?? 0) === currentTick) {
        renderable._lastUsed = now;
      }
      if (now - renderable._lastUsed > this.maxUnusedTime) {
        if (!renderable.destroyed) {
          const rp = renderPipes;
          if (renderGroup)
            renderGroup.structureDidChange = true;
          rp[renderable.renderPipeId].destroyRenderable(renderable);
        }
        renderable._lastUsed = -1;
        offset++;
        renderable.off("destroyed", this._removeRenderable, this);
      } else {
        managedRenderables[i2 - offset] = renderable;
      }
    }
    managedRenderables.length -= offset;
  }
  destroy() {
    this.enabled = false;
    this._renderer = null;
    this._managedRenderables.length = 0;
    this._managedHashes.length = 0;
    this._managedArrays.length = 0;
  }
  _removeRenderable(renderable) {
    const index = this._managedRenderables.indexOf(renderable);
    if (index >= 0) {
      renderable.off("destroyed", this._removeRenderable, this);
      this._managedRenderables[index] = null;
    }
  }
  _updateInstructionGCTick(renderGroup, gcTick) {
    renderGroup.instructionSet.gcTick = gcTick;
    for (const child of renderGroup.renderGroupChildren) {
      this._updateInstructionGCTick(child, gcTick);
    }
  }
}, RenderableGCSystem;
var init_RenderableGCSystem = __esm(() => {
  init_Extensions();
  init_clean();
  _RenderableGCSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "renderableGC",
    priority: 0
  };
  _RenderableGCSystem.defaultOptions = {
    renderableGCActive: true,
    renderableGCMaxUnusedTime: 60000,
    renderableGCFrequency: 30000
  };
  RenderableGCSystem = _RenderableGCSystem;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
var _TextureGCSystem = class _TextureGCSystem2 {
  constructor(renderer) {
    this._renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
  }
  init(options) {
    options = { ..._TextureGCSystem2.defaultOptions, ...options };
    this.checkCountMax = options.textureGCCheckCountMax;
    this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;
    this.active = options.textureGCActive;
  }
  postrender() {
    if (!this._renderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (!this.active)
      return;
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  }
  run() {
    const managedTextures = this._renderer.texture.managedTextures;
    for (let i2 = 0;i2 < managedTextures.length; i2++) {
      const texture = managedTextures[i2];
      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
        texture._touched = -1;
        texture.unload();
      }
    }
  }
  destroy() {
    this._renderer = null;
  }
}, TextureGCSystem;
var init_TextureGCSystem = __esm(() => {
  init_Extensions();
  _TextureGCSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "textureGC"
  };
  _TextureGCSystem.defaultOptions = {
    textureGCActive: true,
    textureGCAMaxIdle: null,
    textureGCMaxIdle: 60 * 60,
    textureGCCheckCountMax: 600
  };
  TextureGCSystem = _TextureGCSystem;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
var _RenderTarget = class _RenderTarget2 {
  constructor(descriptor = {}) {
    this.uid = uid("renderTarget");
    this.colorTextures = [];
    this.dirtyId = 0;
    this.isRoot = false;
    this._size = new Float32Array(2);
    this._managedColorTextures = false;
    descriptor = { ..._RenderTarget2.defaultOptions, ...descriptor };
    this.stencil = descriptor.stencil;
    this.depth = descriptor.depth;
    this.isRoot = descriptor.isRoot;
    if (typeof descriptor.colorTextures === "number") {
      this._managedColorTextures = true;
      for (let i2 = 0;i2 < descriptor.colorTextures; i2++) {
        this.colorTextures.push(new TextureSource({
          width: descriptor.width,
          height: descriptor.height,
          resolution: descriptor.resolution,
          antialias: descriptor.antialias
        }));
      }
    } else {
      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
      const colorSource = this.colorTexture.source;
      this.resize(colorSource.width, colorSource.height, colorSource._resolution);
    }
    this.colorTexture.source.on("resize", this.onSourceResize, this);
    if (descriptor.depthStencilTexture || this.stencil) {
      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
        this.depthStencilTexture = descriptor.depthStencilTexture.source;
      } else {
        this.ensureDepthStencilTexture();
      }
    }
  }
  get size() {
    const _size = this._size;
    _size[0] = this.pixelWidth;
    _size[1] = this.pixelHeight;
    return _size;
  }
  get width() {
    return this.colorTexture.source.width;
  }
  get height() {
    return this.colorTexture.source.height;
  }
  get pixelWidth() {
    return this.colorTexture.source.pixelWidth;
  }
  get pixelHeight() {
    return this.colorTexture.source.pixelHeight;
  }
  get resolution() {
    return this.colorTexture.source._resolution;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  onSourceResize(source2) {
    this.resize(source2.width, source2.height, source2._resolution, true);
  }
  ensureDepthStencilTexture() {
    if (!this.depthStencilTexture) {
      this.depthStencilTexture = new TextureSource({
        width: this.width,
        height: this.height,
        resolution: this.resolution,
        format: "depth24plus-stencil8",
        autoGenerateMipmaps: false,
        antialias: false,
        mipLevelCount: 1
      });
    }
  }
  resize(width, height, resolution = this.resolution, skipColorTexture = false) {
    this.dirtyId++;
    this.colorTextures.forEach((colorTexture, i2) => {
      if (skipColorTexture && i2 === 0)
        return;
      colorTexture.source.resize(width, height, resolution);
    });
    if (this.depthStencilTexture) {
      this.depthStencilTexture.source.resize(width, height, resolution);
    }
  }
  destroy() {
    this.colorTexture.source.off("resize", this.onSourceResize, this);
    if (this._managedColorTextures) {
      this.colorTextures.forEach((texture) => {
        texture.destroy();
      });
    }
    if (this.depthStencilTexture) {
      this.depthStencilTexture.destroy();
      delete this.depthStencilTexture;
    }
  }
}, RenderTarget;
var init_RenderTarget = __esm(() => {
  init_uid();
  init_TextureSource();
  init_Texture();
  _RenderTarget.defaultOptions = {
    width: 0,
    height: 0,
    resolution: 1,
    colorTextures: 1,
    stencil: false,
    depth: false,
    antialias: false,
    isRoot: false
  };
  RenderTarget = _RenderTarget;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
function getCanvasTexture(canvas, options) {
  if (!canvasCache.has(canvas)) {
    const texture = new Texture({
      source: new CanvasSource({
        resource: canvas,
        ...options
      })
    });
    const onDestroy = () => {
      if (canvasCache.get(canvas) === texture) {
        canvasCache.delete(canvas);
      }
    };
    texture.once("destroy", onDestroy);
    texture.source.once("destroy", onDestroy);
    canvasCache.set(canvas, texture);
  }
  return canvasCache.get(canvas);
}
var canvasCache;
var init_getCanvasTexture = __esm(() => {
  init_GlobalResourceRegistry();
  init_CanvasSource();
  init_Texture();
  canvasCache = /* @__PURE__ */ new Map;
  GlobalResourceRegistry.register(canvasCache);
});

// node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
var _ViewSystem = class _ViewSystem2 {
  get autoDensity() {
    return this.texture.source.autoDensity;
  }
  set autoDensity(value) {
    this.texture.source.autoDensity = value;
  }
  get resolution() {
    return this.texture.source._resolution;
  }
  set resolution(value) {
    this.texture.source.resize(this.texture.source.width, this.texture.source.height, value);
  }
  init(options) {
    options = {
      ..._ViewSystem2.defaultOptions,
      ...options
    };
    if (options.view) {
      deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
      options.canvas = options.view;
    }
    this.screen = new Rectangle(0, 0, options.width, options.height);
    this.canvas = options.canvas || DOMAdapter.get().createCanvas();
    this.antialias = !!options.antialias;
    this.texture = getCanvasTexture(this.canvas, options);
    this.renderTarget = new RenderTarget({
      colorTextures: [this.texture],
      depth: !!options.depth,
      isRoot: true
    });
    this.texture.source.transparent = options.backgroundAlpha < 1;
    this.resolution = options.resolution;
  }
  resize(desiredScreenWidth, desiredScreenHeight, resolution) {
    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
    this.screen.width = this.texture.frame.width;
    this.screen.height = this.texture.frame.height;
  }
  destroy(options = false) {
    const removeView = typeof options === "boolean" ? options : !!options?.removeView;
    if (removeView && this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
    this.texture.destroy();
  }
}, ViewSystem;
var init_ViewSystem = __esm(() => {
  init_adapter();
  init_Extensions();
  init_Rectangle();
  init_deprecation();
  init_RenderTarget();
  init_getCanvasTexture();
  _ViewSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "view",
    priority: 0
  };
  _ViewSystem.defaultOptions = {
    width: 800,
    height: 600,
    autoDensity: false,
    antialias: false
  };
  ViewSystem = _ViewSystem;
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
var SharedSystems, SharedRenderPipes;
var init_SharedSystems = __esm(() => {
  init_CustomRenderPipe();
  init_RenderGroupPipe();
  init_RenderGroupSystem();
  init_SpritePipe();
  init_globalHooks();
  init_BatcherPipe();
  init_AlphaMaskPipe();
  init_ColorMaskPipe();
  init_StencilMaskPipe();
  init_BackgroundSystem();
  init_BlendModePipe();
  init_ExtractSystem();
  init_GenerateTextureSystem();
  init_GlobalUniformSystem();
  init_SchedulerSystem();
  init_HelloSystem();
  init_RenderableGCSystem();
  init_TextureGCSystem();
  init_ViewSystem();
  SharedSystems = [
    BackgroundSystem,
    GlobalUniformSystem,
    HelloSystem,
    ViewSystem,
    RenderGroupSystem,
    TextureGCSystem,
    GenerateTextureSystem,
    ExtractSystem,
    RendererInitHook,
    RenderableGCSystem,
    SchedulerSystem
  ];
  SharedRenderPipes = [
    BlendModePipe,
    BatcherPipe,
    SpritePipe,
    RenderGroupPipe,
    AlphaMaskPipe,
    StencilMaskPipe,
    ColorMaskPipe,
    CustomRenderPipe
  ];
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
class BindGroupSystem {
  constructor(renderer) {
    this._hash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_hash");
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  getBindGroup(bindGroup, program, groupIndex) {
    bindGroup._updateKey();
    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
    return gpuBindGroup;
  }
  _createBindGroup(group, program, groupIndex) {
    const device = this._gpu.device;
    const groupLayout = program.layout[groupIndex];
    const entries = [];
    const renderer = this._renderer;
    for (const j2 in groupLayout) {
      const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
      let gpuResource;
      if (resource._resourceType === "uniformGroup") {
        const uniformGroup = resource;
        renderer.ubo.updateUniformGroup(uniformGroup);
        const buffer = uniformGroup.buffer;
        gpuResource = {
          buffer: renderer.buffer.getGPUBuffer(buffer),
          offset: 0,
          size: buffer.descriptor.size
        };
      } else if (resource._resourceType === "buffer") {
        const buffer = resource;
        gpuResource = {
          buffer: renderer.buffer.getGPUBuffer(buffer),
          offset: 0,
          size: buffer.descriptor.size
        };
      } else if (resource._resourceType === "bufferResource") {
        const bufferResource = resource;
        gpuResource = {
          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
          offset: bufferResource.offset,
          size: bufferResource.size
        };
      } else if (resource._resourceType === "textureSampler") {
        const sampler = resource;
        gpuResource = renderer.texture.getGpuSampler(sampler);
      } else if (resource._resourceType === "textureSource") {
        const texture = resource;
        gpuResource = renderer.texture.getGpuSource(texture).createView({});
      }
      entries.push({
        binding: groupLayout[j2],
        resource: gpuResource
      });
    }
    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
    const gpuBindGroup = device.createBindGroup({
      layout,
      entries
    });
    this._hash[group._key] = gpuBindGroup;
    return gpuBindGroup;
  }
  destroy() {
    for (const key of Object.keys(this._hash)) {
      this._hash[key] = null;
    }
    this._hash = null;
    this._renderer = null;
  }
}
var init_BindGroupSystem = __esm(() => {
  init_Extensions();
  BindGroupSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "bindGroup"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
class GpuBufferSystem {
  constructor(renderer) {
    this._gpuBuffers = /* @__PURE__ */ Object.create(null);
    this._managedBuffers = [];
    renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  getGPUBuffer(buffer) {
    return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
  }
  updateBuffer(buffer) {
    const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
    const data = buffer.data;
    if (buffer._updateID && data) {
      buffer._updateID = 0;
      this._gpu.device.queue.writeBuffer(gpuBuffer, 0, data.buffer, 0, (buffer._updateSize || data.byteLength) + 3 & ~3);
    }
    return gpuBuffer;
  }
  destroyAll() {
    for (const id in this._gpuBuffers) {
      this._gpuBuffers[id].destroy();
    }
    this._gpuBuffers = {};
  }
  createGPUBuffer(buffer) {
    if (!this._gpuBuffers[buffer.uid]) {
      buffer.on("update", this.updateBuffer, this);
      buffer.on("change", this.onBufferChange, this);
      buffer.on("destroy", this.onBufferDestroy, this);
      this._managedBuffers.push(buffer);
    }
    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
    buffer._updateID = 0;
    if (buffer.data) {
      fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
      gpuBuffer.unmap();
    }
    this._gpuBuffers[buffer.uid] = gpuBuffer;
    return gpuBuffer;
  }
  onBufferChange(buffer) {
    const gpuBuffer = this._gpuBuffers[buffer.uid];
    gpuBuffer.destroy();
    buffer._updateID = 0;
    this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
  }
  onBufferDestroy(buffer) {
    this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
    this._destroyBuffer(buffer);
  }
  destroy() {
    this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
    this._managedBuffers = null;
    this._gpuBuffers = null;
  }
  _destroyBuffer(buffer) {
    const gpuBuffer = this._gpuBuffers[buffer.uid];
    gpuBuffer.destroy();
    buffer.off("update", this.updateBuffer, this);
    buffer.off("change", this.onBufferChange, this);
    buffer.off("destroy", this.onBufferDestroy, this);
    this._gpuBuffers[buffer.uid] = null;
  }
}
var init_GpuBufferSystem = __esm(() => {
  init_Extensions();
  init_fastCopy();
  GpuBufferSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "buffer"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
class GpuColorMaskSystem {
  constructor(renderer) {
    this._colorMaskCache = 15;
    this._renderer = renderer;
  }
  setMask(colorMask) {
    if (this._colorMaskCache === colorMask)
      return;
    this._colorMaskCache = colorMask;
    this._renderer.pipeline.setColorMask(colorMask);
  }
  destroy() {
    this._renderer = null;
    this._colorMaskCache = null;
  }
}
var init_GpuColorMaskSystem = __esm(() => {
  init_Extensions();
  GpuColorMaskSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "colorMask"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
class GpuDeviceSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  async init(options) {
    if (this._initPromise)
      return this._initPromise;
    this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options)).then((gpu) => {
      this.gpu = gpu;
      this._renderer.runners.contextChange.emit(this.gpu);
    });
    return this._initPromise;
  }
  contextChange(gpu) {
    this._renderer.gpu = gpu;
  }
  async _createDeviceAndAdaptor(options) {
    const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({
      powerPreference: options.powerPreference,
      forceFallbackAdapter: options.forceFallbackAdapter
    });
    const requiredFeatures = [
      "texture-compression-bc",
      "texture-compression-astc",
      "texture-compression-etc2"
    ].filter((feature) => adapter.features.has(feature));
    const device = await adapter.requestDevice({
      requiredFeatures
    });
    return { adapter, device };
  }
  destroy() {
    this.gpu = null;
    this._renderer = null;
  }
}
var init_GpuDeviceSystem = __esm(() => {
  init_adapter();
  init_Extensions();
  GpuDeviceSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "device"
  };
  GpuDeviceSystem.defaultOptions = {
    powerPreference: undefined,
    forceFallbackAdapter: false
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
class GpuEncoderSystem {
  constructor(renderer) {
    this._boundBindGroup = /* @__PURE__ */ Object.create(null);
    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
  }
  renderStart() {
    this.commandFinished = new Promise((resolve) => {
      this._resolveCommandFinished = resolve;
    });
    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
  }
  beginRenderPass(gpuRenderTarget) {
    this.endRenderPass();
    this._clearCache();
    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
  }
  endRenderPass() {
    if (this.renderPassEncoder) {
      this.renderPassEncoder.end();
    }
    this.renderPassEncoder = null;
  }
  setViewport(viewport) {
    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
  }
  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
    this.setPipeline(pipeline);
  }
  setPipeline(pipeline) {
    if (this._boundPipeline === pipeline)
      return;
    this._boundPipeline = pipeline;
    this.renderPassEncoder.setPipeline(pipeline);
  }
  _setVertexBuffer(index, buffer) {
    if (this._boundVertexBuffer[index] === buffer)
      return;
    this._boundVertexBuffer[index] = buffer;
    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
  }
  _setIndexBuffer(buffer) {
    if (this._boundIndexBuffer === buffer)
      return;
    this._boundIndexBuffer = buffer;
    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
  }
  resetBindGroup(index) {
    this._boundBindGroup[index] = null;
  }
  setBindGroup(index, bindGroup, program) {
    if (this._boundBindGroup[index] === bindGroup)
      return;
    this._boundBindGroup[index] = bindGroup;
    bindGroup._touch(this._renderer.textureGC.count);
    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
  }
  setGeometry(geometry, program) {
    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
    for (const i2 in buffersToBind) {
      this._setVertexBuffer(parseInt(i2, 10), geometry.attributes[buffersToBind[i2]].buffer);
    }
    if (geometry.indexBuffer) {
      this._setIndexBuffer(geometry.indexBuffer);
    }
  }
  _setShaderBindGroups(shader, skipSync) {
    for (const i2 in shader.groups) {
      const bindGroup = shader.groups[i2];
      if (!skipSync) {
        this._syncBindGroup(bindGroup);
      }
      this.setBindGroup(i2, bindGroup, shader.gpuProgram);
    }
  }
  _syncBindGroup(bindGroup) {
    for (const j2 in bindGroup.resources) {
      const resource = bindGroup.resources[j2];
      if (resource.isUniformGroup) {
        this._renderer.ubo.updateUniformGroup(resource);
      }
    }
  }
  draw(options) {
    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;
    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
    this.setGeometry(geometry, shader.gpuProgram);
    this._setShaderBindGroups(shader, skipSync);
    if (geometry.indexBuffer) {
      this.renderPassEncoder.drawIndexed(size || geometry.indexBuffer.data.length, instanceCount ?? geometry.instanceCount, start || 0);
    } else {
      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);
    }
  }
  finishRenderPass() {
    if (this.renderPassEncoder) {
      this.renderPassEncoder.end();
      this.renderPassEncoder = null;
    }
  }
  postrender() {
    this.finishRenderPass();
    this._gpu.device.queue.submit([this.commandEncoder.finish()]);
    this._resolveCommandFinished();
    this.commandEncoder = null;
  }
  restoreRenderPass() {
    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, false, [0, 0, 0, 1]);
    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
    const boundPipeline = this._boundPipeline;
    const boundVertexBuffer = { ...this._boundVertexBuffer };
    const boundIndexBuffer = this._boundIndexBuffer;
    const boundBindGroup = { ...this._boundBindGroup };
    this._clearCache();
    const viewport = this._renderer.renderTarget.viewport;
    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
    this.setPipeline(boundPipeline);
    for (const i2 in boundVertexBuffer) {
      this._setVertexBuffer(i2, boundVertexBuffer[i2]);
    }
    for (const i2 in boundBindGroup) {
      this.setBindGroup(i2, boundBindGroup[i2], null);
    }
    this._setIndexBuffer(boundIndexBuffer);
  }
  _clearCache() {
    for (let i2 = 0;i2 < 16; i2++) {
      this._boundBindGroup[i2] = null;
      this._boundVertexBuffer[i2] = null;
    }
    this._boundIndexBuffer = null;
    this._boundPipeline = null;
  }
  destroy() {
    this._renderer = null;
    this._gpu = null;
    this._boundBindGroup = null;
    this._boundVertexBuffer = null;
    this._boundIndexBuffer = null;
    this._boundPipeline = null;
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
}
var init_GpuEncoderSystem = __esm(() => {
  init_Extensions();
  GpuEncoderSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "encoder",
    priority: 1
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs
class GpuLimitsSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  contextChange() {
    this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;
    this.maxBatchableTextures = this.maxTextures;
  }
  destroy() {}
}
var init_GpuLimitsSystem = __esm(() => {
  init_Extensions();
  GpuLimitsSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "limits"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
class GpuStencilSystem {
  constructor(renderer) {
    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    renderer.renderTarget.onRenderTargetChange.add(this);
  }
  onRenderTargetChange(renderTarget) {
    let stencilState = this._renderTargetStencilState[renderTarget.uid];
    if (!stencilState) {
      stencilState = this._renderTargetStencilState[renderTarget.uid] = {
        stencilMode: STENCIL_MODES.DISABLED,
        stencilReference: 0
      };
    }
    this._activeRenderTarget = renderTarget;
    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
  }
  setStencilMode(stencilMode, stencilReference) {
    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
    stencilState.stencilMode = stencilMode;
    stencilState.stencilReference = stencilReference;
    const renderer = this._renderer;
    renderer.pipeline.setStencilMode(stencilMode);
    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
  }
  destroy() {
    this._renderer.renderTarget.onRenderTargetChange.remove(this);
    this._renderer = null;
    this._activeRenderTarget = null;
    this._renderTargetStencilState = null;
  }
}
var init_GpuStencilSystem = __esm(() => {
  init_Extensions();
  init_const3();
  GpuStencilSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "stencil"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs
class UboSystem {
  constructor(adaptor) {
    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
    this._adaptor = adaptor;
    this._systemCheck();
  }
  _systemCheck() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
  }
  ensureUniformGroup(uniformGroup) {
    const uniformData = this.getUniformGroupData(uniformGroup);
    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({
      data: new Float32Array(uniformData.layout.size / 4),
      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
    }));
  }
  getUniformGroupData(uniformGroup) {
    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
  }
  _initUniformGroup(uniformGroup) {
    const uniformGroupSignature = uniformGroup._signature;
    let uniformData = this._syncFunctionHash[uniformGroupSignature];
    if (!uniformData) {
      const elements = Object.keys(uniformGroup.uniformStructures).map((i2) => uniformGroup.uniformStructures[i2]);
      const layout = this._adaptor.createUboElements(elements);
      const syncFunction = this._generateUboSync(layout.uboElements);
      uniformData = this._syncFunctionHash[uniformGroupSignature] = {
        layout,
        syncFunction
      };
    }
    return this._syncFunctionHash[uniformGroupSignature];
  }
  _generateUboSync(uboElements) {
    return this._adaptor.generateUboSync(uboElements);
  }
  syncUniformGroup(uniformGroup, data, offset) {
    const uniformGroupData = this.getUniformGroupData(uniformGroup);
    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({
      data: new Float32Array(uniformGroupData.layout.size / 4),
      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
    }));
    let dataInt32 = null;
    if (!data) {
      data = uniformGroup.buffer.data;
      dataInt32 = uniformGroup.buffer.dataInt32;
    }
    offset || (offset = 0);
    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);
    return true;
  }
  updateUniformGroup(uniformGroup) {
    if (uniformGroup.isStatic && !uniformGroup._dirtyId)
      return false;
    uniformGroup._dirtyId = 0;
    const synced = this.syncUniformGroup(uniformGroup);
    uniformGroup.buffer.update();
    return synced;
  }
  destroy() {
    this._syncFunctionHash = null;
  }
}
var init_UboSystem = __esm(() => {
  init_unsafeEvalSupported();
  init_Buffer();
  init_const4();
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
function createUboElementsWGSL(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let offset = 0;
  for (let i2 = 0;i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, align) * uboElement.data.size;
    }
    offset = Math.ceil(offset / align) * align;
    uboElement.size = size;
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_ALIGN_SIZE_DATA;
var init_createUboElementsWGSL = __esm(() => {
  WGSL_ALIGN_SIZE_DATA = {
    i32: { align: 4, size: 4 },
    u32: { align: 4, size: 4 },
    f32: { align: 4, size: 4 },
    f16: { align: 2, size: 2 },
    "vec2<i32>": { align: 8, size: 8 },
    "vec2<u32>": { align: 8, size: 8 },
    "vec2<f32>": { align: 8, size: 8 },
    "vec2<f16>": { align: 4, size: 4 },
    "vec3<i32>": { align: 16, size: 12 },
    "vec3<u32>": { align: 16, size: 12 },
    "vec3<f32>": { align: 16, size: 12 },
    "vec3<f16>": { align: 8, size: 6 },
    "vec4<i32>": { align: 16, size: 16 },
    "vec4<u32>": { align: 16, size: 16 },
    "vec4<f32>": { align: 16, size: 16 },
    "vec4<f16>": { align: 8, size: 8 },
    "mat2x2<f32>": { align: 8, size: 16 },
    "mat2x2<f16>": { align: 4, size: 8 },
    "mat3x2<f32>": { align: 8, size: 24 },
    "mat3x2<f16>": { align: 4, size: 12 },
    "mat4x2<f32>": { align: 8, size: 32 },
    "mat4x2<f16>": { align: 4, size: 16 },
    "mat2x3<f32>": { align: 16, size: 32 },
    "mat2x3<f16>": { align: 8, size: 16 },
    "mat3x3<f32>": { align: 16, size: 48 },
    "mat3x3<f16>": { align: 8, size: 24 },
    "mat4x3<f32>": { align: 16, size: 64 },
    "mat4x3<f16>": { align: 8, size: 32 },
    "mat2x4<f32>": { align: 16, size: 32 },
    "mat2x4<f16>": { align: 8, size: 16 },
    "mat3x4<f32>": { align: 16, size: 48 },
    "mat3x4<f16>": { align: 8, size: 24 },
    "mat4x4<f32>": { align: 16, size: 64 },
    "mat4x4<f16>": { align: 8, size: 32 }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
var uniformParsers;
var init_uniformParsers = __esm(() => {
  uniformParsers = [
    {
      type: "mat3x3<f32>",
      test: (data) => {
        const value = data.value;
        return value.a !== undefined;
      },
      ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
      uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
    },
    {
      type: "vec4<f32>",
      test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== undefined,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
    },
    {
      type: "vec2<f32>",
      test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== undefined,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
    },
    {
      type: "vec4<f32>",
      test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== undefined,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
    },
    {
      type: "vec3<f32>",
      test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== undefined,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
    }
  ];
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
  const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
  let prev = 0;
  for (let i2 = 0;i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    const name = uboElement.data.name;
    let parsed = false;
    let offset = 0;
    for (let j2 = 0;j2 < uniformParsers.length; j2++) {
      const uniformParser = uniformParsers[j2];
      if (uniformParser.test(uboElement.data)) {
        offset = uboElement.offset / 4;
        funcFragments.push(`name = "${name}";`, `offset += ${offset - prev};`, uniformParsers[j2][parserCode] || uniformParsers[j2].ubo);
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        offset = uboElement.offset / 4;
        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
      } else {
        const template = singleSettersMap[uboElement.data.type];
        offset = uboElement.offset / 4;
        funcFragments.push(`
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `);
      }
    }
    prev = offset;
  }
  const fragmentSrc = funcFragments.join(`
`);
  return new Function("uv", "data", "dataInt32", "offset", fragmentSrc);
}
var init_createUboSyncFunction = __esm(() => {
  init_uniformParsers();
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
function loopMatrix(col, row) {
  const total = col * row;
  return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
}
var uboSyncFunctionsSTD40, uboSyncFunctionsWGSL;
var init_uboSyncFunctions = __esm(() => {
  uboSyncFunctionsSTD40 = {
    f32: `
        data[offset] = v;`,
    i32: `
        dataInt32[offset] = v;`,
    "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
    "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
    "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
    "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
    "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
    "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
    "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
    "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
    "mat3x2<f32>": loopMatrix(3, 2),
    "mat4x2<f32>": loopMatrix(4, 2),
    "mat2x3<f32>": loopMatrix(2, 3),
    "mat4x3<f32>": loopMatrix(4, 3),
    "mat2x4<f32>": loopMatrix(2, 4),
    "mat3x4<f32>": loopMatrix(3, 4)
  };
  uboSyncFunctionsWGSL = {
    ...uboSyncFunctionsSTD40,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
function generateArraySyncWGSL(uboElement, offsetToAdd) {
  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
  const remainder = (align - size) / 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 ${data}[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
}
var init_generateArraySyncWGSL = __esm(() => {
  init_createUboElementsWGSL();
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
function createUboSyncFunctionWGSL(uboElements) {
  return createUboSyncFunction(uboElements, "uboWgsl", generateArraySyncWGSL, uboSyncFunctionsWGSL);
}
var init_createUboSyncFunctionWGSL = __esm(() => {
  init_createUboSyncFunction();
  init_uboSyncFunctions();
  init_generateArraySyncWGSL();
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs
var GpuUboSystem;
var init_GpuUboSystem = __esm(() => {
  init_Extensions();
  init_UboSystem();
  init_createUboElementsWGSL();
  init_createUboSyncFunctionWGSL();
  GpuUboSystem = class GpuUboSystem extends UboSystem {
    constructor() {
      super({
        createUboElements: createUboElementsWGSL,
        generateUboSync: createUboSyncFunctionWGSL
      });
    }
  };
  GpuUboSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "ubo"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
var BufferResource;
var init_BufferResource = __esm(() => {
  init_eventemitter3();
  init_uid();
  BufferResource = class BufferResource extends eventemitter3_default {
    constructor({ buffer, offset, size }) {
      super();
      this.uid = uid("buffer");
      this._resourceType = "bufferResource";
      this._touched = 0;
      this._resourceId = uid("resource");
      this._bufferResource = true;
      this.destroyed = false;
      this.buffer = buffer;
      this.offset = offset | 0;
      this.size = size;
      this.buffer.on("change", this.onBufferChange, this);
    }
    onBufferChange() {
      this._resourceId = uid("resource");
      this.emit("change", this);
    }
    destroy(destroyBuffer = false) {
      this.destroyed = true;
      if (destroyBuffer) {
        this.buffer.destroy();
      }
      this.emit("change", this);
      this.buffer = null;
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
class UboBatch {
  constructor({ minUniformOffsetAlignment }) {
    this._minUniformOffsetAlignment = 256;
    this.byteIndex = 0;
    this._minUniformOffsetAlignment = minUniformOffsetAlignment;
    this.data = new Float32Array(65535);
  }
  clear() {
    this.byteIndex = 0;
  }
  addEmptyGroup(size) {
    if (size > this._minUniformOffsetAlignment / 4) {
      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
    }
    const start = this.byteIndex;
    let newSize = start + size * 4;
    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
    if (newSize > this.data.length * 4) {
      throw new Error("UniformBufferBatch: ubo batch got too big");
    }
    this.byteIndex = newSize;
    return start;
  }
  addGroup(array) {
    const offset = this.addEmptyGroup(array.length);
    for (let i2 = 0;i2 < array.length; i2++) {
      this.data[offset / 4 + i2] = array[i2];
    }
    return offset;
  }
  destroy() {
    this.data = null;
  }
}
var init_UboBatch = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
class GpuUniformBatchPipe {
  constructor(renderer) {
    this._bindGroupHash = /* @__PURE__ */ Object.create(null);
    this._buffers = [];
    this._bindGroups = [];
    this._bufferResources = [];
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
    const totalBuffers = 256 / minUniformOffsetAlignment;
    for (let i2 = 0;i2 < totalBuffers; i2++) {
      let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
      if (i2 === 0)
        usage |= BufferUsage.COPY_SRC;
      this._buffers.push(new Buffer({
        data: this._batchBuffer.data,
        usage
      }));
    }
  }
  renderEnd() {
    this._uploadBindGroups();
    this._resetBindGroups();
  }
  _resetBindGroups() {
    for (const i2 in this._bindGroupHash) {
      this._bindGroupHash[i2] = null;
    }
    this._batchBuffer.clear();
  }
  getUniformBindGroup(group, duplicate) {
    if (!duplicate && this._bindGroupHash[group.uid]) {
      return this._bindGroupHash[group.uid];
    }
    this._renderer.ubo.ensureUniformGroup(group);
    const data = group.buffer.data;
    const offset = this._batchBuffer.addEmptyGroup(data.length);
    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
    return this._bindGroupHash[group.uid];
  }
  getUboResource(group) {
    this._renderer.ubo.updateUniformGroup(group);
    const data = group.buffer.data;
    const offset = this._batchBuffer.addGroup(data);
    return this._getBufferResource(offset / minUniformOffsetAlignment);
  }
  getArrayBindGroup(data) {
    const offset = this._batchBuffer.addGroup(data);
    return this._getBindGroup(offset / minUniformOffsetAlignment);
  }
  getArrayBufferResource(data) {
    const offset = this._batchBuffer.addGroup(data);
    const index = offset / minUniformOffsetAlignment;
    return this._getBufferResource(index);
  }
  _getBufferResource(index) {
    if (!this._bufferResources[index]) {
      const buffer = this._buffers[index % 2];
      this._bufferResources[index] = new BufferResource({
        buffer,
        offset: (index / 2 | 0) * 256,
        size: minUniformOffsetAlignment
      });
    }
    return this._bufferResources[index];
  }
  _getBindGroup(index) {
    if (!this._bindGroups[index]) {
      const bindGroup = new BindGroup({
        0: this._getBufferResource(index)
      });
      this._bindGroups[index] = bindGroup;
    }
    return this._bindGroups[index];
  }
  _uploadBindGroups() {
    const bufferSystem = this._renderer.buffer;
    const firstBuffer = this._buffers[0];
    firstBuffer.update(this._batchBuffer.byteIndex);
    bufferSystem.updateBuffer(firstBuffer);
    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
    for (let i2 = 1;i2 < this._buffers.length; i2++) {
      const buffer = this._buffers[i2];
      commandEncoder.copyBufferToBuffer(bufferSystem.getGPUBuffer(firstBuffer), minUniformOffsetAlignment, bufferSystem.getGPUBuffer(buffer), 0, this._batchBuffer.byteIndex);
    }
    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
  }
  destroy() {
    for (let i2 = 0;i2 < this._bindGroups.length; i2++) {
      this._bindGroups[i2]?.destroy();
    }
    this._bindGroups = null;
    this._bindGroupHash = null;
    for (let i2 = 0;i2 < this._buffers.length; i2++) {
      this._buffers[i2].destroy();
    }
    this._buffers = null;
    for (let i2 = 0;i2 < this._bufferResources.length; i2++) {
      this._bufferResources[i2].destroy();
    }
    this._bufferResources = null;
    this._batchBuffer.destroy();
    this._bindGroupHash = null;
    this._renderer = null;
  }
}
var minUniformOffsetAlignment = 128;
var init_GpuUniformBatchPipe = __esm(() => {
  init_Extensions();
  init_Buffer();
  init_BufferResource();
  init_const4();
  init_UboBatch();
  init_BindGroup();
  GpuUniformBatchPipe.extension = {
    type: [
      ExtensionType.WebGPUPipes
    ],
    name: "uniformBatch"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
function ensureAttributes(geometry, extractedData) {
  for (const i2 in geometry.attributes) {
    const attribute = geometry.attributes[i2];
    const attributeData = extractedData[i2];
    if (attributeData) {
      attribute.format ?? (attribute.format = attributeData.format);
      attribute.offset ?? (attribute.offset = attributeData.offset);
      attribute.instance ?? (attribute.instance = attributeData.instance);
    } else {
      warn(`Attribute ${i2} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
    }
  }
  ensureStartAndStride(geometry);
}
function ensureStartAndStride(geometry) {
  const { buffers, attributes } = geometry;
  const tempStride = {};
  const tempStart = {};
  for (const j2 in buffers) {
    const buffer = buffers[j2];
    tempStride[buffer.uid] = 0;
    tempStart[buffer.uid] = 0;
  }
  for (const j2 in attributes) {
    const attribute = attributes[j2];
    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
  for (const j2 in attributes) {
    const attribute = attributes[j2];
    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
}
var init_ensureAttributes = __esm(() => {
  init_warn();
  init_getAttributeInfoFromFormat();
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
var GpuStencilModesToPixi;
var init_GpuStencilModesToPixi = __esm(() => {
  init_const3();
  GpuStencilModesToPixi = [];
  GpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;
  GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
    stencilWriteMask: 0,
    stencilReadMask: 0
  };
  GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
    stencilFront: {
      compare: "equal",
      passOp: "increment-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "increment-clamp"
    }
  };
  GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
    stencilFront: {
      compare: "equal",
      passOp: "decrement-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "decrement-clamp"
    }
  };
  GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
      compare: "equal",
      passOp: "keep"
    },
    stencilBack: {
      compare: "equal",
      passOp: "keep"
    }
  };
  GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
      compare: "not-equal",
      passOp: "keep"
    },
    stencilBack: {
      compare: "not-equal",
      passOp: "keep"
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
}
function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
}

class PipelineSystem {
  constructor(renderer) {
    this._moduleCache = /* @__PURE__ */ Object.create(null);
    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
    this._pipeCache = /* @__PURE__ */ Object.create(null);
    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
    this._colorMask = 15;
    this._multisampleCount = 1;
    this._renderer = renderer;
  }
  contextChange(gpu) {
    this._gpu = gpu;
    this.setStencilMode(STENCIL_MODES.DISABLED);
    this._updatePipeHash();
  }
  setMultisampleCount(multisampleCount) {
    if (this._multisampleCount === multisampleCount)
      return;
    this._multisampleCount = multisampleCount;
    this._updatePipeHash();
  }
  setRenderTarget(renderTarget) {
    this._multisampleCount = renderTarget.msaaSamples;
    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
    this._updatePipeHash();
  }
  setColorMask(colorMask) {
    if (this._colorMask === colorMask)
      return;
    this._colorMask = colorMask;
    this._updatePipeHash();
  }
  setStencilMode(stencilMode) {
    if (this._stencilMode === stencilMode)
      return;
    this._stencilMode = stencilMode;
    this._stencilState = GpuStencilModesToPixi[stencilMode];
    this._updatePipeHash();
  }
  setPipeline(geometry, program, state, passEncoder) {
    const pipeline = this.getPipeline(geometry, program, state);
    passEncoder.setPipeline(pipeline);
  }
  getPipeline(geometry, program, state, topology) {
    if (!geometry._layoutKey) {
      ensureAttributes(geometry, program.attributeData);
      this._generateBufferKey(geometry);
    }
    topology || (topology = geometry.topology);
    const key = getGraphicsStateKey(geometry._layoutKey, program._layoutKey, state.data, state._blendModeId, topologyStringToId[topology]);
    if (this._pipeCache[key])
      return this._pipeCache[key];
    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
    return this._pipeCache[key];
  }
  _createPipeline(geometry, program, state, topology) {
    const device = this._gpu.device;
    const buffers = this._createVertexBufferLayouts(geometry, program);
    const blendModes = this._renderer.state.getColorTargets(state);
    blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
    const layout = this._renderer.shader.getProgramData(program).pipeline;
    const descriptor = {
      vertex: {
        module: this._getModule(program.vertex.source),
        entryPoint: program.vertex.entryPoint,
        buffers
      },
      fragment: {
        module: this._getModule(program.fragment.source),
        entryPoint: program.fragment.entryPoint,
        targets: blendModes
      },
      primitive: {
        topology,
        cullMode: state.cullMode
      },
      layout,
      multisample: {
        count: this._multisampleCount
      },
      label: `PIXI Pipeline`
    };
    if (this._depthStencilAttachment) {
      descriptor.depthStencil = {
        ...this._stencilState,
        format: "depth24plus-stencil8",
        depthWriteEnabled: state.depthTest,
        depthCompare: state.depthTest ? "less" : "always"
      };
    }
    const pipeline = device.createRenderPipeline(descriptor);
    return pipeline;
  }
  _getModule(code) {
    return this._moduleCache[code] || this._createModule(code);
  }
  _createModule(code) {
    const device = this._gpu.device;
    this._moduleCache[code] = device.createShaderModule({
      code
    });
    return this._moduleCache[code];
  }
  _generateBufferKey(geometry) {
    const keyGen = [];
    let index = 0;
    const attributeKeys = Object.keys(geometry.attributes).sort();
    for (let i2 = 0;i2 < attributeKeys.length; i2++) {
      const attribute = geometry.attributes[attributeKeys[i2]];
      keyGen[index++] = attribute.offset;
      keyGen[index++] = attribute.format;
      keyGen[index++] = attribute.stride;
      keyGen[index++] = attribute.instance;
    }
    const stringKey = keyGen.join("|");
    geometry._layoutKey = createIdFromString(stringKey, "geometry");
    return geometry._layoutKey;
  }
  _generateAttributeLocationsKey(program) {
    const keyGen = [];
    let index = 0;
    const attributeKeys = Object.keys(program.attributeData).sort();
    for (let i2 = 0;i2 < attributeKeys.length; i2++) {
      const attribute = program.attributeData[attributeKeys[i2]];
      keyGen[index++] = attribute.location;
    }
    const stringKey = keyGen.join("|");
    program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
    return program._attributeLocationsKey;
  }
  getBufferNamesToBind(geometry, program) {
    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
    if (this._bindingNamesCache[key])
      return this._bindingNamesCache[key];
    const data = this._createVertexBufferLayouts(geometry, program);
    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
    const attributeData = program.attributeData;
    for (let i2 = 0;i2 < data.length; i2++) {
      const attributes = Object.values(data[i2].attributes);
      const shaderLocation = attributes[0].shaderLocation;
      for (const j2 in attributeData) {
        if (attributeData[j2].location === shaderLocation) {
          bufferNamesToBind[i2] = j2;
          break;
        }
      }
    }
    this._bindingNamesCache[key] = bufferNamesToBind;
    return bufferNamesToBind;
  }
  _createVertexBufferLayouts(geometry, program) {
    if (!program._attributeLocationsKey)
      this._generateAttributeLocationsKey(program);
    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
    if (this._bufferLayoutsCache[key]) {
      return this._bufferLayoutsCache[key];
    }
    const vertexBuffersLayout = [];
    geometry.buffers.forEach((buffer) => {
      const bufferEntry = {
        arrayStride: 0,
        stepMode: "vertex",
        attributes: []
      };
      const bufferEntryAttributes = bufferEntry.attributes;
      for (const i2 in program.attributeData) {
        const attribute = geometry.attributes[i2];
        if ((attribute.divisor ?? 1) !== 1) {
          warn(`Attribute ${i2} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
        }
        if (attribute.buffer === buffer) {
          bufferEntry.arrayStride = attribute.stride;
          bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
          bufferEntryAttributes.push({
            shaderLocation: program.attributeData[i2].location,
            offset: attribute.offset,
            format: attribute.format
          });
        }
      }
      if (bufferEntryAttributes.length) {
        vertexBuffersLayout.push(bufferEntry);
      }
    });
    this._bufferLayoutsCache[key] = vertexBuffersLayout;
    return vertexBuffersLayout;
  }
  _updatePipeHash() {
    const key = getGlobalStateKey(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
    if (!this._pipeStateCaches[key]) {
      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
    }
    this._pipeCache = this._pipeStateCaches[key];
  }
  destroy() {
    this._renderer = null;
    this._bufferLayoutsCache = null;
  }
}
var topologyStringToId;
var init_PipelineSystem = __esm(() => {
  init_Extensions();
  init_warn();
  init_ensureAttributes();
  init_const3();
  init_createIdFromString();
  init_GpuStencilModesToPixi();
  topologyStringToId = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 2,
    "triangle-list": 3,
    "triangle-strip": 4
  };
  PipelineSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "pipeline"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
function calculateProjection(pm, x2, y2, width, height, flipY) {
  const sign2 = flipY ? 1 : -1;
  pm.identity();
  pm.a = 1 / width * 2;
  pm.d = sign2 * (1 / height * 2);
  pm.tx = -1 - x2 * pm.a;
  pm.ty = -sign2 - y2 * pm.d;
  return pm;
}
var init_calculateProjection = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
function isRenderingToScreen(renderTarget) {
  const resource = renderTarget.colorTexture.source.resource;
  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
}
var init_isRenderingToScreen = () => {};

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
class RenderTargetSystem {
  constructor(renderer) {
    this.rootViewPort = new Rectangle;
    this.viewport = new Rectangle;
    this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
    this.projectionMatrix = new Matrix;
    this.defaultClearColor = [0, 0, 0, 0];
    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map;
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
    this._renderTargetStack = [];
    this._renderer = renderer;
    renderer.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
  }
  finishRenderPass() {
    this.adaptor.finishRenderPass(this.renderTarget);
  }
  renderStart({
    target,
    clear,
    clearColor,
    frame
  }) {
    this._renderTargetStack.length = 0;
    this.push(target, clear, clearColor, frame);
    this.rootViewPort.copyFrom(this.viewport);
    this.rootRenderTarget = this.renderTarget;
    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
    this.adaptor.prerender?.(this.rootRenderTarget);
  }
  postrender() {
    this.adaptor.postrender?.(this.rootRenderTarget);
  }
  bind(renderSurface, clear = true, clearColor, frame) {
    const renderTarget = this.getRenderTarget(renderSurface);
    const didChange = this.renderTarget !== renderTarget;
    this.renderTarget = renderTarget;
    this.renderSurface = renderSurface;
    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
      this.adaptor.resizeGpuRenderTarget(renderTarget);
      gpuRenderTarget.width = renderTarget.pixelWidth;
      gpuRenderTarget.height = renderTarget.pixelHeight;
    }
    const source2 = renderTarget.colorTexture;
    const viewport = this.viewport;
    const pixelWidth = source2.pixelWidth;
    const pixelHeight = source2.pixelHeight;
    if (!frame && renderSurface instanceof Texture) {
      frame = renderSurface.frame;
    }
    if (frame) {
      const resolution = source2._resolution;
      viewport.x = frame.x * resolution + 0.5 | 0;
      viewport.y = frame.y * resolution + 0.5 | 0;
      viewport.width = frame.width * resolution + 0.5 | 0;
      viewport.height = frame.height * resolution + 0.5 | 0;
    } else {
      viewport.x = 0;
      viewport.y = 0;
      viewport.width = pixelWidth;
      viewport.height = pixelHeight;
    }
    calculateProjection(this.projectionMatrix, 0, 0, viewport.width / source2.resolution, viewport.height / source2.resolution, !renderTarget.isRoot);
    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
    if (didChange) {
      this.onRenderTargetChange.emit(renderTarget);
    }
    return renderTarget;
  }
  clear(target, clear = CLEAR.ALL, clearColor) {
    if (!clear)
      return;
    if (target) {
      target = this.getRenderTarget(target);
    }
    this.adaptor.clear(target || this.renderTarget, clear, clearColor, this.viewport);
  }
  contextChange() {
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {
    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
    this._renderTargetStack.push({
      renderTarget,
      frame
    });
    return renderTarget;
  }
  pop() {
    this._renderTargetStack.pop();
    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
  }
  getRenderTarget(renderSurface) {
    if (renderSurface.isTexture) {
      renderSurface = renderSurface.source;
    }
    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
  }
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    if (originSrc.x < 0) {
      size.width += originSrc.x;
      originDest.x -= originSrc.x;
      originSrc.x = 0;
    }
    if (originSrc.y < 0) {
      size.height += originSrc.y;
      originDest.y -= originSrc.y;
      originSrc.y = 0;
    }
    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
    size.width = Math.min(size.width, pixelWidth - originSrc.x);
    size.height = Math.min(size.height, pixelHeight - originSrc.y);
    return this.adaptor.copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest);
  }
  ensureDepthStencil() {
    if (!this.renderTarget.stencil) {
      this.renderTarget.stencil = true;
      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
    }
  }
  destroy() {
    this._renderer = null;
    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
      if (renderTarget !== key) {
        renderTarget.destroy();
      }
    });
    this._renderSurfaceToRenderTargetHash.clear();
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  _initRenderTarget(renderSurface) {
    let renderTarget = null;
    if (CanvasSource.test(renderSurface)) {
      renderSurface = getCanvasTexture(renderSurface).source;
    }
    if (renderSurface instanceof RenderTarget) {
      renderTarget = renderSurface;
    } else if (renderSurface instanceof TextureSource) {
      renderTarget = new RenderTarget({
        colorTextures: [renderSurface]
      });
      if (renderSurface.source instanceof CanvasSource) {
        renderTarget.isRoot = true;
      }
      renderSurface.once("destroy", () => {
        renderTarget.destroy();
        this._renderSurfaceToRenderTargetHash.delete(renderSurface);
        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
        if (gpuRenderTarget) {
          this._gpuRenderTargetHash[renderTarget.uid] = null;
          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
        }
      });
    }
    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
    return renderTarget;
  }
  getGpuRenderTarget(renderTarget) {
    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
  }
  resetState() {
    this.renderTarget = null;
    this.renderSurface = null;
  }
}
var init_RenderTargetSystem = __esm(() => {
  init_Matrix();
  init_Rectangle();
  init_const7();
  init_calculateProjection();
  init_SystemRunner();
  init_CanvasSource();
  init_TextureSource();
  init_Texture();
  init_getCanvasTexture();
  init_isRenderingToScreen();
  init_RenderTarget();
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
class GpuRenderTarget {
  constructor() {
    this.contexts = [];
    this.msaaTextures = [];
    this.msaaSamples = 1;
  }
}
var init_GpuRenderTarget = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
class GpuRenderTargetAdaptor {
  init(renderer, renderTargetSystem) {
    this._renderer = renderer;
    this._renderTargetSystem = renderTargetSystem;
  }
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    const renderer = this._renderer;
    const baseGpuTexture = this._getGpuColorTexture(sourceRenderSurfaceTexture);
    const backGpuTexture = renderer.texture.getGpuSource(destinationTexture.source);
    renderer.encoder.commandEncoder.copyTextureToTexture({
      texture: baseGpuTexture,
      origin: originSrc
    }, {
      texture: backGpuTexture,
      origin: originDest
    }, size);
    return destinationTexture;
  }
  startRenderPass(renderTarget, clear = true, clearColor, viewport) {
    const renderTargetSystem = this._renderTargetSystem;
    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
    gpuRenderTarget.descriptor = descriptor;
    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
    this._renderer.encoder.beginRenderPass(gpuRenderTarget);
    this._renderer.encoder.setViewport(viewport);
  }
  finishRenderPass() {
    this._renderer.encoder.endRenderPass();
  }
  _getGpuColorTexture(renderTarget) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (gpuRenderTarget.contexts[0]) {
      return gpuRenderTarget.contexts[0].getCurrentTexture();
    }
    return this._renderer.texture.getGpuSource(renderTarget.colorTextures[0].source);
  }
  getDescriptor(renderTarget, clear, clearValue) {
    if (typeof clear === "boolean") {
      clear = clear ? CLEAR.ALL : CLEAR.NONE;
    }
    const renderTargetSystem = this._renderTargetSystem;
    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    const colorAttachments = renderTarget.colorTextures.map((texture, i2) => {
      const context2 = gpuRenderTarget.contexts[i2];
      let view;
      let resolveTarget;
      if (context2) {
        const currentTexture = context2.getCurrentTexture();
        const canvasTextureView = currentTexture.createView();
        view = canvasTextureView;
      } else {
        view = this._renderer.texture.getGpuSource(texture).createView({
          mipLevelCount: 1
        });
      }
      if (gpuRenderTarget.msaaTextures[i2]) {
        resolveTarget = view;
        view = this._renderer.texture.getTextureView(gpuRenderTarget.msaaTextures[i2]);
      }
      const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
      clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
      return {
        view,
        resolveTarget,
        clearValue,
        storeOp: "store",
        loadOp
      };
    });
    let depthStencilAttachment;
    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
      renderTarget.ensureDepthStencilTexture();
      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
    }
    if (renderTarget.depthStencilTexture) {
      const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
      const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
      depthStencilAttachment = {
        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
        stencilStoreOp: "store",
        stencilLoadOp,
        depthClearValue: 1,
        depthLoadOp,
        depthStoreOp: "store"
      };
    }
    const descriptor = {
      colorAttachments,
      depthStencilAttachment
    };
    return descriptor;
  }
  clear(renderTarget, clear = true, clearColor, viewport) {
    if (!clear)
      return;
    const { gpu, encoder } = this._renderer;
    const device = gpu.device;
    const standAlone = encoder.commandEncoder === null;
    if (standAlone) {
      const commandEncoder = device.createCommandEncoder();
      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      passEncoder.end();
      const gpuCommands = commandEncoder.finish();
      device.queue.submit([gpuCommands]);
    } else {
      this.startRenderPass(renderTarget, clear, clearColor, viewport);
    }
  }
  initGpuRenderTarget(renderTarget) {
    renderTarget.isRoot = true;
    const gpuRenderTarget = new GpuRenderTarget;
    renderTarget.colorTextures.forEach((colorTexture, i2) => {
      if (colorTexture instanceof CanvasSource) {
        const context2 = colorTexture.resource.getContext("webgpu");
        const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
        try {
          context2.configure({
            device: this._renderer.gpu.device,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            format: "bgra8unorm",
            alphaMode
          });
        } catch (e2) {
          console.error(e2);
        }
        gpuRenderTarget.contexts[i2] = context2;
      }
      gpuRenderTarget.msaa = colorTexture.source.antialias;
      if (colorTexture.source.antialias) {
        const msaaTexture = new TextureSource({
          width: 0,
          height: 0,
          sampleCount: 4
        });
        gpuRenderTarget.msaaTextures[i2] = msaaTexture;
      }
    });
    if (gpuRenderTarget.msaa) {
      gpuRenderTarget.msaaSamples = 4;
      if (renderTarget.depthStencilTexture) {
        renderTarget.depthStencilTexture.source.sampleCount = 4;
      }
    }
    return gpuRenderTarget;
  }
  destroyGpuRenderTarget(gpuRenderTarget) {
    gpuRenderTarget.contexts.forEach((context2) => {
      context2.unconfigure();
    });
    gpuRenderTarget.msaaTextures.forEach((texture) => {
      texture.destroy();
    });
    gpuRenderTarget.msaaTextures.length = 0;
    gpuRenderTarget.contexts.length = 0;
  }
  ensureDepthStencilTexture(renderTarget) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
      renderTarget.depthStencilTexture.source.sampleCount = 4;
    }
  }
  resizeGpuRenderTarget(renderTarget) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    gpuRenderTarget.width = renderTarget.width;
    gpuRenderTarget.height = renderTarget.height;
    if (gpuRenderTarget.msaa) {
      renderTarget.colorTextures.forEach((colorTexture, i2) => {
        const msaaTexture = gpuRenderTarget.msaaTextures[i2];
        msaaTexture?.resize(colorTexture.source.width, colorTexture.source.height, colorTexture.source._resolution);
      });
    }
  }
}
var init_GpuRenderTargetAdaptor = __esm(() => {
  init_const7();
  init_CanvasSource();
  init_TextureSource();
  init_GpuRenderTarget();
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
var GpuRenderTargetSystem;
var init_GpuRenderTargetSystem = __esm(() => {
  init_Extensions();
  init_RenderTargetSystem();
  init_GpuRenderTargetAdaptor();
  GpuRenderTargetSystem = class GpuRenderTargetSystem extends RenderTargetSystem {
    constructor(renderer) {
      super(renderer);
      this.adaptor = new GpuRenderTargetAdaptor;
      this.adaptor.init(renderer, this);
    }
  };
  GpuRenderTargetSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "renderTarget"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
class GpuShaderSystem {
  constructor() {
    this._gpuProgramData = /* @__PURE__ */ Object.create(null);
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  getProgramData(program) {
    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
  }
  _createGPUProgramData(program) {
    const device = this._gpu.device;
    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
    this._gpuProgramData[program._layoutKey] = {
      bindGroups,
      pipeline: device.createPipelineLayout(pipelineLayoutDesc)
    };
    return this._gpuProgramData[program._layoutKey];
  }
  destroy() {
    this._gpu = null;
    this._gpuProgramData = null;
  }
}
var init_GpuShaderSystem = __esm(() => {
  init_Extensions();
  GpuShaderSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "shader"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
var GpuBlendModesToPixi;
var init_GpuBlendModesToPixi = __esm(() => {
  GpuBlendModesToPixi = {};
  GpuBlendModesToPixi.normal = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.add = {
    alpha: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.multiply = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "dst",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.screen = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.overlay = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.none = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "zero",
      operation: "add"
    }
  };
  GpuBlendModesToPixi["normal-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  GpuBlendModesToPixi["add-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one",
      operation: "add"
    }
  };
  GpuBlendModesToPixi["screen-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.erase = {
    alpha: {
      srcFactor: "zero",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.min = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "min"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "min"
    }
  };
  GpuBlendModesToPixi.max = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "max"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "max"
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
class GpuStateSystem {
  constructor() {
    this.defaultState = new State;
    this.defaultState.blend = true;
  }
  contextChange(gpu) {
    this.gpu = gpu;
  }
  getColorTargets(state) {
    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
    return [
      {
        format: "bgra8unorm",
        writeMask: 0,
        blend
      }
    ];
  }
  destroy() {
    this.gpu = null;
  }
}
var init_GpuStateSystem = __esm(() => {
  init_Extensions();
  init_State();
  init_GpuBlendModesToPixi();
  GpuStateSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "state"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
var gpuUploadBufferImageResource;
var init_gpuUploadBufferImageResource = __esm(() => {
  gpuUploadBufferImageResource = {
    type: "image",
    upload(source2, gpuTexture, gpu) {
      const resource = source2.resource;
      const total = (source2.pixelWidth | 0) * (source2.pixelHeight | 0);
      const bytesPerPixel = resource.byteLength / total;
      gpu.device.queue.writeTexture({ texture: gpuTexture }, resource, {
        offset: 0,
        rowsPerImage: source2.pixelHeight,
        bytesPerRow: source2.pixelHeight * bytesPerPixel
      }, {
        width: source2.pixelWidth,
        height: source2.pixelHeight,
        depthOrArrayLayers: 1
      });
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
var blockDataMap, defaultBlockData, gpuUploadCompressedTextureResource;
var init_gpuUploadCompressedTextureResource = __esm(() => {
  blockDataMap = {
    "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
    "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
  };
  defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
  gpuUploadCompressedTextureResource = {
    type: "compressed",
    upload(source2, gpuTexture, gpu) {
      let mipWidth = source2.pixelWidth;
      let mipHeight = source2.pixelHeight;
      const blockData = blockDataMap[source2.format] || defaultBlockData;
      for (let i2 = 0;i2 < source2.resource.length; i2++) {
        const levelBuffer = source2.resource[i2];
        const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
        gpu.device.queue.writeTexture({
          texture: gpuTexture,
          mipLevel: i2
        }, levelBuffer, {
          offset: 0,
          bytesPerRow
        }, {
          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
          depthOrArrayLayers: 1
        });
        mipWidth = Math.max(mipWidth >> 1, 1);
        mipHeight = Math.max(mipHeight >> 1, 1);
      }
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
var gpuUploadImageResource;
var init_gpuUploadImageSource = __esm(() => {
  init_adapter();
  init_warn();
  gpuUploadImageResource = {
    type: "image",
    upload(source2, gpuTexture, gpu) {
      const resource = source2.resource;
      if (!resource)
        return;
      if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {
        const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);
        const context2 = canvas.getContext("2d");
        context2.drawImage(resource, 0, 0, resource.width, resource.height);
        source2.resource = canvas;
        warn("ImageSource: Image element passed, converting to canvas and replacing resource.");
      }
      const width = Math.min(gpuTexture.width, source2.resourceWidth || source2.pixelWidth);
      const height = Math.min(gpuTexture.height, source2.resourceHeight || source2.pixelHeight);
      const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
      gpu.device.queue.copyExternalImageToTexture({ source: resource }, { texture: gpuTexture, premultipliedAlpha }, {
        width,
        height
      });
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
var gpuUploadVideoResource;
var init_gpuUploadVideoSource = __esm(() => {
  init_gpuUploadImageSource();
  gpuUploadVideoResource = {
    type: "video",
    upload(source2, gpuTexture, gpu) {
      gpuUploadImageResource.upload(source2, gpuTexture, gpu);
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
class GpuMipmapGenerator {
  constructor(device) {
    this.device = device;
    this.sampler = device.createSampler({ minFilter: "linear" });
    this.pipelines = {};
  }
  _getMipmapPipeline(format) {
    let pipeline = this.pipelines[format];
    if (!pipeline) {
      if (!this.mipmapShaderModule) {
        this.mipmapShaderModule = this.device.createShaderModule({
          code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
        });
      }
      pipeline = this.device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: this.mipmapShaderModule,
          entryPoint: "vertexMain"
        },
        fragment: {
          module: this.mipmapShaderModule,
          entryPoint: "fragmentMain",
          targets: [{ format }]
        }
      });
      this.pipelines[format] = pipeline;
    }
    return pipeline;
  }
  generateMipmap(texture) {
    const pipeline = this._getMipmapPipeline(texture.format);
    if (texture.dimension === "3d" || texture.dimension === "1d") {
      throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
    }
    let mipTexture = texture;
    const arrayLayerCount = texture.depthOrArrayLayers || 1;
    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
    if (!renderToSource) {
      const mipTextureDescriptor = {
        size: {
          width: Math.ceil(texture.width / 2),
          height: Math.ceil(texture.height / 2),
          depthOrArrayLayers: arrayLayerCount
        },
        format: texture.format,
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
        mipLevelCount: texture.mipLevelCount - 1
      };
      mipTexture = this.device.createTexture(mipTextureDescriptor);
    }
    const commandEncoder = this.device.createCommandEncoder({});
    const bindGroupLayout = pipeline.getBindGroupLayout(0);
    for (let arrayLayer = 0;arrayLayer < arrayLayerCount; ++arrayLayer) {
      let srcView = texture.createView({
        baseMipLevel: 0,
        mipLevelCount: 1,
        dimension: "2d",
        baseArrayLayer: arrayLayer,
        arrayLayerCount: 1
      });
      let dstMipLevel = renderToSource ? 1 : 0;
      for (let i2 = 1;i2 < texture.mipLevelCount; ++i2) {
        const dstView = mipTexture.createView({
          baseMipLevel: dstMipLevel++,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: arrayLayer,
          arrayLayerCount: 1
        });
        const passEncoder = commandEncoder.beginRenderPass({
          colorAttachments: [{
            view: dstView,
            storeOp: "store",
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0, a: 0 }
          }]
        });
        const bindGroup = this.device.createBindGroup({
          layout: bindGroupLayout,
          entries: [{
            binding: 0,
            resource: this.sampler
          }, {
            binding: 1,
            resource: srcView
          }]
        });
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.draw(3, 1, 0, 0);
        passEncoder.end();
        srcView = dstView;
      }
    }
    if (!renderToSource) {
      const mipLevelSize = {
        width: Math.ceil(texture.width / 2),
        height: Math.ceil(texture.height / 2),
        depthOrArrayLayers: arrayLayerCount
      };
      for (let i2 = 1;i2 < texture.mipLevelCount; ++i2) {
        commandEncoder.copyTextureToTexture({
          texture: mipTexture,
          mipLevel: i2 - 1
        }, {
          texture,
          mipLevel: i2
        }, mipLevelSize);
        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
      }
    }
    this.device.queue.submit([commandEncoder.finish()]);
    if (!renderToSource) {
      mipTexture.destroy();
    }
    return texture;
  }
}
var init_GpuMipmapGenerator = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
class GpuTextureSystem {
  constructor(renderer) {
    this.managedTextures = [];
    this._gpuSources = /* @__PURE__ */ Object.create(null);
    this._gpuSamplers = /* @__PURE__ */ Object.create(null);
    this._bindGroupHash = /* @__PURE__ */ Object.create(null);
    this._textureViewHash = /* @__PURE__ */ Object.create(null);
    this._uploads = {
      image: gpuUploadImageResource,
      buffer: gpuUploadBufferImageResource,
      video: gpuUploadVideoResource,
      compressed: gpuUploadCompressedTextureResource
    };
    this._renderer = renderer;
    renderer.renderableGC.addManagedHash(this, "_gpuSources");
    renderer.renderableGC.addManagedHash(this, "_gpuSamplers");
    renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
    renderer.renderableGC.addManagedHash(this, "_textureViewHash");
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  initSource(source2) {
    if (this._gpuSources[source2.uid]) {
      return this._gpuSources[source2.uid];
    }
    return this._initSource(source2);
  }
  _initSource(source2) {
    if (source2.autoGenerateMipmaps) {
      const biggestDimension = Math.max(source2.pixelWidth, source2.pixelHeight);
      source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
    }
    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    if (source2.uploadMethodId !== "compressed") {
      usage |= GPUTextureUsage.RENDER_ATTACHMENT;
      usage |= GPUTextureUsage.COPY_SRC;
    }
    const blockData = blockDataMap[source2.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
    const width = Math.ceil(source2.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
    const height = Math.ceil(source2.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
    const textureDescriptor = {
      label: source2.label,
      size: { width, height },
      format: source2.format,
      sampleCount: source2.sampleCount,
      mipLevelCount: source2.mipLevelCount,
      dimension: source2.dimension,
      usage
    };
    const gpuTexture = this._gpuSources[source2.uid] = this._gpu.device.createTexture(textureDescriptor);
    if (!this.managedTextures.includes(source2)) {
      source2.on("update", this.onSourceUpdate, this);
      source2.on("resize", this.onSourceResize, this);
      source2.on("destroy", this.onSourceDestroy, this);
      source2.on("unload", this.onSourceUnload, this);
      source2.on("updateMipmaps", this.onUpdateMipmaps, this);
      this.managedTextures.push(source2);
    }
    this.onSourceUpdate(source2);
    return gpuTexture;
  }
  onSourceUpdate(source2) {
    const gpuTexture = this.getGpuSource(source2);
    if (!gpuTexture)
      return;
    if (this._uploads[source2.uploadMethodId]) {
      this._uploads[source2.uploadMethodId].upload(source2, gpuTexture, this._gpu);
    }
    if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
      this.onUpdateMipmaps(source2);
    }
  }
  onSourceUnload(source2) {
    const gpuTexture = this._gpuSources[source2.uid];
    if (gpuTexture) {
      this._gpuSources[source2.uid] = null;
      gpuTexture.destroy();
    }
  }
  onUpdateMipmaps(source2) {
    if (!this._mipmapGenerator) {
      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
    }
    const gpuTexture = this.getGpuSource(source2);
    this._mipmapGenerator.generateMipmap(gpuTexture);
  }
  onSourceDestroy(source2) {
    source2.off("update", this.onSourceUpdate, this);
    source2.off("unload", this.onSourceUnload, this);
    source2.off("destroy", this.onSourceDestroy, this);
    source2.off("resize", this.onSourceResize, this);
    source2.off("updateMipmaps", this.onUpdateMipmaps, this);
    this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
    this.onSourceUnload(source2);
  }
  onSourceResize(source2) {
    const gpuTexture = this._gpuSources[source2.uid];
    if (!gpuTexture) {
      this.initSource(source2);
    } else if (gpuTexture.width !== source2.pixelWidth || gpuTexture.height !== source2.pixelHeight) {
      this._textureViewHash[source2.uid] = null;
      this._bindGroupHash[source2.uid] = null;
      this.onSourceUnload(source2);
      this.initSource(source2);
    }
  }
  _initSampler(sampler) {
    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
    return this._gpuSamplers[sampler._resourceId];
  }
  getGpuSampler(sampler) {
    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
  }
  getGpuSource(source2) {
    return this._gpuSources[source2.uid] || this.initSource(source2);
  }
  getTextureBindGroup(texture) {
    return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
  }
  _createTextureBindGroup(texture) {
    const source2 = texture.source;
    this._bindGroupHash[texture.uid] = new BindGroup({
      0: source2,
      1: source2.style,
      2: new UniformGroup({
        uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
      })
    });
    return this._bindGroupHash[texture.uid];
  }
  getTextureView(texture) {
    const source2 = texture.source;
    return this._textureViewHash[source2.uid] ?? this._createTextureView(source2);
  }
  _createTextureView(texture) {
    this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
    return this._textureViewHash[texture.uid];
  }
  generateCanvas(texture) {
    const renderer = this._renderer;
    const commandEncoder = renderer.gpu.device.createCommandEncoder();
    const canvas = DOMAdapter.get().createCanvas();
    canvas.width = texture.source.pixelWidth;
    canvas.height = texture.source.pixelHeight;
    const context2 = canvas.getContext("webgpu");
    context2.configure({
      device: renderer.gpu.device,
      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
      format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
      alphaMode: "premultiplied"
    });
    commandEncoder.copyTextureToTexture({
      texture: renderer.texture.getGpuSource(texture.source),
      origin: {
        x: 0,
        y: 0
      }
    }, {
      texture: context2.getCurrentTexture()
    }, {
      width: canvas.width,
      height: canvas.height
    });
    renderer.gpu.device.queue.submit([commandEncoder.finish()]);
    return canvas;
  }
  getPixels(texture) {
    const webGPUCanvas = this.generateCanvas(texture);
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
    const context2 = canvasAndContext.context;
    context2.drawImage(webGPUCanvas, 0, 0);
    const { width, height } = webGPUCanvas;
    const imageData = context2.getImageData(0, 0, width, height);
    const pixels = new Uint8ClampedArray(imageData.data.buffer);
    CanvasPool.returnCanvasAndContext(canvasAndContext);
    return { pixels, width, height };
  }
  destroy() {
    this.managedTextures.slice().forEach((source2) => this.onSourceDestroy(source2));
    this.managedTextures = null;
    for (const k2 of Object.keys(this._bindGroupHash)) {
      const key = Number(k2);
      const bindGroup = this._bindGroupHash[key];
      bindGroup?.destroy();
      this._bindGroupHash[key] = null;
    }
    this._gpu = null;
    this._mipmapGenerator = null;
    this._gpuSources = null;
    this._bindGroupHash = null;
    this._textureViewHash = null;
    this._gpuSamplers = null;
  }
}
var init_GpuTextureSystem = __esm(() => {
  init_adapter();
  init_Extensions();
  init_UniformGroup();
  init_CanvasPool();
  init_BindGroup();
  init_gpuUploadBufferImageResource();
  init_gpuUploadCompressedTextureResource();
  init_gpuUploadImageSource();
  init_gpuUploadVideoSource();
  init_GpuMipmapGenerator();
  GpuTextureSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "texture"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
var exports_WebGPURenderer = {};
__export(exports_WebGPURenderer, {
  WebGPURenderer: () => WebGPURenderer
});
var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
var init_WebGPURenderer = __esm(() => {
  init_Extensions();
  init_GpuGraphicsAdaptor();
  init_GpuMeshAdapter();
  init_GpuBatchAdaptor();
  init_AbstractRenderer();
  init_SharedSystems();
  init_types2();
  init_BindGroupSystem();
  init_GpuBufferSystem();
  init_GpuColorMaskSystem();
  init_GpuDeviceSystem();
  init_GpuEncoderSystem();
  init_GpuLimitsSystem();
  init_GpuStencilSystem();
  init_GpuUboSystem();
  init_GpuUniformBatchPipe();
  init_PipelineSystem();
  init_GpuRenderTargetSystem();
  init_GpuShaderSystem();
  init_GpuStateSystem();
  init_GpuTextureSystem();
  DefaultWebGPUSystems = [
    ...SharedSystems,
    GpuUboSystem,
    GpuEncoderSystem,
    GpuDeviceSystem,
    GpuLimitsSystem,
    GpuBufferSystem,
    GpuTextureSystem,
    GpuRenderTargetSystem,
    GpuShaderSystem,
    GpuStateSystem,
    PipelineSystem,
    GpuColorMaskSystem,
    GpuStencilSystem,
    BindGroupSystem
  ];
  DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
  DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
  systems = [];
  renderPipes = [];
  renderPipeAdaptors = [];
  extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
  extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
  extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
  extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
  WebGPURenderer = class WebGPURenderer extends AbstractRenderer {
    constructor() {
      const systemConfig = {
        name: "webgpu",
        type: RendererType.WEBGPU,
        systems,
        renderPipes,
        renderPipeAdaptors
      };
      super(systemConfig);
    }
  };
});

// node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
class GlGraphicsAdaptor {
  contextChange(renderer) {
    const uniforms = new UniformGroup({
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uTransformMatrix: { value: new Matrix, type: "mat3x3<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    const maxTextures = renderer.limits.maxBatchableTextures;
    const glProgram3 = compileHighShaderGlProgram({
      name: "graphics",
      bits: [
        colorBitGl,
        generateTextureBatchBitGl(maxTextures),
        localUniformBitGl,
        roundPixelsBitGl
      ]
    });
    this.shader = new Shader({
      glProgram: glProgram3,
      resources: {
        localUniforms: uniforms,
        batchSamplers: getBatchSamplersUniformGroup(maxTextures)
      }
    });
  }
  execute(graphicsPipe, renderable) {
    const context2 = renderable.context;
    const shader = context2.customShader || this.shader;
    const renderer = graphicsPipe.renderer;
    const contextSystem = renderer.graphicsContext;
    const {
      batcher,
      instructions
    } = contextSystem.getContextRenderData(context2);
    shader.groups[0] = renderer.globalUniforms.bindGroup;
    renderer.state.set(graphicsPipe.state);
    renderer.shader.bind(shader);
    renderer.geometry.bind(batcher.geometry, shader.glProgram);
    const batches = instructions.instructions;
    for (let i2 = 0;i2 < instructions.instructionSize; i2++) {
      const batch = batches[i2];
      if (batch.size) {
        for (let j2 = 0;j2 < batch.textures.count; j2++) {
          renderer.texture.bind(batch.textures.textures[j2], j2);
        }
        renderer.geometry.draw(batch.topology, batch.size, batch.start);
      }
    }
  }
  destroy() {
    this.shader.destroy(true);
    this.shader = null;
  }
}
var init_GlGraphicsAdaptor = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_compileHighShaderToProgram();
  init_colorBit();
  init_generateTextureBatchBit();
  init_localUniformBit();
  init_roundPixelsBit();
  init_getBatchSamplersUniformGroup();
  init_Shader();
  init_UniformGroup();
  GlGraphicsAdaptor.extension = {
    type: [
      ExtensionType.WebGLPipesAdaptor
    ],
    name: "graphics"
  };
});

// node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
class GlMeshAdaptor {
  init() {
    const glProgram3 = compileHighShaderGlProgram({
      name: "mesh",
      bits: [
        localUniformBitGl,
        textureBitGl,
        roundPixelsBitGl
      ]
    });
    this._shader = new Shader({
      glProgram: glProgram3,
      resources: {
        uTexture: Texture.EMPTY.source,
        textureUniforms: {
          uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix }
        }
      }
    });
  }
  execute(meshPipe, mesh) {
    const renderer = meshPipe.renderer;
    let shader = mesh._shader;
    if (!shader) {
      shader = this._shader;
      const texture = mesh.texture;
      const source2 = texture.source;
      shader.resources.uTexture = source2;
      shader.resources.uSampler = source2.style;
      shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
    } else if (!shader.glProgram) {
      warn("Mesh shader has no glProgram", mesh.shader);
      return;
    }
    shader.groups[100] = renderer.globalUniforms.bindGroup;
    shader.groups[101] = meshPipe.localUniformsBindGroup;
    renderer.encoder.draw({
      geometry: mesh._geometry,
      shader,
      state: mesh.state
    });
  }
  destroy() {
    this._shader.destroy(true);
    this._shader = null;
  }
}
var init_GlMeshAdaptor = __esm(() => {
  init_Extensions();
  init_Matrix();
  init_compileHighShaderToProgram();
  init_localUniformBit();
  init_roundPixelsBit();
  init_textureBit();
  init_Shader();
  init_Texture();
  init_warn();
  GlMeshAdaptor.extension = {
    type: [
      ExtensionType.WebGLPipesAdaptor
    ],
    name: "mesh"
  };
});

// node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
class GlBatchAdaptor {
  constructor() {
    this._tempState = State.for2d();
    this._didUploadHash = {};
  }
  init(batcherPipe) {
    batcherPipe.renderer.runners.contextChange.add(this);
  }
  contextChange() {
    this._didUploadHash = {};
  }
  start(batchPipe, geometry, shader) {
    const renderer = batchPipe.renderer;
    const didUpload = this._didUploadHash[shader.uid];
    renderer.shader.bind(shader, didUpload);
    if (!didUpload) {
      this._didUploadHash[shader.uid] = true;
    }
    renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
    renderer.geometry.bind(geometry, shader.glProgram);
  }
  execute(batchPipe, batch) {
    const renderer = batchPipe.renderer;
    this._tempState.blendMode = batch.blendMode;
    renderer.state.set(this._tempState);
    const textures = batch.textures.textures;
    for (let i2 = 0;i2 < batch.textures.count; i2++) {
      renderer.texture.bind(textures[i2], i2);
    }
    renderer.geometry.draw(batch.topology, batch.size, batch.start);
  }
}
var init_GlBatchAdaptor = __esm(() => {
  init_Extensions();
  init_State();
  GlBatchAdaptor.extension = {
    type: [
      ExtensionType.WebGLPipesAdaptor
    ],
    name: "batch"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
var BUFFER_TYPE;
var init_const9 = __esm(() => {
  BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
    BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    return BUFFER_TYPE2;
  })(BUFFER_TYPE || {});
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
class GlBuffer {
  constructor(buffer, type) {
    this._lastBindBaseLocation = -1;
    this._lastBindCallId = -1;
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.type = type;
  }
}
var init_GlBuffer = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
class GlBufferSystem {
  constructor(renderer) {
    this._gpuBuffers = /* @__PURE__ */ Object.create(null);
    this._boundBufferBases = /* @__PURE__ */ Object.create(null);
    this._minBaseLocation = 0;
    this._nextBindBaseIndex = this._minBaseLocation;
    this._bindCallId = 0;
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
  }
  destroy() {
    this._renderer = null;
    this._gl = null;
    this._gpuBuffers = null;
    this._boundBufferBases = null;
  }
  contextChange() {
    this._gl = this._renderer.gl;
    this._gpuBuffers = /* @__PURE__ */ Object.create(null);
    this._maxBindings = this._renderer.limits.maxUniformBindings;
  }
  getGlBuffer(buffer) {
    return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
  }
  bind(buffer) {
    const { _gl: gl } = this;
    const glBuffer = this.getGlBuffer(buffer);
    gl.bindBuffer(glBuffer.type, glBuffer.buffer);
  }
  bindBufferBase(glBuffer, index) {
    const { _gl: gl } = this;
    if (this._boundBufferBases[index] !== glBuffer) {
      this._boundBufferBases[index] = glBuffer;
      glBuffer._lastBindBaseLocation = index;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  nextBindBase(hasTransformFeedback) {
    this._bindCallId++;
    this._minBaseLocation = 0;
    if (hasTransformFeedback) {
      this._boundBufferBases[0] = null;
      this._minBaseLocation = 1;
      if (this._nextBindBaseIndex < 1) {
        this._nextBindBaseIndex = 1;
      }
    }
  }
  freeLocationForBufferBase(glBuffer) {
    let freeIndex = this.getLastBindBaseLocation(glBuffer);
    if (freeIndex >= this._minBaseLocation) {
      glBuffer._lastBindCallId = this._bindCallId;
      return freeIndex;
    }
    let loop = 0;
    let nextIndex = this._nextBindBaseIndex;
    while (loop < 2) {
      if (nextIndex >= this._maxBindings) {
        nextIndex = this._minBaseLocation;
        loop++;
      }
      const curBuf = this._boundBufferBases[nextIndex];
      if (curBuf && curBuf._lastBindCallId === this._bindCallId) {
        nextIndex++;
        continue;
      }
      break;
    }
    freeIndex = nextIndex;
    this._nextBindBaseIndex = nextIndex + 1;
    if (loop >= 2) {
      return -1;
    }
    glBuffer._lastBindCallId = this._bindCallId;
    this._boundBufferBases[freeIndex] = null;
    return freeIndex;
  }
  getLastBindBaseLocation(glBuffer) {
    const index = glBuffer._lastBindBaseLocation;
    if (this._boundBufferBases[index] === glBuffer) {
      return index;
    }
    return -1;
  }
  bindBufferRange(glBuffer, index, offset, size) {
    const { _gl: gl } = this;
    offset || (offset = 0);
    index || (index = 0);
    this._boundBufferBases[index] = null;
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);
  }
  updateBuffer(buffer) {
    const { _gl: gl } = this;
    const glBuffer = this.getGlBuffer(buffer);
    if (buffer._updateID === glBuffer.updateID) {
      return glBuffer;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(glBuffer.type, glBuffer.buffer);
    const data = buffer.data;
    const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
    if (data) {
      if (glBuffer.byteLength >= data.byteLength) {
        gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
      } else {
        glBuffer.byteLength = data.byteLength;
        gl.bufferData(glBuffer.type, data, drawType);
      }
    } else {
      glBuffer.byteLength = buffer.descriptor.size;
      gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);
    }
    return glBuffer;
  }
  destroyAll() {
    const gl = this._gl;
    for (const id in this._gpuBuffers) {
      gl.deleteBuffer(this._gpuBuffers[id].buffer);
    }
    this._gpuBuffers = /* @__PURE__ */ Object.create(null);
  }
  onBufferDestroy(buffer, contextLost) {
    const glBuffer = this._gpuBuffers[buffer.uid];
    const gl = this._gl;
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    this._gpuBuffers[buffer.uid] = null;
  }
  createGLBuffer(buffer) {
    const { _gl: gl } = this;
    let type = BUFFER_TYPE.ARRAY_BUFFER;
    if (buffer.descriptor.usage & BufferUsage.INDEX) {
      type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
      type = BUFFER_TYPE.UNIFORM_BUFFER;
    }
    const glBuffer = new GlBuffer(gl.createBuffer(), type);
    this._gpuBuffers[buffer.uid] = glBuffer;
    buffer.on("destroy", this.onBufferDestroy, this);
    return glBuffer;
  }
  resetState() {
    this._boundBufferBases = /* @__PURE__ */ Object.create(null);
  }
}
var init_GlBufferSystem = __esm(() => {
  init_Extensions();
  init_const4();
  init_const9();
  init_GlBuffer();
  GlBufferSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "buffer"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
var _GlContextSystem = class _GlContextSystem2 {
  constructor(renderer) {
    this.supports = {
      uint32Indices: true,
      uniformBufferObject: true,
      vertexArrayObject: true,
      srgbTextures: true,
      nonPowOf2wrapping: true,
      msaa: true,
      nonPowOf2mipmaps: true
    };
    this._renderer = renderer;
    this.extensions = /* @__PURE__ */ Object.create(null);
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  contextChange(gl) {
    this.gl = gl;
    this._renderer.gl = gl;
  }
  init(options) {
    options = { ..._GlContextSystem2.defaultOptions, ...options };
    let multiView = this.multiView = options.multiView;
    if (options.context && multiView) {
      warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
      multiView = false;
    }
    if (multiView) {
      this.canvas = DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
    } else {
      this.canvas = this._renderer.view.canvas;
    }
    if (options.context) {
      this.initFromContext(options.context);
    } else {
      const alpha = this._renderer.background.alpha < 1;
      const premultipliedAlpha = options.premultipliedAlpha ?? true;
      const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
      this.createContext(options.preferWebGLVersion, {
        alpha,
        premultipliedAlpha,
        antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference ?? "default"
      });
    }
  }
  ensureCanvasSize(targetCanvas) {
    if (!this.multiView) {
      if (targetCanvas !== this.canvas) {
        warn("multiView is disabled, but targetCanvas is not the main canvas");
      }
      return;
    }
    const { canvas } = this;
    if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
      canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
      canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
    }
  }
  initFromContext(gl) {
    this.gl = gl;
    this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
    this.getExtensions();
    this.validateContext(gl);
    this._renderer.runners.contextChange.emit(gl);
    const element = this._renderer.view.canvas;
    element.addEventListener("webglcontextlost", this.handleContextLost, false);
    element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
  }
  createContext(preferWebGLVersion, options) {
    let gl;
    const canvas = this.canvas;
    if (preferWebGLVersion === 2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (!gl) {
      gl = canvas.getContext("webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.initFromContext(this.gl);
  }
  getExtensions() {
    const { gl } = this;
    const common = {
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc"),
      bptc: gl.getExtension("EXT_texture_compression_bptc"),
      rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
      loseContext: gl.getExtension("WEBGL_lose_context")
    };
    if (this.webGLVersion === 1) {
      this.extensions = {
        ...common,
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
        vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
        srgb: gl.getExtension("EXT_sRGB")
      };
    } else {
      this.extensions = {
        ...common,
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      };
      const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
      if (provokeExt) {
        provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
      }
    }
  }
  handleContextLost(event) {
    event.preventDefault();
    if (this._contextLossForced) {
      this._contextLossForced = false;
      setTimeout(() => {
        if (this.gl.isContextLost()) {
          this.extensions.loseContext?.restoreContext();
        }
      }, 0);
    }
  }
  handleContextRestored() {
    this.getExtensions();
    this._renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const element = this._renderer.view.canvas;
    this._renderer = null;
    element.removeEventListener("webglcontextlost", this.handleContextLost);
    element.removeEventListener("webglcontextrestored", this.handleContextRestored);
    this.gl.useProgram(null);
    this.extensions.loseContext?.loseContext();
  }
  forceContextLoss() {
    this.extensions.loseContext?.loseContext();
    this._contextLossForced = true;
  }
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    if (attributes && !attributes.stencil) {
      warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const supports = this.supports;
    const isWebGl2 = this.webGLVersion === 2;
    const extensions2 = this.extensions;
    supports.uint32Indices = isWebGl2 || !!extensions2.uint32ElementIndex;
    supports.uniformBufferObject = isWebGl2;
    supports.vertexArrayObject = isWebGl2 || !!extensions2.vertexArrayObject;
    supports.srgbTextures = isWebGl2 || !!extensions2.srgb;
    supports.nonPowOf2wrapping = isWebGl2;
    supports.nonPowOf2mipmaps = isWebGl2;
    supports.msaa = isWebGl2;
    if (!supports.uint32Indices) {
      warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
    }
  }
}, GlContextSystem;
var init_GlContextSystem = __esm(() => {
  init_adapter();
  init_Extensions();
  init_warn();
  _GlContextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "context"
  };
  _GlContextSystem.defaultOptions = {
    context: null,
    premultipliedAlpha: true,
    preserveDrawingBuffer: false,
    powerPreference: undefined,
    preferWebGLVersion: 2,
    multiView: false
  };
  GlContextSystem = _GlContextSystem;
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
var GL_FORMATS, GL_TARGETS, GL_TYPES;
var init_const10 = __esm(() => {
  GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
    GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
    GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
    GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
    GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
    GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
    GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
    GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    return GL_FORMATS2;
  })(GL_FORMATS || {});
  GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
    GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    return GL_TARGETS2;
  })(GL_TARGETS || {});
  GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
    GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
    GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
    GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
    GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
    GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    return GL_TYPES2;
  })(GL_TYPES || {});
});

// node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
function getGlTypeFromFormat(format) {
  return infoMap[format] ?? infoMap.float32;
}
var infoMap;
var init_getGlTypeFromFormat = __esm(() => {
  init_const10();
  infoMap = {
    uint8x2: GL_TYPES.UNSIGNED_BYTE,
    uint8x4: GL_TYPES.UNSIGNED_BYTE,
    sint8x2: GL_TYPES.BYTE,
    sint8x4: GL_TYPES.BYTE,
    unorm8x2: GL_TYPES.UNSIGNED_BYTE,
    unorm8x4: GL_TYPES.UNSIGNED_BYTE,
    snorm8x2: GL_TYPES.BYTE,
    snorm8x4: GL_TYPES.BYTE,
    uint16x2: GL_TYPES.UNSIGNED_SHORT,
    uint16x4: GL_TYPES.UNSIGNED_SHORT,
    sint16x2: GL_TYPES.SHORT,
    sint16x4: GL_TYPES.SHORT,
    unorm16x2: GL_TYPES.UNSIGNED_SHORT,
    unorm16x4: GL_TYPES.UNSIGNED_SHORT,
    snorm16x2: GL_TYPES.SHORT,
    snorm16x4: GL_TYPES.SHORT,
    float16x2: GL_TYPES.HALF_FLOAT,
    float16x4: GL_TYPES.HALF_FLOAT,
    float32: GL_TYPES.FLOAT,
    float32x2: GL_TYPES.FLOAT,
    float32x3: GL_TYPES.FLOAT,
    float32x4: GL_TYPES.FLOAT,
    uint32: GL_TYPES.UNSIGNED_INT,
    uint32x2: GL_TYPES.UNSIGNED_INT,
    uint32x3: GL_TYPES.UNSIGNED_INT,
    uint32x4: GL_TYPES.UNSIGNED_INT,
    sint32: GL_TYPES.INT,
    sint32x2: GL_TYPES.INT,
    sint32x3: GL_TYPES.INT,
    sint32x4: GL_TYPES.INT
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
class GlGeometrySystem {
  constructor(renderer) {
    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
  }
  contextChange() {
    const gl = this.gl = this._renderer.gl;
    if (!this._renderer.context.supports.vertexArrayObject) {
      throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
    }
    const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
    if (nativeVaoExtension) {
      gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
      gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
      gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
    }
    const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
    if (nativeInstancedExtension) {
      gl.drawArraysInstanced = (a2, b2, c2, d2) => {
        nativeInstancedExtension.drawArraysInstancedANGLE(a2, b2, c2, d2);
      };
      gl.drawElementsInstanced = (a2, b2, c2, d2, e2) => {
        nativeInstancedExtension.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
      };
      gl.vertexAttribDivisor = (a2, b2) => nativeInstancedExtension.vertexAttribDivisorANGLE(a2, b2);
    }
    this._activeGeometry = null;
    this._activeVao = null;
    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
  }
  bind(geometry, program) {
    const gl = this.gl;
    this._activeGeometry = geometry;
    const vao = this.getVao(geometry, program);
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      gl.bindVertexArray(vao);
    }
    this.updateBuffers();
  }
  resetState() {
    this.unbind();
  }
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this._renderer.buffer;
    for (let i2 = 0;i2 < geometry.buffers.length; i2++) {
      const buffer = geometry.buffers[i2];
      bufferSystem.updateBuffer(buffer);
    }
  }
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program._attributeData;
    for (const j2 in shaderAttributes) {
      if (!geometryAttributes[j2]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
      }
    }
  }
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program._attributeData;
    const strings = ["g", geometry.uid];
    for (const i2 in attribs) {
      if (shaderAttributes[i2]) {
        strings.push(i2, shaderAttributes[i2].location);
      }
    }
    return strings.join("-");
  }
  getVao(geometry, program) {
    return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
  }
  initGeometryVao(geometry, program, _incRefCount = true) {
    const gl = this._renderer.gl;
    const bufferSystem = this._renderer.buffer;
    this._renderer.shader._getProgramData(program);
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    if (!this._geometryVaoHash[geometry.uid]) {
      this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
      geometry.on("destroy", this.onGeometryDestroy, this);
    }
    const vaoObjectHash = this._geometryVaoHash[geometry.uid];
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program._key] = vao;
      return vao;
    }
    ensureAttributes(geometry, program._attributeData);
    const buffers = geometry.buffers;
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i2 = 0;i2 < buffers.length; i2++) {
      const buffer = buffers[i2];
      bufferSystem.bind(buffer);
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program._key] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    return vao;
  }
  onGeometryDestroy(geometry, contextLost) {
    const vaoObjectHash = this._geometryVaoHash[geometry.uid];
    const gl = this.gl;
    if (vaoObjectHash) {
      if (contextLost) {
        for (const i2 in vaoObjectHash) {
          if (this._activeVao !== vaoObjectHash[i2]) {
            this.unbind();
          }
          gl.deleteVertexArray(vaoObjectHash[i2]);
        }
      }
      this._geometryVaoHash[geometry.uid] = null;
    }
  }
  destroyAll(contextLost = false) {
    const gl = this.gl;
    for (const i2 in this._geometryVaoHash) {
      if (contextLost) {
        for (const j2 in this._geometryVaoHash[i2]) {
          const vaoObjectHash = this._geometryVaoHash[i2];
          if (this._activeVao !== vaoObjectHash) {
            this.unbind();
          }
          gl.deleteVertexArray(vaoObjectHash[j2]);
        }
      }
      this._geometryVaoHash[i2] = null;
    }
  }
  activateVao(geometry, program) {
    const gl = this._renderer.gl;
    const bufferSystem = this._renderer.buffer;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      const buffer = attribute.buffer;
      const glBuffer = bufferSystem.getGlBuffer(buffer);
      const programAttrib = program._attributeData[j2];
      if (programAttrib) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        const location2 = programAttrib.location;
        gl.enableVertexAttribArray(location2);
        const attributeInfo = getAttributeInfoFromFormat(attribute.format);
        const type = getGlTypeFromFormat(attribute.format);
        if (programAttrib.format?.substring(1, 4) === "int") {
          gl.vertexAttribIPointer(location2, attributeInfo.size, type, attribute.stride, attribute.offset);
        } else {
          gl.vertexAttribPointer(location2, attributeInfo.size, type, attributeInfo.normalised, attribute.stride, attribute.offset);
        }
        if (attribute.instance) {
          if (this.hasInstance) {
            const divisor = attribute.divisor ?? 1;
            gl.vertexAttribDivisor(location2, divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  draw(topology, size, start, instanceCount) {
    const { gl } = this._renderer;
    const geometry = this._activeGeometry;
    const glTopology = topologyToGlMap[topology || geometry.topology];
    instanceCount ?? (instanceCount = geometry.instanceCount);
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (instanceCount > 1) {
        gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
      } else {
        gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
      }
    } else if (instanceCount > 1) {
      gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
    } else {
      gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
    }
    return this;
  }
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this._renderer = null;
    this.gl = null;
    this._activeVao = null;
    this._activeGeometry = null;
    this._geometryVaoHash = null;
  }
}
var topologyToGlMap;
var init_GlGeometrySystem = __esm(() => {
  init_Extensions();
  init_getAttributeInfoFromFormat();
  init_ensureAttributes();
  init_getGlTypeFromFormat();
  topologyToGlMap = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 3,
    "triangle-list": 4,
    "triangle-strip": 5
  };
  GlGeometrySystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "geometry"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
var bigTriangleGeometry, _GlBackBufferSystem = class _GlBackBufferSystem2 {
  constructor(renderer) {
    this.useBackBuffer = false;
    this._useBackBufferThisRender = false;
    this._renderer = renderer;
  }
  init(options = {}) {
    const { useBackBuffer, antialias } = { ..._GlBackBufferSystem2.defaultOptions, ...options };
    this.useBackBuffer = useBackBuffer;
    this._antialias = antialias;
    if (!this._renderer.context.supports.msaa) {
      warn("antialiasing, is not supported on when using the back buffer");
      this._antialias = false;
    }
    this._state = State.for2d();
    const bigTriangleProgram = new GlProgram({
      vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
      fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
      name: "big-triangle"
    });
    this._bigTriangleShader = new Shader({
      glProgram: bigTriangleProgram,
      resources: {
        uTexture: Texture.WHITE.source
      }
    });
  }
  renderStart(options) {
    const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
    this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
    if (this._useBackBufferThisRender) {
      const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
      this._targetTexture = renderTarget2.colorTexture;
      options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
    }
  }
  renderEnd() {
    this._presentBackBuffer();
  }
  _presentBackBuffer() {
    const renderer = this._renderer;
    renderer.renderTarget.finishRenderPass();
    if (!this._useBackBufferThisRender)
      return;
    renderer.renderTarget.bind(this._targetTexture, false);
    this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
    renderer.encoder.draw({
      geometry: bigTriangleGeometry,
      shader: this._bigTriangleShader,
      state: this._state
    });
  }
  _getBackBufferTexture(targetSourceTexture) {
    this._backBufferTexture = this._backBufferTexture || new Texture({
      source: new TextureSource({
        width: targetSourceTexture.width,
        height: targetSourceTexture.height,
        resolution: targetSourceTexture._resolution,
        antialias: this._antialias
      })
    });
    this._backBufferTexture.source.resize(targetSourceTexture.width, targetSourceTexture.height, targetSourceTexture._resolution);
    return this._backBufferTexture;
  }
  destroy() {
    if (this._backBufferTexture) {
      this._backBufferTexture.destroy();
      this._backBufferTexture = null;
    }
  }
}, GlBackBufferSystem;
var init_GlBackBufferSystem = __esm(() => {
  init_Extensions();
  init_warn();
  init_Geometry();
  init_Shader();
  init_State();
  init_TextureSource();
  init_Texture();
  init_GlProgram();
  bigTriangleGeometry = new Geometry({
    attributes: {
      aPosition: [
        -1,
        -1,
        3,
        -1,
        -1,
        3
      ]
    }
  });
  _GlBackBufferSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "backBuffer",
    priority: 1
  };
  _GlBackBufferSystem.defaultOptions = {
    useBackBuffer: false
  };
  GlBackBufferSystem = _GlBackBufferSystem;
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
class GlColorMaskSystem {
  constructor(renderer) {
    this._colorMaskCache = 15;
    this._renderer = renderer;
  }
  setMask(colorMask) {
    if (this._colorMaskCache === colorMask)
      return;
    this._colorMaskCache = colorMask;
    this._renderer.gl.colorMask(!!(colorMask & 8), !!(colorMask & 4), !!(colorMask & 2), !!(colorMask & 1));
  }
}
var init_GlColorMaskSystem = __esm(() => {
  init_Extensions();
  GlColorMaskSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "colorMask"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
class GlEncoderSystem {
  constructor(renderer) {
    this.commandFinished = Promise.resolve();
    this._renderer = renderer;
  }
  setGeometry(geometry, shader) {
    this._renderer.geometry.bind(geometry, shader.glProgram);
  }
  finishRenderPass() {}
  draw(options) {
    const renderer = this._renderer;
    const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;
    renderer.shader.bind(shader, skipSync);
    renderer.geometry.bind(geometry, renderer.shader._activeProgram);
    if (state) {
      renderer.state.set(state);
    }
    renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);
  }
  destroy() {
    this._renderer = null;
  }
}
var init_GlEncoderSystem = __esm(() => {
  init_Extensions();
  GlEncoderSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "encoder"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.mjs
class GlLimitsSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  contextChange() {
    const gl = this._renderer.gl;
    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.maxBatchableTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
    const isWebGl2 = this._renderer.context.webGLVersion === 2;
    this.maxUniformBindings = isWebGl2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  }
  destroy() {}
}
var init_GlLimitsSystem = __esm(() => {
  init_Extensions();
  init_checkMaxIfStatementsInShader();
  GlLimitsSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "limits"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
class GlStencilSystem {
  constructor(renderer) {
    this._stencilCache = {
      enabled: false,
      stencilReference: 0,
      stencilMode: STENCIL_MODES.NONE
    };
    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
    renderer.renderTarget.onRenderTargetChange.add(this);
  }
  contextChange(gl) {
    this._gl = gl;
    this._comparisonFuncMapping = {
      always: gl.ALWAYS,
      never: gl.NEVER,
      equal: gl.EQUAL,
      "not-equal": gl.NOTEQUAL,
      less: gl.LESS,
      "less-equal": gl.LEQUAL,
      greater: gl.GREATER,
      "greater-equal": gl.GEQUAL
    };
    this._stencilOpsMapping = {
      keep: gl.KEEP,
      zero: gl.ZERO,
      replace: gl.REPLACE,
      invert: gl.INVERT,
      "increment-clamp": gl.INCR,
      "decrement-clamp": gl.DECR,
      "increment-wrap": gl.INCR_WRAP,
      "decrement-wrap": gl.DECR_WRAP
    };
    this.resetState();
  }
  onRenderTargetChange(renderTarget) {
    if (this._activeRenderTarget === renderTarget)
      return;
    this._activeRenderTarget = renderTarget;
    let stencilState = this._renderTargetStencilState[renderTarget.uid];
    if (!stencilState) {
      stencilState = this._renderTargetStencilState[renderTarget.uid] = {
        stencilMode: STENCIL_MODES.DISABLED,
        stencilReference: 0
      };
    }
    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
  }
  resetState() {
    this._stencilCache.enabled = false;
    this._stencilCache.stencilMode = STENCIL_MODES.NONE;
    this._stencilCache.stencilReference = 0;
  }
  setStencilMode(stencilMode, stencilReference) {
    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
    const gl = this._gl;
    const mode = GpuStencilModesToPixi[stencilMode];
    const _stencilCache = this._stencilCache;
    stencilState.stencilMode = stencilMode;
    stencilState.stencilReference = stencilReference;
    if (stencilMode === STENCIL_MODES.DISABLED) {
      if (this._stencilCache.enabled) {
        this._stencilCache.enabled = false;
        gl.disable(gl.STENCIL_TEST);
      }
      return;
    }
    if (!this._stencilCache.enabled) {
      this._stencilCache.enabled = true;
      gl.enable(gl.STENCIL_TEST);
    }
    if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
      _stencilCache.stencilMode = stencilMode;
      _stencilCache.stencilReference = stencilReference;
      gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
      gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
    }
  }
}
var init_GlStencilSystem = __esm(() => {
  init_Extensions();
  init_GpuStencilModesToPixi();
  init_const3();
  GlStencilSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "stencil"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
function createUboElementsSTD40(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  const chunkSize = 16;
  let size = 0;
  let offset = 0;
  for (let i2 = 0;i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    size = WGSL_TO_STD40_SIZE[uboElement.data.type];
    if (!size) {
      throw new Error(`Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, chunkSize) * uboElement.data.size;
    }
    const boundary = size === 12 ? 16 : size;
    uboElement.size = size;
    const curOffset = offset % chunkSize;
    if (curOffset > 0 && chunkSize - curOffset < boundary) {
      offset += (chunkSize - curOffset) % 16;
    } else {
      offset += (size - curOffset % size) % size;
    }
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_TO_STD40_SIZE;
var init_createUboElementsSTD40 = __esm(() => {
  WGSL_TO_STD40_SIZE = {
    f32: 4,
    i32: 4,
    "vec2<f32>": 8,
    "vec3<f32>": 12,
    "vec4<f32>": 16,
    "vec2<i32>": 8,
    "vec3<i32>": 12,
    "vec4<i32>": 16,
    "mat2x2<f32>": 16 * 2,
    "mat3x3<f32>": 16 * 3,
    "mat4x4<f32>": 16 * 4
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
function generateArraySyncSTD40(uboElement, offsetToAdd) {
  const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
  const elementSize = uboElement.data.value.length / uboElement.data.size;
  const remainder = (4 - elementSize % 4) % 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                ${data}[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
}
var init_generateArraySyncSTD40 = __esm(() => {
  init_createUboElementsSTD40();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
function createUboSyncFunctionSTD40(uboElements) {
  return createUboSyncFunction(uboElements, "uboStd40", generateArraySyncSTD40, uboSyncFunctionsSTD40);
}
var init_createUboSyncSTD40 = __esm(() => {
  init_createUboSyncFunction();
  init_uboSyncFunctions();
  init_generateArraySyncSTD40();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs
var GlUboSystem;
var init_GlUboSystem = __esm(() => {
  init_Extensions();
  init_UboSystem();
  init_createUboElementsSTD40();
  init_createUboSyncSTD40();
  GlUboSystem = class GlUboSystem extends UboSystem {
    constructor() {
      super({
        createUboElements: createUboElementsSTD40,
        generateUboSync: createUboSyncFunctionSTD40
      });
    }
  };
  GlUboSystem.extension = {
    type: [ExtensionType.WebGLSystem],
    name: "ubo"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
class GlRenderTarget {
  constructor() {
    this.width = -1;
    this.height = -1;
    this.msaa = false;
    this.msaaRenderBuffer = [];
  }
}
var init_GlRenderTarget = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
class GlRenderTargetAdaptor {
  constructor() {
    this._clearColorCache = [0, 0, 0, 0];
    this._viewPortCache = new Rectangle;
  }
  init(renderer, renderTargetSystem) {
    this._renderer = renderer;
    this._renderTargetSystem = renderTargetSystem;
    renderer.runners.contextChange.add(this);
  }
  contextChange() {
    this._clearColorCache = [0, 0, 0, 0];
    this._viewPortCache = new Rectangle;
  }
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    const renderTargetSystem = this._renderTargetSystem;
    const renderer = this._renderer;
    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
    const gl = renderer.gl;
    this.finishRenderPass(sourceRenderSurfaceTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
    renderer.texture.bind(destinationTexture, 0);
    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, originDest.x, originDest.y, originSrc.x, originSrc.y, size.width, size.height);
    return destinationTexture;
  }
  startRenderPass(renderTarget, clear = true, clearColor, viewport) {
    const renderTargetSystem = this._renderTargetSystem;
    const source2 = renderTarget.colorTexture;
    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    let viewPortY = viewport.y;
    if (renderTarget.isRoot) {
      viewPortY = source2.pixelHeight - viewport.height;
    }
    renderTarget.colorTextures.forEach((texture) => {
      this._renderer.texture.unbind(texture);
    });
    const gl = this._renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
    const viewPortCache = this._viewPortCache;
    if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
      viewPortCache.x = viewport.x;
      viewPortCache.y = viewPortY;
      viewPortCache.width = viewport.width;
      viewPortCache.height = viewport.height;
      gl.viewport(viewport.x, viewPortY, viewport.width, viewport.height);
    }
    if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
      this._initStencil(gpuRenderTarget);
    }
    this.clear(renderTarget, clear, clearColor);
  }
  finishRenderPass(renderTarget) {
    const renderTargetSystem = this._renderTargetSystem;
    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (!glRenderTarget.msaa)
      return;
    const gl = this._renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
    gl.blitFramebuffer(0, 0, glRenderTarget.width, glRenderTarget.height, 0, 0, glRenderTarget.width, glRenderTarget.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
  }
  initGpuRenderTarget(renderTarget) {
    const renderer = this._renderer;
    const gl = renderer.gl;
    const glRenderTarget = new GlRenderTarget;
    const colorTexture = renderTarget.colorTexture;
    if (colorTexture instanceof CanvasSource) {
      this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
      glRenderTarget.framebuffer = null;
      return glRenderTarget;
    }
    this._initColor(renderTarget, glRenderTarget);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return glRenderTarget;
  }
  destroyGpuRenderTarget(gpuRenderTarget) {
    const gl = this._renderer.gl;
    if (gpuRenderTarget.framebuffer) {
      gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
      gpuRenderTarget.framebuffer = null;
    }
    if (gpuRenderTarget.resolveTargetFramebuffer) {
      gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
      gpuRenderTarget.resolveTargetFramebuffer = null;
    }
    if (gpuRenderTarget.depthStencilRenderBuffer) {
      gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
      gpuRenderTarget.depthStencilRenderBuffer = null;
    }
    gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
      gl.deleteRenderbuffer(renderBuffer);
    });
    gpuRenderTarget.msaaRenderBuffer = null;
  }
  clear(_renderTarget, clear, clearColor) {
    if (!clear)
      return;
    const renderTargetSystem = this._renderTargetSystem;
    if (typeof clear === "boolean") {
      clear = clear ? CLEAR.ALL : CLEAR.NONE;
    }
    const gl = this._renderer.gl;
    if (clear & CLEAR.COLOR) {
      clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
      const clearColorCache = this._clearColorCache;
      const clearColorArray = clearColor;
      if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
        clearColorCache[0] = clearColorArray[0];
        clearColorCache[1] = clearColorArray[1];
        clearColorCache[2] = clearColorArray[2];
        clearColorCache[3] = clearColorArray[3];
        gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
      }
    }
    gl.clear(clear);
  }
  resizeGpuRenderTarget(renderTarget) {
    if (renderTarget.isRoot)
      return;
    const renderTargetSystem = this._renderTargetSystem;
    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    this._resizeColor(renderTarget, glRenderTarget);
    if (renderTarget.stencil || renderTarget.depth) {
      this._resizeStencil(glRenderTarget);
    }
  }
  _initColor(renderTarget, glRenderTarget) {
    const renderer = this._renderer;
    const gl = renderer.gl;
    const resolveTargetFramebuffer = gl.createFramebuffer();
    glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
    glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
    glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
    renderTarget.colorTextures.forEach((colorTexture, i2) => {
      const source2 = colorTexture.source;
      if (source2.antialias) {
        if (renderer.context.supports.msaa) {
          glRenderTarget.msaa = true;
        } else {
          warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
        }
      }
      renderer.texture.bindSource(source2, 0);
      const glSource = renderer.texture.getGlSource(source2);
      const glTexture = glSource.texture;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, 3553, glTexture, 0);
    });
    if (glRenderTarget.msaa) {
      const viewFramebuffer = gl.createFramebuffer();
      glRenderTarget.framebuffer = viewFramebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
      renderTarget.colorTextures.forEach((_, i2) => {
        const msaaRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.msaaRenderBuffer[i2] = msaaRenderBuffer;
      });
    } else {
      glRenderTarget.framebuffer = resolveTargetFramebuffer;
    }
    this._resizeColor(renderTarget, glRenderTarget);
  }
  _resizeColor(renderTarget, glRenderTarget) {
    const source2 = renderTarget.colorTexture.source;
    glRenderTarget.width = source2.pixelWidth;
    glRenderTarget.height = source2.pixelHeight;
    renderTarget.colorTextures.forEach((colorTexture, i2) => {
      if (i2 === 0)
        return;
      colorTexture.source.resize(source2.width, source2.height, source2._resolution);
    });
    if (glRenderTarget.msaa) {
      const renderer = this._renderer;
      const gl = renderer.gl;
      const viewFramebuffer = glRenderTarget.framebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
      renderTarget.colorTextures.forEach((colorTexture, i2) => {
        const source22 = colorTexture.source;
        renderer.texture.bindSource(source22, 0);
        const glSource = renderer.texture.getGlSource(source22);
        const glInternalFormat = glSource.internalFormat;
        const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i2];
        gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, glInternalFormat, source22.pixelWidth, source22.pixelHeight);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, gl.RENDERBUFFER, msaaRenderBuffer);
      });
    }
  }
  _initStencil(glRenderTarget) {
    if (glRenderTarget.framebuffer === null)
      return;
    const gl = this._renderer.gl;
    const depthStencilRenderBuffer = gl.createRenderbuffer();
    glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
    gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilRenderBuffer);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilRenderBuffer);
    this._resizeStencil(glRenderTarget);
  }
  _resizeStencil(glRenderTarget) {
    const gl = this._renderer.gl;
    gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderTarget.depthStencilRenderBuffer);
    if (glRenderTarget.msaa) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.DEPTH24_STENCIL8, glRenderTarget.width, glRenderTarget.height);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL, glRenderTarget.width, glRenderTarget.height);
    }
  }
  prerender(renderTarget) {
    const resource = renderTarget.colorTexture.resource;
    if (this._renderer.context.multiView && CanvasSource.test(resource)) {
      this._renderer.context.ensureCanvasSize(resource);
    }
  }
  postrender(renderTarget) {
    if (!this._renderer.context.multiView)
      return;
    if (CanvasSource.test(renderTarget.colorTexture.resource)) {
      const contextCanvas = this._renderer.context.canvas;
      const canvasSource = renderTarget.colorTexture;
      canvasSource.context2D.drawImage(contextCanvas, 0, canvasSource.pixelHeight - contextCanvas.height);
    }
  }
}
var init_GlRenderTargetAdaptor = __esm(() => {
  init_Rectangle();
  init_warn();
  init_CanvasSource();
  init_const7();
  init_GlRenderTarget();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
var GlRenderTargetSystem;
var init_GlRenderTargetSystem = __esm(() => {
  init_Extensions();
  init_RenderTargetSystem();
  init_GlRenderTargetAdaptor();
  GlRenderTargetSystem = class GlRenderTargetSystem extends RenderTargetSystem {
    constructor(renderer) {
      super(renderer);
      this.adaptor = new GlRenderTargetAdaptor;
      this.adaptor.init(renderer, this);
    }
  };
  GlRenderTargetSystem.extension = {
    type: [ExtensionType.WebGLSystem],
    name: "renderTarget"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
function generateShaderSyncCode(shader, shaderSystem) {
  const funcFragments = [];
  const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
  let addedTextreSystem = false;
  let textureCount = 0;
  const programData = shaderSystem._getProgramData(shader.glProgram);
  for (const i2 in shader.groups) {
    const group = shader.groups[i2];
    funcFragments.push(`
            resources = g[${i2}].resources;
        `);
    for (const j2 in group.resources) {
      const resource = group.resources[j2];
      if (resource instanceof UniformGroup) {
        if (resource.ubo) {
          const resName = shader._uniformBindMap[i2][Number(j2)];
          funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j2}],
                            '${resName}',
                            ${shader.glProgram._uniformBlockData[resName].index}
                        );
                    `);
        } else {
          funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j2}], p, sD);
                    `);
        }
      } else if (resource instanceof BufferResource) {
        const resName = shader._uniformBindMap[i2][Number(j2)];
        funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j2}],
                        '${resName}',
                        ${shader.glProgram._uniformBlockData[resName].index}
                    );
                `);
      } else if (resource instanceof TextureSource) {
        const uniformName = shader._uniformBindMap[i2][j2];
        const uniformData = programData.uniformData[uniformName];
        if (uniformData) {
          if (!addedTextreSystem) {
            addedTextreSystem = true;
            headerFragments.push(`
                        var tS = r.texture;
                        `);
          }
          shaderSystem._gl.uniform1i(uniformData.location, textureCount);
          funcFragments.push(`
                        tS.bind(resources[${j2}], ${textureCount});
                    `);
          textureCount++;
        }
      }
    }
  }
  const functionSource = [...headerFragments, ...funcFragments].join(`
`);
  return new Function("r", "s", "sD", functionSource);
}
var init_GenerateShaderSyncCode = __esm(() => {
  init_BufferResource();
  init_UniformGroup();
  init_TextureSource();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
class GlProgramData {
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBlockBindings = {};
  }
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBlockBindings = null;
    this.program = null;
  }
}
var init_GlProgramData = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
var init_compileShader = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
function booleanArray(size) {
  const array = new Array(size);
  for (let i2 = 0;i2 < array.length; i2++) {
    array[i2] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultValue = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i2 = 0;i2 < typeNames.length; ++i2) {
      const tn = typeNames[i2];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
function mapGlToVertexFormat(gl, type) {
  const typeValue = mapType(gl, type);
  return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
}
var GL_TABLE = null, GL_TO_GLSL_TYPES, GLSL_TO_VERTEX_TYPES;
var init_mapType = __esm(() => {
  GL_TO_GLSL_TYPES = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
  };
  GLSL_TO_VERTEX_TYPES = {
    float: "float32",
    vec2: "float32x2",
    vec3: "float32x3",
    vec4: "float32x4",
    int: "sint32",
    ivec2: "sint32x2",
    ivec3: "sint32x3",
    ivec4: "sint32x4",
    uint: "uint32",
    uvec2: "uint32x2",
    uvec3: "uint32x3",
    uvec4: "uint32x4",
    bool: "uint32",
    bvec2: "uint32x2",
    bvec3: "uint32x3",
    bvec4: "uint32x4"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0;i2 < totalAttributes; i2++) {
    const attribData = gl.getActiveAttrib(program, i2);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const format = mapGlToVertexFormat(gl, attribData.type);
    attributes[attribData.name] = {
      location: 0,
      format,
      stride: getAttributeInfoFromFormat(format).stride,
      offset: 0,
      instance: false,
      start: 0
    };
  }
  const keys = Object.keys(attributes);
  if (sortAttributes) {
    keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
    for (let i2 = 0;i2 < keys.length; i2++) {
      attributes[keys[i2]].location = i2;
      gl.bindAttribLocation(program, i2, keys[i2]);
    }
    gl.linkProgram(program);
  } else {
    for (let i2 = 0;i2 < keys.length; i2++) {
      attributes[keys[i2]].location = gl.getAttribLocation(program, keys[i2]);
    }
  }
  return attributes;
}
var init_extractAttributesFromGlProgram = __esm(() => {
  init_getAttributeInfoFromFormat();
  init_mapType();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs
function getUboData(program, gl) {
  if (!gl.ACTIVE_UNIFORM_BLOCKS)
    return {};
  const uniformBlocks = {};
  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let i2 = 0;i2 < totalUniformsBlocks; i2++) {
    const name = gl.getActiveUniformBlockName(program, i2);
    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
    const size = gl.getActiveUniformBlockParameter(program, i2, gl.UNIFORM_BLOCK_DATA_SIZE);
    uniformBlocks[name] = {
      name,
      index: uniformBlockIndex,
      size
    };
  }
  return uniformBlocks;
}
var init_getUboData = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i2 = 0;i2 < totalUniforms; i2++) {
    const uniformData = gl.getActiveUniform(program, i2);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i2,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
var init_getUniformData = __esm(() => {
  init_defaultValue();
  init_mapType();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split(`
`).map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split(`
`);
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join(`
`);
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
var init_logProgramError = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
function generateProgram(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program._attributeData = extractAttributesFromGlProgram(webGLProgram, gl, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex));
  program._uniformData = getUniformData(webGLProgram, gl);
  program._uniformBlockData = getUboData(webGLProgram, gl);
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i2 in program._uniformData) {
    const data = program._uniformData[i2];
    uniformData[i2] = {
      location: gl.getUniformLocation(webGLProgram, i2),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram3 = new GlProgramData(webGLProgram, uniformData);
  return glProgram3;
}
var init_generateProgram = __esm(() => {
  init_warn();
  init_GlProgramData();
  init_compileShader();
  init_defaultValue();
  init_extractAttributesFromGlProgram();
  init_getUboData();
  init_getUniformData();
  init_logProgramError();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
class GlShaderSystem {
  constructor(renderer) {
    this._activeProgram = null;
    this._programDataHash = /* @__PURE__ */ Object.create(null);
    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
  }
  contextChange(gl) {
    this._gl = gl;
    this._programDataHash = /* @__PURE__ */ Object.create(null);
    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
    this._activeProgram = null;
  }
  bind(shader, skipSync) {
    this._setProgram(shader.glProgram);
    if (skipSync)
      return;
    defaultSyncData.textureCount = 0;
    defaultSyncData.blockIndex = 0;
    let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
    if (!syncFunction) {
      syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
    }
    this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);
    syncFunction(this._renderer, shader, defaultSyncData);
  }
  updateUniformGroup(uniformGroup) {
    this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
  }
  bindUniformBlock(uniformGroup, name, index = 0) {
    const bufferSystem = this._renderer.buffer;
    const programData = this._getProgramData(this._activeProgram);
    const isBufferResource = uniformGroup._bufferResource;
    if (!isBufferResource) {
      this._renderer.ubo.updateUniformGroup(uniformGroup);
    }
    const buffer = uniformGroup.buffer;
    const glBuffer = bufferSystem.updateBuffer(buffer);
    const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);
    if (isBufferResource) {
      const { offset, size } = uniformGroup;
      if (offset === 0 && size === buffer.data.byteLength) {
        bufferSystem.bindBufferBase(glBuffer, boundLocation);
      } else {
        bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);
      }
    } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {
      bufferSystem.bindBufferBase(glBuffer, boundLocation);
    }
    const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
    if (programData.uniformBlockBindings[index] === boundLocation)
      return;
    programData.uniformBlockBindings[index] = boundLocation;
    this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);
  }
  _setProgram(program) {
    if (this._activeProgram === program)
      return;
    this._activeProgram = program;
    const programData = this._getProgramData(program);
    this._gl.useProgram(programData.program);
  }
  _getProgramData(program) {
    return this._programDataHash[program._key] || this._createProgramData(program);
  }
  _createProgramData(program) {
    const key = program._key;
    this._programDataHash[key] = generateProgram(this._gl, program);
    return this._programDataHash[key];
  }
  destroy() {
    for (const key of Object.keys(this._programDataHash)) {
      const programData = this._programDataHash[key];
      programData.destroy();
      this._programDataHash[key] = null;
    }
    this._programDataHash = null;
    this._shaderSyncFunctions = null;
    this._activeProgram = null;
    this._renderer = null;
    this._gl = null;
  }
  _generateShaderSync(shader, shaderSystem) {
    return generateShaderSyncCode(shader, shaderSystem);
  }
  resetState() {
    this._activeProgram = null;
  }
}
var defaultSyncData;
var init_GlShaderSystem = __esm(() => {
  init_Extensions();
  init_GenerateShaderSyncCode();
  init_generateProgram();
  defaultSyncData = {
    textureCount: 0,
    blockIndex: 0
  };
  GlShaderSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "shader"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
var UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS;
var init_generateUniformsSyncTypes = __esm(() => {
  UNIFORM_TO_SINGLE_SETTERS = {
    f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
    "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
    "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
    "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
    i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
    "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
    "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
    "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
    bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
    "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
    "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
  };
  UNIFORM_TO_ARRAY_SETTERS = {
    f32: `gl.uniform1fv(location, v);`,
    "vec2<f32>": `gl.uniform2fv(location, v);`,
    "vec3<f32>": `gl.uniform3fv(location, v);`,
    "vec4<f32>": `gl.uniform4fv(location, v);`,
    "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
    "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
    "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
    i32: `gl.uniform1iv(location, v);`,
    "vec2<i32>": `gl.uniform2iv(location, v);`,
    "vec3<i32>": `gl.uniform3iv(location, v);`,
    "vec4<i32>": `gl.uniform4iv(location, v);`,
    u32: `gl.uniform1iv(location, v);`,
    "vec2<u32>": `gl.uniform2iv(location, v);`,
    "vec3<u32>": `gl.uniform3iv(location, v);`,
    "vec4<u32>": `gl.uniform4iv(location, v);`,
    bool: `gl.uniform1iv(location, v);`,
    "vec2<bool>": `gl.uniform2iv(location, v);`,
    "vec3<bool>": `gl.uniform3iv(location, v);`,
    "vec4<bool>": `gl.uniform4iv(location, v);`
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
  for (const i2 in group.uniforms) {
    if (!uniformData[i2]) {
      if (group.uniforms[i2] instanceof UniformGroup) {
        if (group.uniforms[i2].ubo) {
          funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i2}, "${i2}");
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i2});
                    `);
        }
      } else if (group.uniforms[i2] instanceof BufferResource) {
        funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i2}, "${i2}");
                    `);
      }
      continue;
    }
    const uniform = group.uniformStructures[i2];
    let parsed = false;
    for (let j2 = 0;j2 < uniformParsers.length; j2++) {
      const parser = uniformParsers[j2];
      if (uniform.type === parser.type && parser.test(uniform)) {
        funcFragments.push(`name = "${i2}";`, uniformParsers[j2].uniform);
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
      const template = templateType[uniform.type].replace("location", `ud["${i2}"].location`);
      funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join(`
`));
}
var init_generateUniformsSync = __esm(() => {
  init_BufferResource();
  init_UniformGroup();
  init_uniformParsers();
  init_generateUniformsSyncTypes();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
class GlUniformGroupSystem {
  constructor(renderer) {
    this._cache = {};
    this._uniformGroupSyncHash = {};
    this._renderer = renderer;
    this.gl = null;
    this._cache = {};
  }
  contextChange(gl) {
    this.gl = gl;
  }
  updateUniformGroup(group, program, syncData) {
    const programData = this._renderer.shader._getProgramData(program);
    if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
      programData.uniformDirtyGroups[group.uid] = group._dirtyId;
      const syncFunc = this._getUniformSyncFunction(group, program);
      syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
    }
  }
  _getUniformSyncFunction(group, program) {
    return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
  }
  _createUniformSyncFunction(group, program) {
    const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
    const id = this._getSignature(group, program._uniformData, "u");
    if (!this._cache[id]) {
      this._cache[id] = this._generateUniformsSync(group, program._uniformData);
    }
    uniformGroupSyncHash[program._key] = this._cache[id];
    return uniformGroupSyncHash[program._key];
  }
  _generateUniformsSync(group, uniformData) {
    return generateUniformsSync(group, uniformData);
  }
  _getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i2 in uniforms) {
      strings.push(i2);
      if (uniformData[i2]) {
        strings.push(uniformData[i2].type);
      }
    }
    return strings.join("-");
  }
  destroy() {
    this._renderer = null;
    this._cache = null;
  }
}
var init_GlUniformGroupSystem = __esm(() => {
  init_Extensions();
  init_generateUniformsSync();
  GlUniformGroupSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "uniformGroup"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
function mapWebGLBlendModesToPixi(gl) {
  const blendMap = {};
  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.add = [gl.ONE, gl.ONE];
  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.none = [0, 0];
  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
  if (isWebGl2) {
    blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
    blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
  } else {
    const ext = gl.getExtension("EXT_blend_minmax");
    if (ext) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
    }
  }
  return blendMap;
}
var init_mapWebGLBlendModesToPixi = __esm(() => {
  init_adapter();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
var BLEND2 = 0, OFFSET2 = 1, CULLING2 = 2, DEPTH_TEST2 = 3, WINDING2 = 4, DEPTH_MASK2 = 5, _GlStateSystem = class _GlStateSystem2 {
  constructor(renderer) {
    this._invertFrontFace = false;
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = "none";
    this._blendEq = false;
    this.map = [];
    this.map[BLEND2] = this.setBlend;
    this.map[OFFSET2] = this.setOffset;
    this.map[CULLING2] = this.setCullFace;
    this.map[DEPTH_TEST2] = this.setDepthTest;
    this.map[WINDING2] = this.setFrontFace;
    this.map[DEPTH_MASK2] = this.setDepthMask;
    this.checks = [];
    this.defaultState = State.for2d();
    renderer.renderTarget.onRenderTargetChange.add(this);
  }
  onRenderTargetChange(renderTarget) {
    this._invertFrontFace = !renderTarget.isRoot;
    if (this._cullFace) {
      this.setFrontFace(this._frontFace);
    } else {
      this._frontFaceDirty = true;
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModesMap = mapWebGLBlendModesToPixi(gl);
    this.resetState();
  }
  set(state) {
    state || (state = this.defaultState);
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i2 = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i2].call(this, !!(state.data & 1 << i2));
        }
        diff >>= 1;
        i2++;
      }
      this.stateId = state.data;
    }
    for (let i2 = 0;i2 < this.checks.length; i2++) {
      this.checks[i2](this, state);
    }
  }
  forceState(state) {
    state || (state = this.defaultState);
    for (let i2 = 0;i2 < this.map.length; i2++) {
      this.map[i2].call(this, !!(state.data & 1 << i2));
    }
    for (let i2 = 0;i2 < this.checks.length; i2++) {
      this.checks[i2](this, state);
    }
    this.stateId = state.data;
  }
  setBlend(value) {
    this._updateCheck(_GlStateSystem2._checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  setOffset(value) {
    this._updateCheck(_GlStateSystem2._checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  setCullFace(value) {
    this._cullFace = value;
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
    if (this._cullFace && this._frontFaceDirty) {
      this.setFrontFace(this._frontFace);
    }
  }
  setFrontFace(value) {
    this._frontFace = value;
    this._frontFaceDirty = false;
    const faceMode = this._invertFrontFace ? !value : value;
    if (this._glFrontFace !== faceMode) {
      this._glFrontFace = faceMode;
      this.gl.frontFace(this.gl[faceMode ? "CW" : "CCW"]);
    }
  }
  setBlendMode(value) {
    if (!this.blendModesMap[value]) {
      value = "normal";
    }
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    const mode = this.blendModesMap[value];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  resetState() {
    this._glFrontFace = false;
    this._frontFace = false;
    this._cullFace = false;
    this._frontFaceDirty = false;
    this._invertFrontFace = false;
    this.gl.frontFace(this.gl.CCW);
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = "";
    this.setBlendMode("normal");
  }
  _updateCheck(func, value) {
    const index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  }
  static _checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  static _checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  destroy() {
    this.gl = null;
    this.checks.length = 0;
  }
}, GlStateSystem;
var init_GlStateSystem = __esm(() => {
  init_Extensions();
  init_State();
  init_mapWebGLBlendModesToPixi();
  _GlStateSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "state"
  };
  GlStateSystem = _GlStateSystem;
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
class GlTexture {
  constructor(texture) {
    this.target = GL_TARGETS.TEXTURE_2D;
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.type = GL_TYPES.UNSIGNED_BYTE;
    this.internalFormat = GL_FORMATS.RGBA;
    this.format = GL_FORMATS.RGBA;
    this.samplerType = 0;
  }
}
var init_GlTexture = __esm(() => {
  init_const10();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
var glUploadBufferImageResource;
var init_glUploadBufferImageResource = __esm(() => {
  glUploadBufferImageResource = {
    id: "buffer",
    upload(source2, glTexture, gl) {
      if (glTexture.width === source2.width || glTexture.height === source2.height) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, source2.width, source2.height, glTexture.format, glTexture.type, source2.resource);
      } else {
        gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, source2.width, source2.height, 0, glTexture.format, glTexture.type, source2.resource);
      }
      glTexture.width = source2.width;
      glTexture.height = source2.height;
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
var compressedFormatMap, glUploadCompressedTextureResource;
var init_glUploadCompressedTextureResource = __esm(() => {
  compressedFormatMap = {
    "bc1-rgba-unorm": true,
    "bc1-rgba-unorm-srgb": true,
    "bc2-rgba-unorm": true,
    "bc2-rgba-unorm-srgb": true,
    "bc3-rgba-unorm": true,
    "bc3-rgba-unorm-srgb": true,
    "bc4-r-unorm": true,
    "bc4-r-snorm": true,
    "bc5-rg-unorm": true,
    "bc5-rg-snorm": true,
    "bc6h-rgb-ufloat": true,
    "bc6h-rgb-float": true,
    "bc7-rgba-unorm": true,
    "bc7-rgba-unorm-srgb": true,
    "etc2-rgb8unorm": true,
    "etc2-rgb8unorm-srgb": true,
    "etc2-rgb8a1unorm": true,
    "etc2-rgb8a1unorm-srgb": true,
    "etc2-rgba8unorm": true,
    "etc2-rgba8unorm-srgb": true,
    "eac-r11unorm": true,
    "eac-r11snorm": true,
    "eac-rg11unorm": true,
    "eac-rg11snorm": true,
    "astc-4x4-unorm": true,
    "astc-4x4-unorm-srgb": true,
    "astc-5x4-unorm": true,
    "astc-5x4-unorm-srgb": true,
    "astc-5x5-unorm": true,
    "astc-5x5-unorm-srgb": true,
    "astc-6x5-unorm": true,
    "astc-6x5-unorm-srgb": true,
    "astc-6x6-unorm": true,
    "astc-6x6-unorm-srgb": true,
    "astc-8x5-unorm": true,
    "astc-8x5-unorm-srgb": true,
    "astc-8x6-unorm": true,
    "astc-8x6-unorm-srgb": true,
    "astc-8x8-unorm": true,
    "astc-8x8-unorm-srgb": true,
    "astc-10x5-unorm": true,
    "astc-10x5-unorm-srgb": true,
    "astc-10x6-unorm": true,
    "astc-10x6-unorm-srgb": true,
    "astc-10x8-unorm": true,
    "astc-10x8-unorm-srgb": true,
    "astc-10x10-unorm": true,
    "astc-10x10-unorm-srgb": true,
    "astc-12x10-unorm": true,
    "astc-12x10-unorm-srgb": true,
    "astc-12x12-unorm": true,
    "astc-12x12-unorm-srgb": true
  };
  glUploadCompressedTextureResource = {
    id: "compressed",
    upload(source2, glTexture, gl) {
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
      let mipWidth = source2.pixelWidth;
      let mipHeight = source2.pixelHeight;
      const compressed = !!compressedFormatMap[source2.format];
      for (let i2 = 0;i2 < source2.resource.length; i2++) {
        const levelBuffer = source2.resource[i2];
        if (compressed) {
          gl.compressedTexImage2D(gl.TEXTURE_2D, i2, glTexture.internalFormat, mipWidth, mipHeight, 0, levelBuffer);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, i2, glTexture.internalFormat, mipWidth, mipHeight, 0, glTexture.format, glTexture.type, levelBuffer);
        }
        mipWidth = Math.max(mipWidth >> 1, 1);
        mipHeight = Math.max(mipHeight >> 1, 1);
      }
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
var glUploadImageResource;
var init_glUploadImageResource = __esm(() => {
  glUploadImageResource = {
    id: "image",
    upload(source2, glTexture, gl, webGLVersion) {
      const glWidth = glTexture.width;
      const glHeight = glTexture.height;
      const textureWidth = source2.pixelWidth;
      const textureHeight = source2.pixelHeight;
      const resourceWidth = source2.resourceWidth;
      const resourceHeight = source2.resourceHeight;
      if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
        if (glWidth !== textureWidth || glHeight !== textureHeight) {
          gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, textureWidth, textureHeight, 0, glTexture.format, glTexture.type, null);
        }
        if (webGLVersion === 2) {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, resourceWidth, resourceHeight, glTexture.format, glTexture.type, source2.resource);
        } else {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, glTexture.format, glTexture.type, source2.resource);
        }
      } else if (glWidth === textureWidth && glHeight === textureHeight) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, glTexture.format, glTexture.type, source2.resource);
      } else if (webGLVersion === 2) {
        gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, textureWidth, textureHeight, 0, glTexture.format, glTexture.type, source2.resource);
      } else {
        gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, glTexture.format, glTexture.type, source2.resource);
      }
      glTexture.width = textureWidth;
      glTexture.height = textureHeight;
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
var glUploadVideoResource;
var init_glUploadVideoResource = __esm(() => {
  init_glUploadImageResource();
  glUploadVideoResource = {
    id: "video",
    upload(source2, glTexture, gl, webGLVersion) {
      if (!source2.isValid) {
        gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, 1, 1, 0, glTexture.format, glTexture.type, null);
        return;
      }
      glUploadImageResource.upload(source2, glTexture, gl, webGLVersion);
    }
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
var init_pixiToGlMaps = __esm(() => {
  scaleModeToGlFilter = {
    linear: 9729,
    nearest: 9728
  };
  mipmapScaleModeToGlFilter = {
    linear: {
      linear: 9987,
      nearest: 9985
    },
    nearest: {
      linear: 9986,
      nearest: 9984
    }
  };
  wrapModeToGlAddress = {
    "clamp-to-edge": 33071,
    repeat: 10497,
    "mirror-repeat": 33648
  };
  compareModeToGlCompare = {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
  const castParam = firstParam;
  if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
    const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
    const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
    const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
    if (gl.TEXTURE_WRAP_R)
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
  }
  if (!firstCreation || style.magFilter !== "linear") {
    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
  }
  if (mipmaps) {
    if (!firstCreation || style.mipmapFilter !== "linear") {
      const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
    }
  } else {
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
  }
  if (anisotropicExt && style.maxAnisotropy > 1) {
    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
  }
  if (style.compare) {
    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
  }
}
var init_applyStyleParams = __esm(() => {
  init_pixiToGlMaps();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
function mapFormatToGlFormat(gl) {
  return {
    r8unorm: gl.RED,
    r8snorm: gl.RED,
    r8uint: gl.RED,
    r8sint: gl.RED,
    r16uint: gl.RED,
    r16sint: gl.RED,
    r16float: gl.RED,
    rg8unorm: gl.RG,
    rg8snorm: gl.RG,
    rg8uint: gl.RG,
    rg8sint: gl.RG,
    r32uint: gl.RED,
    r32sint: gl.RED,
    r32float: gl.RED,
    rg16uint: gl.RG,
    rg16sint: gl.RG,
    rg16float: gl.RG,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.RGBA,
    rgba8snorm: gl.RGBA,
    rgba8uint: gl.RGBA,
    rgba8sint: gl.RGBA,
    bgra8unorm: gl.RGBA,
    "bgra8unorm-srgb": gl.RGBA,
    rgb9e5ufloat: gl.RGB,
    rgb10a2unorm: gl.RGBA,
    rg11b10ufloat: gl.RGB,
    rg32uint: gl.RG,
    rg32sint: gl.RG,
    rg32float: gl.RG,
    rgba16uint: gl.RGBA,
    rgba16sint: gl.RGBA,
    rgba16float: gl.RGBA,
    rgba32uint: gl.RGBA,
    rgba32sint: gl.RGBA,
    rgba32float: gl.RGBA,
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT,
    depth24plus: gl.DEPTH_COMPONENT,
    "depth24plus-stencil8": gl.DEPTH_STENCIL,
    depth32float: gl.DEPTH_COMPONENT,
    "depth32float-stencil8": gl.DEPTH_STENCIL
  };
}
var init_mapFormatToGlFormat = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
function mapFormatToGlInternalFormat(gl, extensions2) {
  let srgb = {};
  let bgra8unorm = gl.RGBA;
  if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
    srgb = {
      "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
      "bgra8unorm-srgb": gl.SRGB8_ALPHA8
    };
    bgra8unorm = gl.RGBA8;
  } else if (extensions2.srgb) {
    srgb = {
      "rgba8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT,
      "bgra8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT
    };
  }
  return {
    r8unorm: gl.R8,
    r8snorm: gl.R8_SNORM,
    r8uint: gl.R8UI,
    r8sint: gl.R8I,
    r16uint: gl.R16UI,
    r16sint: gl.R16I,
    r16float: gl.R16F,
    rg8unorm: gl.RG8,
    rg8snorm: gl.RG8_SNORM,
    rg8uint: gl.RG8UI,
    rg8sint: gl.RG8I,
    r32uint: gl.R32UI,
    r32sint: gl.R32I,
    r32float: gl.R32F,
    rg16uint: gl.RG16UI,
    rg16sint: gl.RG16I,
    rg16float: gl.RG16F,
    rgba8unorm: gl.RGBA,
    ...srgb,
    rgba8snorm: gl.RGBA8_SNORM,
    rgba8uint: gl.RGBA8UI,
    rgba8sint: gl.RGBA8I,
    bgra8unorm,
    rgb9e5ufloat: gl.RGB9_E5,
    rgb10a2unorm: gl.RGB10_A2,
    rg11b10ufloat: gl.R11F_G11F_B10F,
    rg32uint: gl.RG32UI,
    rg32sint: gl.RG32I,
    rg32float: gl.RG32F,
    rgba16uint: gl.RGBA16UI,
    rgba16sint: gl.RGBA16I,
    rgba16float: gl.RGBA16F,
    rgba32uint: gl.RGBA32UI,
    rgba32sint: gl.RGBA32I,
    rgba32float: gl.RGBA32F,
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT16,
    depth24plus: gl.DEPTH_COMPONENT24,
    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
    depth32float: gl.DEPTH_COMPONENT32F,
    "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
    ...extensions2.s3tc ? {
      "bc1-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
    } : {},
    ...extensions2.s3tc_sRGB ? {
      "bc1-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    } : {},
    ...extensions2.rgtc ? {
      "bc4-r-unorm": extensions2.rgtc.COMPRESSED_RED_RGTC1_EXT,
      "bc4-r-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      "bc5-rg-unorm": extensions2.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
      "bc5-rg-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    } : {},
    ...extensions2.bptc ? {
      "bc6h-rgb-float": extensions2.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      "bc6h-rgb-ufloat": extensions2.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      "bc7-rgba-unorm": extensions2.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      "bc7-rgba-unorm-srgb": extensions2.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    } : {},
    ...extensions2.etc ? {
      "etc2-rgb8unorm": extensions2.etc.COMPRESSED_RGB8_ETC2,
      "etc2-rgb8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ETC2,
      "etc2-rgb8a1unorm": extensions2.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgb8a1unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgba8unorm": extensions2.etc.COMPRESSED_RGBA8_ETC2_EAC,
      "etc2-rgba8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      "eac-r11unorm": extensions2.etc.COMPRESSED_R11_EAC,
      "eac-rg11unorm": extensions2.etc.COMPRESSED_SIGNED_RG11_EAC
    } : {},
    ...extensions2.astc ? {
      "astc-4x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
      "astc-4x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      "astc-5x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
      "astc-5x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
      "astc-5x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
      "astc-5x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      "astc-6x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
      "astc-6x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      "astc-6x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
      "astc-6x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      "astc-8x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
      "astc-8x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      "astc-8x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
      "astc-8x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      "astc-8x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
      "astc-8x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      "astc-10x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
      "astc-10x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      "astc-10x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
      "astc-10x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      "astc-10x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
      "astc-10x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      "astc-10x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
      "astc-10x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      "astc-12x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
      "astc-12x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      "astc-12x12-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
      "astc-12x12-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    } : {}
  };
}
var init_mapFormatToGlInternalFormat = __esm(() => {
  init_adapter();
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
function mapFormatToGlType(gl) {
  return {
    r8unorm: gl.UNSIGNED_BYTE,
    r8snorm: gl.BYTE,
    r8uint: gl.UNSIGNED_BYTE,
    r8sint: gl.BYTE,
    r16uint: gl.UNSIGNED_SHORT,
    r16sint: gl.SHORT,
    r16float: gl.HALF_FLOAT,
    rg8unorm: gl.UNSIGNED_BYTE,
    rg8snorm: gl.BYTE,
    rg8uint: gl.UNSIGNED_BYTE,
    rg8sint: gl.BYTE,
    r32uint: gl.UNSIGNED_INT,
    r32sint: gl.INT,
    r32float: gl.FLOAT,
    rg16uint: gl.UNSIGNED_SHORT,
    rg16sint: gl.SHORT,
    rg16float: gl.HALF_FLOAT,
    rgba8unorm: gl.UNSIGNED_BYTE,
    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
    rgba8snorm: gl.BYTE,
    rgba8uint: gl.UNSIGNED_BYTE,
    rgba8sint: gl.BYTE,
    bgra8unorm: gl.UNSIGNED_BYTE,
    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
    rg32uint: gl.UNSIGNED_INT,
    rg32sint: gl.INT,
    rg32float: gl.FLOAT,
    rgba16uint: gl.UNSIGNED_SHORT,
    rgba16sint: gl.SHORT,
    rgba16float: gl.HALF_FLOAT,
    rgba32uint: gl.UNSIGNED_INT,
    rgba32sint: gl.INT,
    rgba32float: gl.FLOAT,
    stencil8: gl.UNSIGNED_BYTE,
    depth16unorm: gl.UNSIGNED_SHORT,
    depth24plus: gl.UNSIGNED_INT,
    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
    depth32float: gl.FLOAT,
    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}
var init_mapFormatToGlType = () => {};

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
class GlTextureSystem {
  constructor(renderer) {
    this.managedTextures = [];
    this._glTextures = /* @__PURE__ */ Object.create(null);
    this._glSamplers = /* @__PURE__ */ Object.create(null);
    this._boundTextures = [];
    this._activeTextureLocation = -1;
    this._boundSamplers = /* @__PURE__ */ Object.create(null);
    this._uploads = {
      image: glUploadImageResource,
      buffer: glUploadBufferImageResource,
      video: glUploadVideoResource,
      compressed: glUploadCompressedTextureResource
    };
    this._premultiplyAlpha = false;
    this._useSeparateSamplers = false;
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_glTextures");
    this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
  }
  contextChange(gl) {
    this._gl = gl;
    if (!this._mapFormatToInternalFormat) {
      this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
      this._mapFormatToType = mapFormatToGlType(gl);
      this._mapFormatToFormat = mapFormatToGlFormat(gl);
    }
    this._glTextures = /* @__PURE__ */ Object.create(null);
    this._glSamplers = /* @__PURE__ */ Object.create(null);
    this._boundSamplers = /* @__PURE__ */ Object.create(null);
    this._premultiplyAlpha = false;
    for (let i2 = 0;i2 < 16; i2++) {
      this.bind(Texture.EMPTY, i2);
    }
  }
  initSource(source2) {
    this.bind(source2);
  }
  bind(texture, location2 = 0) {
    const source2 = texture.source;
    if (texture) {
      this.bindSource(source2, location2);
      if (this._useSeparateSamplers) {
        this._bindSampler(source2.style, location2);
      }
    } else {
      this.bindSource(null, location2);
      if (this._useSeparateSamplers) {
        this._bindSampler(null, location2);
      }
    }
  }
  bindSource(source2, location2 = 0) {
    const gl = this._gl;
    source2._touched = this._renderer.textureGC.count;
    if (this._boundTextures[location2] !== source2) {
      this._boundTextures[location2] = source2;
      this._activateLocation(location2);
      source2 || (source2 = Texture.EMPTY.source);
      const glTexture = this.getGlSource(source2);
      gl.bindTexture(glTexture.target, glTexture.texture);
    }
  }
  _bindSampler(style, location2 = 0) {
    const gl = this._gl;
    if (!style) {
      this._boundSamplers[location2] = null;
      gl.bindSampler(location2, null);
      return;
    }
    const sampler = this._getGlSampler(style);
    if (this._boundSamplers[location2] !== sampler) {
      this._boundSamplers[location2] = sampler;
      gl.bindSampler(location2, sampler);
    }
  }
  unbind(texture) {
    const source2 = texture.source;
    const boundTextures = this._boundTextures;
    const gl = this._gl;
    for (let i2 = 0;i2 < boundTextures.length; i2++) {
      if (boundTextures[i2] === source2) {
        this._activateLocation(i2);
        const glTexture = this.getGlSource(source2);
        gl.bindTexture(glTexture.target, null);
        boundTextures[i2] = null;
      }
    }
  }
  _activateLocation(location2) {
    if (this._activeTextureLocation !== location2) {
      this._activeTextureLocation = location2;
      this._gl.activeTexture(this._gl.TEXTURE0 + location2);
    }
  }
  _initSource(source2) {
    const gl = this._gl;
    const glTexture = new GlTexture(gl.createTexture());
    glTexture.type = this._mapFormatToType[source2.format];
    glTexture.internalFormat = this._mapFormatToInternalFormat[source2.format];
    glTexture.format = this._mapFormatToFormat[source2.format];
    if (source2.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source2.isPowerOfTwo)) {
      const biggestDimension = Math.max(source2.width, source2.height);
      source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
    }
    this._glTextures[source2.uid] = glTexture;
    if (!this.managedTextures.includes(source2)) {
      source2.on("update", this.onSourceUpdate, this);
      source2.on("resize", this.onSourceUpdate, this);
      source2.on("styleChange", this.onStyleChange, this);
      source2.on("destroy", this.onSourceDestroy, this);
      source2.on("unload", this.onSourceUnload, this);
      source2.on("updateMipmaps", this.onUpdateMipmaps, this);
      this.managedTextures.push(source2);
    }
    this.onSourceUpdate(source2);
    this.updateStyle(source2, false);
    return glTexture;
  }
  onStyleChange(source2) {
    this.updateStyle(source2, false);
  }
  updateStyle(source2, firstCreation) {
    const gl = this._gl;
    const glTexture = this.getGlSource(source2);
    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
    this._boundTextures[this._activeTextureLocation] = source2;
    applyStyleParams(source2.style, gl, source2.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", gl.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !source2.isPowerOfTwo, firstCreation);
  }
  onSourceUnload(source2) {
    const glTexture = this._glTextures[source2.uid];
    if (!glTexture)
      return;
    this.unbind(source2);
    this._glTextures[source2.uid] = null;
    this._gl.deleteTexture(glTexture.texture);
  }
  onSourceUpdate(source2) {
    const gl = this._gl;
    const glTexture = this.getGlSource(source2);
    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
    this._boundTextures[this._activeTextureLocation] = source2;
    const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
    if (this._premultiplyAlpha !== premultipliedAlpha) {
      this._premultiplyAlpha = premultipliedAlpha;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
    }
    if (this._uploads[source2.uploadMethodId]) {
      this._uploads[source2.uploadMethodId].upload(source2, glTexture, gl, this._renderer.context.webGLVersion);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source2.pixelWidth, source2.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
      this.onUpdateMipmaps(source2, false);
    }
  }
  onUpdateMipmaps(source2, bind = true) {
    if (bind)
      this.bindSource(source2, 0);
    const glTexture = this.getGlSource(source2);
    this._gl.generateMipmap(glTexture.target);
  }
  onSourceDestroy(source2) {
    source2.off("destroy", this.onSourceDestroy, this);
    source2.off("update", this.onSourceUpdate, this);
    source2.off("resize", this.onSourceUpdate, this);
    source2.off("unload", this.onSourceUnload, this);
    source2.off("styleChange", this.onStyleChange, this);
    source2.off("updateMipmaps", this.onUpdateMipmaps, this);
    this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
    this.onSourceUnload(source2);
  }
  _initSampler(style) {
    const gl = this._gl;
    const glSampler = this._gl.createSampler();
    this._glSamplers[style._resourceId] = glSampler;
    applyStyleParams(style, gl, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", glSampler, false, true);
    return this._glSamplers[style._resourceId];
  }
  _getGlSampler(sampler) {
    return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
  }
  getGlSource(source2) {
    return this._glTextures[source2.uid] || this._initSource(source2);
  }
  generateCanvas(texture) {
    const { pixels, width, height } = this.getPixels(texture);
    const canvas = DOMAdapter.get().createCanvas();
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (ctx) {
      const imageData = ctx.createImageData(width, height);
      imageData.data.set(pixels);
      ctx.putImageData(imageData, 0, 0);
    }
    return canvas;
  }
  getPixels(texture) {
    const resolution = texture.source.resolution;
    const frame = texture.frame;
    const width = Math.max(Math.round(frame.width * resolution), 1);
    const height = Math.max(Math.round(frame.height * resolution), 1);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const renderer = this._renderer;
    const renderTarget = renderer.renderTarget.getRenderTarget(texture);
    const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
    const gl = renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (false) {}
    return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
  }
  destroy() {
    this.managedTextures.slice().forEach((source2) => this.onSourceDestroy(source2));
    this.managedTextures = null;
    this._glTextures = null;
    this._glSamplers = null;
    this._boundTextures = null;
    this._boundSamplers = null;
    this._mapFormatToInternalFormat = null;
    this._mapFormatToType = null;
    this._mapFormatToFormat = null;
    this._uploads = null;
    this._renderer = null;
  }
  resetState() {
    this._activeTextureLocation = -1;
    this._boundTextures.fill(Texture.EMPTY.source);
    this._boundSamplers = /* @__PURE__ */ Object.create(null);
    const gl = this._gl;
    this._premultiplyAlpha = false;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
  }
}
var BYTES_PER_PIXEL = 4;
var init_GlTextureSystem = __esm(() => {
  init_adapter();
  init_Extensions();
  init_Texture();
  init_GlTexture();
  init_glUploadBufferImageResource();
  init_glUploadCompressedTextureResource();
  init_glUploadImageResource();
  init_glUploadVideoResource();
  init_applyStyleParams();
  init_mapFormatToGlFormat();
  init_mapFormatToGlInternalFormat();
  init_mapFormatToGlType();
  GlTextureSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "texture"
  };
});

// node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
var exports_WebGLRenderer = {};
__export(exports_WebGLRenderer, {
  WebGLRenderer: () => WebGLRenderer
});
var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
var init_WebGLRenderer = __esm(() => {
  init_Extensions();
  init_GlGraphicsAdaptor();
  init_GlMeshAdaptor();
  init_GlBatchAdaptor();
  init_AbstractRenderer();
  init_SharedSystems();
  init_types2();
  init_GlBufferSystem();
  init_GlContextSystem();
  init_GlGeometrySystem();
  init_GlBackBufferSystem();
  init_GlColorMaskSystem();
  init_GlEncoderSystem();
  init_GlLimitsSystem();
  init_GlStencilSystem();
  init_GlUboSystem();
  init_GlRenderTargetSystem();
  init_GlShaderSystem();
  init_GlUniformGroupSystem();
  init_GlStateSystem();
  init_GlTextureSystem();
  DefaultWebGLSystems = [
    ...SharedSystems,
    GlUboSystem,
    GlBackBufferSystem,
    GlContextSystem,
    GlLimitsSystem,
    GlBufferSystem,
    GlTextureSystem,
    GlRenderTargetSystem,
    GlGeometrySystem,
    GlUniformGroupSystem,
    GlShaderSystem,
    GlEncoderSystem,
    GlStateSystem,
    GlStencilSystem,
    GlColorMaskSystem
  ];
  DefaultWebGLPipes = [...SharedRenderPipes];
  DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
  systems2 = [];
  renderPipes2 = [];
  renderPipeAdaptors2 = [];
  extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
  extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
  extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
  extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
  WebGLRenderer = class WebGLRenderer extends AbstractRenderer {
    constructor() {
      const systemConfig = {
        name: "webgl",
        type: RendererType.WEBGL,
        systems: systems2,
        renderPipes: renderPipes2,
        renderPipeAdaptors: renderPipeAdaptors2
      };
      super(systemConfig);
    }
  };
});

// ../lib/src/should.ts
var should_never_happen = (msg, ...args) => {
  console.error(msg, ...args);
  debugger;
  throw new Error(`Should never happen: ${msg}`);
};

// src/lib/save.ts
function save_get(version) {
  const local_storage_save_value = localStorage.getItem("jdefense");
  if (local_storage_save_value === null) {
    const new_save = save_init(version);
    localStorage.setItem("jdefense", JSON.stringify(new_save));
    return new_save;
  } else {
    const current_save = JSON.parse(local_storage_save_value);
    if (current_save.version !== version) {
      const new_save = save_init(version);
      localStorage.setItem("jdefense", JSON.stringify(new_save));
      return new_save;
    } else {
      return current_save;
    }
  }
}
function save_init(version) {
  return {
    version,
    bundle: "",
    mission: ""
  };
}

// node_modules/pixi.js/lib/environment-browser/browserExt.mjs
init_Extensions();
var browserExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "browser",
    priority: -1
  },
  test: () => true,
  load: async () => {
    await Promise.resolve().then(() => (init_browserAll(), exports_browserAll));
  }
};

// node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs
init_Extensions();
var webworkerExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== undefined,
  load: async () => {
    await Promise.resolve().then(() => (init_webworkerAll(), exports_webworkerAll));
  }
};

// node_modules/pixi.js/lib/index.mjs
init_Extensions();
init_init6();
init_init5();

// node_modules/pixi.js/lib/app/Application.mjs
init_Extensions();

// node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
init_adapter();
init_AbstractRenderer();
var _isWebGLSupported;
function isWebGLSupported(failIfMajorPerformanceCaveat) {
  if (_isWebGLSupported !== undefined)
    return _isWebGLSupported;
  _isWebGLSupported = (() => {
    const contextOptions = {
      stencil: true,
      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!DOMAdapter.get().getWebGLRenderingContext()) {
        return false;
      }
      const canvas = DOMAdapter.get().createCanvas();
      let gl = canvas.getContext("webgl", contextOptions);
      const success = !!gl?.getContextAttributes()?.stencil;
      if (gl) {
        const loseContext = gl.getExtension("WEBGL_lose_context");
        if (loseContext) {
          loseContext.loseContext();
        }
      }
      gl = null;
      return success;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGLSupported;
}

// node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
init_adapter();
var _isWebGPUSupported;
async function isWebGPUSupported(options = {}) {
  if (_isWebGPUSupported !== undefined)
    return _isWebGPUSupported;
  _isWebGPUSupported = await (async () => {
    const gpu = DOMAdapter.get().getNavigator().gpu;
    if (!gpu) {
      return false;
    }
    try {
      const adapter = await gpu.requestAdapter(options);
      await adapter.requestDevice();
      return true;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGPUSupported;
}

// node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
init_AbstractRenderer();
var renderPriority = ["webgl", "webgpu", "canvas"];
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  let finalOptions = {};
  for (let i2 = 0;i2 < preferredOrder.length; i2++) {
    const rendererType = preferredOrder[i2];
    if (rendererType === "webgpu" && await isWebGPUSupported()) {
      const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), exports_WebGPURenderer));
      RendererClass = WebGPURenderer2;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && isWebGLSupported(options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat)) {
      const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), exports_WebGLRenderer));
      RendererClass = WebGLRenderer2;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      finalOptions = { ...options };
      throw new Error("CanvasRenderer is not yet implemented");
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  if (!RendererClass) {
    throw new Error("No available renderer for the current environment");
  }
  const renderer = new RendererClass;
  await renderer.init(finalOptions);
  return renderer;
}

// node_modules/pixi.js/lib/app/Application.mjs
init_Container();
init_globalHooks();
init_deprecation();
var _Application = class _Application2 {
  constructor(...args) {
    this.stage = new Container;
    if (args[0] !== undefined) {
      deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
    }
  }
  async init(options) {
    options = { ...options };
    this.renderer = await autoDetectRenderer(options);
    _Application2._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  render() {
    this.renderer.render({ container: this.stage });
  }
  get canvas() {
    return this.renderer.canvas;
  }
  get view() {
    deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
    return this.renderer.canvas;
  }
  get screen() {
    return this.renderer.screen;
  }
  destroy(rendererDestroyOptions = false, options = false) {
    const plugins = _Application2._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(options);
    this.stage = null;
    this.renderer.destroy(rendererDestroyOptions);
    this.renderer = null;
  }
};
_Application._plugins = [];
var Application = _Application;
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ApplicationInitHook);
// node_modules/pixi.js/lib/index.mjs
init_Point();
init_Rectangle();
init_textureFrom();
init_Container();
init_Graphics();
init_Ticker();
init_eventemitter3();
extensions.add(browserExt, webworkerExt);

// node_modules/pixi-viewport/dist/pixi_viewport.js
var S2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function M2(l2) {
  return l2 && l2.__esModule && Object.prototype.hasOwnProperty.call(l2, "default") ? l2.default : l2;
}
var W = { exports: {} };
(function(l2, t2) {
  (function() {
    var e2, n2;
    n2 = function(i2) {
      return l2.exports = i2;
    }, e2 = {
      linear: function(i2, s2, h2, o2) {
        return h2 * i2 / o2 + s2;
      },
      easeInQuad: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 + s2;
      },
      easeOutQuad: function(i2, s2, h2, o2) {
        return -h2 * (i2 /= o2) * (i2 - 2) + s2;
      },
      easeInOutQuad: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 + s2 : -h2 / 2 * (--i2 * (i2 - 2) - 1) + s2;
      },
      easeInCubic: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 * i2 + s2;
      },
      easeOutCubic: function(i2, s2, h2, o2) {
        return h2 * ((i2 = i2 / o2 - 1) * i2 * i2 + 1) + s2;
      },
      easeInOutCubic: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 * i2 + s2 : h2 / 2 * ((i2 -= 2) * i2 * i2 + 2) + s2;
      },
      easeInQuart: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 * i2 * i2 + s2;
      },
      easeOutQuart: function(i2, s2, h2, o2) {
        return -h2 * ((i2 = i2 / o2 - 1) * i2 * i2 * i2 - 1) + s2;
      },
      easeInOutQuart: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 * i2 * i2 + s2 : -h2 / 2 * ((i2 -= 2) * i2 * i2 * i2 - 2) + s2;
      },
      easeInQuint: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 * i2 * i2 * i2 + s2;
      },
      easeOutQuint: function(i2, s2, h2, o2) {
        return h2 * ((i2 = i2 / o2 - 1) * i2 * i2 * i2 * i2 + 1) + s2;
      },
      easeInOutQuint: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 * i2 * i2 * i2 + s2 : h2 / 2 * ((i2 -= 2) * i2 * i2 * i2 * i2 + 2) + s2;
      },
      easeInSine: function(i2, s2, h2, o2) {
        return -h2 * Math.cos(i2 / o2 * (Math.PI / 2)) + h2 + s2;
      },
      easeOutSine: function(i2, s2, h2, o2) {
        return h2 * Math.sin(i2 / o2 * (Math.PI / 2)) + s2;
      },
      easeInOutSine: function(i2, s2, h2, o2) {
        return -h2 / 2 * (Math.cos(Math.PI * i2 / o2) - 1) + s2;
      },
      easeInExpo: function(i2, s2, h2, o2) {
        return i2 === 0 ? s2 : h2 * Math.pow(2, 10 * (i2 / o2 - 1)) + s2;
      },
      easeOutExpo: function(i2, s2, h2, o2) {
        return i2 === o2 ? s2 + h2 : h2 * (-Math.pow(2, -10 * i2 / o2) + 1) + s2;
      },
      easeInOutExpo: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * Math.pow(2, 10 * (i2 - 1)) + s2 : h2 / 2 * (-Math.pow(2, -10 * --i2) + 2) + s2;
      },
      easeInCirc: function(i2, s2, h2, o2) {
        return -h2 * (Math.sqrt(1 - (i2 /= o2) * i2) - 1) + s2;
      },
      easeOutCirc: function(i2, s2, h2, o2) {
        return h2 * Math.sqrt(1 - (i2 = i2 / o2 - 1) * i2) + s2;
      },
      easeInOutCirc: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? -h2 / 2 * (Math.sqrt(1 - i2 * i2) - 1) + s2 : h2 / 2 * (Math.sqrt(1 - (i2 -= 2) * i2) + 1) + s2;
      },
      easeInElastic: function(i2, s2, h2, o2) {
        var r2, a2, p2;
        return p2 = 1.70158, a2 = 0, r2 = h2, i2 === 0 || (i2 /= o2), a2 || (a2 = o2 * 0.3), r2 < Math.abs(h2) ? (r2 = h2, p2 = a2 / 4) : p2 = a2 / (2 * Math.PI) * Math.asin(h2 / r2), -(r2 * Math.pow(2, 10 * (i2 -= 1)) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a2)) + s2;
      },
      easeOutElastic: function(i2, s2, h2, o2) {
        var r2, a2, p2;
        return p2 = 1.70158, a2 = 0, r2 = h2, i2 === 0 || (i2 /= o2), a2 || (a2 = o2 * 0.3), r2 < Math.abs(h2) ? (r2 = h2, p2 = a2 / 4) : p2 = a2 / (2 * Math.PI) * Math.asin(h2 / r2), r2 * Math.pow(2, -10 * i2) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a2) + h2 + s2;
      },
      easeInOutElastic: function(i2, s2, h2, o2) {
        var r2, a2, p2;
        return p2 = 1.70158, a2 = 0, r2 = h2, i2 === 0 || (i2 /= o2 / 2), a2 || (a2 = o2 * (0.3 * 1.5)), r2 < Math.abs(h2) ? (r2 = h2, p2 = a2 / 4) : p2 = a2 / (2 * Math.PI) * Math.asin(h2 / r2), i2 < 1 ? -0.5 * (r2 * Math.pow(2, 10 * (i2 -= 1)) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a2)) + s2 : r2 * Math.pow(2, -10 * (i2 -= 1)) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a2) * 0.5 + h2 + s2;
      },
      easeInBack: function(i2, s2, h2, o2, r2) {
        return r2 === undefined && (r2 = 1.70158), h2 * (i2 /= o2) * i2 * ((r2 + 1) * i2 - r2) + s2;
      },
      easeOutBack: function(i2, s2, h2, o2, r2) {
        return r2 === undefined && (r2 = 1.70158), h2 * ((i2 = i2 / o2 - 1) * i2 * ((r2 + 1) * i2 + r2) + 1) + s2;
      },
      easeInOutBack: function(i2, s2, h2, o2, r2) {
        return r2 === undefined && (r2 = 1.70158), (i2 /= o2 / 2) < 1 ? h2 / 2 * (i2 * i2 * (((r2 *= 1.525) + 1) * i2 - r2)) + s2 : h2 / 2 * ((i2 -= 2) * i2 * (((r2 *= 1.525) + 1) * i2 + r2) + 2) + s2;
      },
      easeInBounce: function(i2, s2, h2, o2) {
        var r2;
        return r2 = e2.easeOutBounce(o2 - i2, 0, h2, o2), h2 - r2 + s2;
      },
      easeOutBounce: function(i2, s2, h2, o2) {
        return (i2 /= o2) < 1 / 2.75 ? h2 * (7.5625 * i2 * i2) + s2 : i2 < 2 / 2.75 ? h2 * (7.5625 * (i2 -= 1.5 / 2.75) * i2 + 0.75) + s2 : i2 < 2.5 / 2.75 ? h2 * (7.5625 * (i2 -= 2.25 / 2.75) * i2 + 0.9375) + s2 : h2 * (7.5625 * (i2 -= 2.625 / 2.75) * i2 + 0.984375) + s2;
      },
      easeInOutBounce: function(i2, s2, h2, o2) {
        var r2;
        return i2 < o2 / 2 ? (r2 = e2.easeInBounce(i2 * 2, 0, h2, o2), r2 * 0.5 + s2) : (r2 = e2.easeOutBounce(i2 * 2 - o2, 0, h2, o2), r2 * 0.5 + h2 * 0.5 + s2);
      }
    }, n2(e2);
  }).call(S2);
})(W);
var O = W.exports;
var v2 = /* @__PURE__ */ M2(O);
function x2(l2, t2) {
  if (l2) {
    if (typeof l2 == "function")
      return l2;
    if (typeof l2 == "string")
      return v2[l2];
  } else
    return v2[t2];
}

class P {
  constructor(t2) {
    this.viewport = t2, this.touches = [], this.addListeners();
  }
  addListeners() {
    this.viewport.eventMode = "static", this.viewport.forceHitArea || (this.viewport.hitArea = new Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.viewport.on("pointerdown", this.down, this), this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this), this.viewport.on("pointerup", this.up, this), this.viewport.on("pointerupoutside", this.up, this), this.viewport.on("pointercancel", this.up, this), this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this), this.wheelFunction = (t2) => this.handleWheel(t2), this.viewport.options.events.domElement.addEventListener("wheel", this.wheelFunction, { passive: this.viewport.options.passiveWheel }), this.isMouseDown = false;
  }
  destroy() {
    var t2;
    (t2 = this.viewport.options.events.domElement) == null || t2.removeEventListener("wheel", this.wheelFunction);
  }
  down(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    if (t2.pointerType === "mouse" ? this.isMouseDown = true : this.get(t2.pointerId) || this.touches.push({ id: t2.pointerId, last: null }), this.count() === 1) {
      this.last = t2.global.clone();
      const n2 = this.viewport.plugins.get("decelerate", true), i2 = this.viewport.plugins.get("bounce", true);
      (!n2 || !n2.isActive()) && (!i2 || !i2.isActive()) ? this.clickedAvailable = true : this.clickedAvailable = false;
    } else
      this.clickedAvailable = false;
    this.viewport.plugins.down(t2) && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  clear() {
    this.isMouseDown = false, this.touches = [], this.last = null;
  }
  checkThreshold(t2) {
    return Math.abs(t2) >= this.viewport.threshold;
  }
  move(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e2 = this.viewport.plugins.move(t2);
    if (this.clickedAvailable && this.last) {
      const n2 = t2.global.x - this.last.x, i2 = t2.global.y - this.last.y;
      (this.checkThreshold(n2) || this.checkThreshold(i2)) && (this.clickedAvailable = false);
    }
    e2 && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  up(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    t2.pointerType === "mouse" && (this.isMouseDown = false), t2.pointerType !== "mouse" && this.remove(t2.pointerId);
    const e2 = this.viewport.plugins.up(t2);
    this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
      event: t2,
      screen: this.last,
      world: this.viewport.toWorld(this.last),
      viewport: this.viewport
    }), this.clickedAvailable = false), e2 && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  getPointerPosition(t2) {
    const e2 = new Point;
    return this.viewport.options.events.mapPositionToPoint(e2, t2.clientX, t2.clientY), e2;
  }
  handleWheel(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e2 = this.viewport.toLocal(this.getPointerPosition(t2));
    this.viewport.left <= e2.x && e2.x <= this.viewport.right && this.viewport.top <= e2.y && e2.y <= this.viewport.bottom && this.viewport.plugins.wheel(t2) && !this.viewport.options.passiveWheel && t2.preventDefault();
  }
  pause() {
    this.touches = [], this.isMouseDown = false;
  }
  get(t2) {
    for (const e2 of this.touches)
      if (e2.id === t2)
        return e2;
    return null;
  }
  remove(t2) {
    for (let e2 = 0;e2 < this.touches.length; e2++)
      if (this.touches[e2].id === t2) {
        this.touches.splice(e2, 1);
        return;
      }
  }
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
}
var m2 = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];

class C {
  constructor(t2) {
    this.viewport = t2, this.list = [], this.plugins = {};
  }
  add(t2, e2, n2 = m2.length) {
    const i2 = this.plugins[t2];
    i2 && i2.destroy(), this.plugins[t2] = e2;
    const s2 = m2.indexOf(t2);
    s2 !== -1 && m2.splice(s2, 1), m2.splice(n2, 0, t2), this.sort();
  }
  get(t2, e2) {
    var n2;
    return e2 && (n2 = this.plugins[t2]) != null && n2.paused ? null : this.plugins[t2];
  }
  update(t2) {
    for (const e2 of this.list)
      e2.update(t2);
  }
  resize() {
    for (const t2 of this.list)
      t2.resize();
  }
  reset() {
    for (const t2 of this.list)
      t2.reset();
  }
  removeAll() {
    this.list.forEach((t2) => {
      t2.destroy();
    }), this.plugins = {}, this.sort();
  }
  remove(t2) {
    var e2;
    this.plugins[t2] && ((e2 = this.plugins[t2]) == null || e2.destroy(), delete this.plugins[t2], this.viewport.emit("plugin-remove", t2), this.sort());
  }
  pause(t2) {
    var e2;
    (e2 = this.plugins[t2]) == null || e2.pause();
  }
  resume(t2) {
    var e2;
    (e2 = this.plugins[t2]) == null || e2.resume();
  }
  sort() {
    this.list = [];
    for (const t2 of m2)
      this.plugins[t2] && this.list.push(this.plugins[t2]);
  }
  down(t2) {
    let e2 = false;
    for (const n2 of this.list)
      n2.down(t2) && (e2 = true);
    return e2;
  }
  move(t2) {
    let e2 = false;
    for (const n2 of this.viewport.plugins.list)
      n2.move(t2) && (e2 = true);
    return e2;
  }
  up(t2) {
    let e2 = false;
    for (const n2 of this.list)
      n2.up(t2) && (e2 = true);
    return e2;
  }
  wheel(t2) {
    let e2 = false;
    for (const n2 of this.list)
      n2.wheel(t2) && (e2 = true);
    return e2;
  }
}

class u2 {
  constructor(t2) {
    this.parent = t2, this.paused = false;
  }
  destroy() {}
  down(t2) {
    return false;
  }
  move(t2) {
    return false;
  }
  up(t2) {
    return false;
  }
  wheel(t2) {
    return false;
  }
  update(t2) {}
  resize() {}
  reset() {}
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
}
var I = {
  removeOnInterrupt: false,
  ease: "linear",
  time: 1000
};

class k2 extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.startWidth = null, this.startHeight = null, this.deltaWidth = null, this.deltaHeight = null, this.width = null, this.height = null, this.time = 0, this.options = Object.assign({}, I, e2), this.options.ease = x2(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0;
  }
  setupPosition() {
    typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = false) : this.keepCenter = true;
  }
  setupZoom() {
    this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight);
  }
  down() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), false;
  }
  complete() {
    this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
  }
  update(t2) {
    if (this.paused)
      return;
    this.time += t2;
    const e2 = new Point(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const n2 = this.parent.width, i2 = this.parent.height;
      this.complete(), (n2 !== this.parent.width || i2 !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e2, type: "animate" });
    } else {
      const n2 = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const i2 = this.startWidth, s2 = this.deltaWidth;
        this.parent.fitWidth(i2 + s2 * n2, this.keepCenter, this.height === null);
      }
      if (this.height !== null) {
        const i2 = this.startHeight, s2 = this.deltaHeight;
        this.parent.fitHeight(i2 + s2 * n2, this.keepCenter, this.width === null);
      }
      if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
        const i2 = this.startX, s2 = this.startY, h2 = this.deltaX, o2 = this.deltaY, r2 = new Point(this.parent.x, this.parent.y);
        this.parent.moveCenter(i2 + h2 * n2, s2 + o2 * n2), this.parent.emit("moved", { viewport: this.parent, original: r2, type: "animate" });
      }
      (this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e2, type: "animate" });
    }
  }
}
var Y = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};

class X extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, Y, e2), this.ease = x2(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = true : this.options.sides === "horizontal" ? (this.right = this.left = true, this.top = this.bottom = false) : this.options.sides === "vertical" ? (this.left = this.right = false, this.top = this.bottom = true) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = false;
    const n2 = this.options.underflow.toLowerCase();
    n2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = n2.indexOf("left") !== -1 ? -1 : n2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = n2.indexOf("top") !== -1 ? -1 : n2.indexOf("bottom") !== -1 ? 1 : 0), this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    return this.toX = this.toY = null, false;
  }
  up() {
    return this.bounce(), false;
  }
  update(t2) {
    if (!this.paused) {
      if (this.bounce(), this.toX) {
        const e2 = this.toX;
        e2.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), e2.time >= this.options.time ? (this.parent.x = e2.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(e2.time, e2.start, e2.delta, this.options.time);
      }
      if (this.toY) {
        const e2 = this.toY;
        e2.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), e2.time >= this.options.time ? (this.parent.y = e2.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(e2.time, e2.start, e2.delta, this.options.time);
      }
    }
  }
  calcUnderflowX() {
    let t2;
    switch (this.underflowX) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        t2 = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return t2;
  }
  calcUnderflowY() {
    let t2;
    switch (this.underflowY) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        t2 = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return t2;
  }
  oob() {
    const t2 = this.options.bounceBox;
    if (t2) {
      const e2 = typeof t2.x > "u" ? 0 : t2.x, n2 = typeof t2.y > "u" ? 0 : t2.y, i2 = typeof t2.width > "u" ? this.parent.worldWidth : t2.width, s2 = typeof t2.height > "u" ? this.parent.worldHeight : t2.height;
      return {
        left: this.parent.left < e2,
        right: this.parent.right > i2,
        top: this.parent.top < n2,
        bottom: this.parent.bottom > s2,
        topLeft: new Point(e2 * this.parent.scale.x, n2 * this.parent.scale.y),
        bottomRight: new Point(i2 * this.parent.scale.x - this.parent.screenWidth, s2 * this.parent.scale.y - this.parent.screenHeight)
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Point(0, 0),
      bottomRight: new Point(this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth, this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight)
    };
  }
  bounce() {
    var s2, h2;
    if (this.paused)
      return;
    let t2, e2 = this.parent.plugins.get("decelerate", true);
    e2 && (e2.x || e2.y) && (e2.x && e2.percentChangeX === ((s2 = e2.options) == null ? undefined : s2.friction) || e2.y && e2.percentChangeY === ((h2 = e2.options) == null ? undefined : h2.friction)) && (t2 = this.oob(), (t2.left && this.left || t2.right && this.right) && (e2.percentChangeX = this.options.friction), (t2.top && this.top || t2.bottom && this.bottom) && (e2.percentChangeY = this.options.friction));
    const n2 = this.parent.plugins.get("drag", true) || {}, i2 = this.parent.plugins.get("pinch", true) || {};
    if (e2 = e2 || {}, !(n2 != null && n2.active) && !(i2 != null && i2.active) && (!this.toX || !this.toY) && (!e2.x || !e2.y)) {
      t2 = t2 || this.oob();
      const { topLeft: o2, bottomRight: r2 } = t2;
      if (!this.toX && !e2.x) {
        let a2 = null;
        t2.left && this.left ? a2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -o2.x : t2.right && this.right && (a2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -r2.x), a2 !== null && this.parent.x !== a2 && (this.toX = { time: 0, start: this.parent.x, delta: a2 - this.parent.x, end: a2 }, this.parent.emit("bounce-x-start", this.parent));
      }
      if (!this.toY && !e2.y) {
        let a2 = null;
        t2.top && this.top ? a2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -o2.y : t2.bottom && this.bottom && (a2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -r2.y), a2 !== null && this.parent.y !== a2 && (this.toY = { time: 0, start: this.parent.y, delta: a2 - this.parent.y, end: a2 }, this.parent.emit("bounce-y-start", this.parent));
      }
    }
  }
  reset() {
    this.toX = this.toY = null, this.bounce();
  }
}
var z = {
  left: false,
  right: false,
  top: false,
  bottom: false,
  direction: null,
  underflow: "center"
};

class A extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, z, e2), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null), this.parseUnderflow(), this.last = { x: null, y: null, scaleX: null, scaleY: null }, this.update();
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "none" ? this.noUnderflow = true : t2 === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = false) : (this.underflowX = t2.indexOf("left") !== -1 ? -1 : t2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t2.indexOf("top") !== -1 ? -1 : t2.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = false);
  }
  move() {
    return this.update(), false;
  }
  update() {
    if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
      return;
    const t2 = new Point(this.parent.x, this.parent.y), e2 = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let n2 = false;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x !== 0 && (this.parent.x = 0, n2 = true);
            break;
          case 1:
            this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, n2 = true);
            break;
          default:
            this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, n2 = true);
        }
      else
        this.options.left !== null && this.parent.left < (this.options.left === true ? 0 : this.options.left) && (this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x, e2.x = 0, n2 = true), this.options.right !== null && this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, e2.x = 0, n2 = true);
      n2 && this.parent.emit("moved", {
        viewport: this.parent,
        original: t2,
        type: "clamp-x"
      });
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let n2 = false;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y !== 0 && (this.parent.y = 0, n2 = true);
            break;
          case 1:
            this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, n2 = true);
            break;
          default:
            this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, n2 = true);
        }
      else
        this.options.top !== null && this.parent.top < (this.options.top === true ? 0 : this.options.top) && (this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y, e2.y = 0, n2 = true), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, e2.y = 0, n2 = true);
      n2 && this.parent.emit("moved", {
        viewport: this.parent,
        original: t2,
        type: "clamp-y"
      });
    }
    this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
}
var T = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};

class _ extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, T, e2), this.clamp();
  }
  resize() {
    this.clamp();
  }
  clamp() {
    if (!this.paused) {
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && t2 < this.options.minWidth) {
          const n2 = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n2, t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxWidth !== null && t2 > this.options.maxWidth) {
          const n2 = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n2, t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.minHeight !== null && e2 < this.options.minHeight) {
          const n2 = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n2, t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxHeight !== null && e2 > this.options.maxHeight) {
          const n2 = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n2, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
      } else if (this.options.minScale || this.options.maxScale) {
        const t2 = { x: null, y: null }, e2 = { x: null, y: null };
        if (typeof this.options.minScale == "number")
          t2.x = this.options.minScale, t2.y = this.options.minScale;
        else if (this.options.minScale !== null) {
          const s2 = this.options.minScale;
          t2.x = typeof s2.x > "u" ? null : s2.x, t2.y = typeof s2.y > "u" ? null : s2.y;
        }
        if (typeof this.options.maxScale == "number")
          e2.x = this.options.maxScale, e2.y = this.options.maxScale;
        else if (this.options.maxScale !== null) {
          const s2 = this.options.maxScale;
          e2.x = typeof s2.x > "u" ? null : s2.x, e2.y = typeof s2.y > "u" ? null : s2.y;
        }
        let n2 = this.parent.scale.x, i2 = this.parent.scale.y;
        t2.x !== null && n2 < t2.x && (n2 = t2.x), e2.x !== null && n2 > e2.x && (n2 = e2.x), t2.y !== null && i2 < t2.y && (i2 = t2.y), e2.y !== null && i2 > e2.y && (i2 = e2.y), (n2 !== this.parent.scale.x || i2 !== this.parent.scale.y) && (this.parent.scale.set(n2, i2), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
      }
    }
  }
  reset() {
    this.clamp();
  }
}
var L = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
};
var d2 = 16;

class E extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, L, e2), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", (n2) => this.handleMoved(n2));
  }
  down() {
    return this.saved = [], this.x = this.y = null, false;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused)
      return false;
    const t2 = this.parent.input.count();
    return (t2 === 1 || t2 > 1 && !this.parent.plugins.get("pinch", true)) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), false;
  }
  handleMoved(t2) {
    if (this.saved.length) {
      const e2 = this.saved[this.saved.length - 1];
      t2.type === "clamp-x" && t2.original ? e2.x === t2.original.x && (e2.x = this.parent.x) : t2.type === "clamp-y" && t2.original && e2.y === t2.original.y && (e2.y = this.parent.y);
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const t2 = performance.now();
      for (const e2 of this.saved)
        if (e2.time >= t2 - 100) {
          const n2 = t2 - e2.time;
          this.x = (this.parent.x - e2.x) / n2, this.y = (this.parent.y - e2.y) / n2, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
          break;
        }
    }
    return false;
  }
  activate(t2) {
    t2 = t2 || {}, typeof t2.x < "u" && (this.x = t2.x, this.percentChangeX = this.options.friction), typeof t2.y < "u" && (this.y = t2.y, this.percentChangeY = this.options.friction);
  }
  update(t2) {
    if (this.paused)
      return;
    const e2 = this.x || this.y, n2 = this.timeSinceRelease, i2 = this.timeSinceRelease + t2;
    if (this.x) {
      const s2 = this.percentChangeX, h2 = Math.log(s2);
      this.parent.x += this.x * d2 / h2 * (Math.pow(s2, i2 / d2) - Math.pow(s2, n2 / d2)), this.x *= Math.pow(this.percentChangeX, t2 / d2);
    }
    if (this.y) {
      const s2 = this.percentChangeY, h2 = Math.log(s2);
      this.parent.y += this.y * d2 / h2 * (Math.pow(s2, i2 / d2) - Math.pow(s2, n2 / d2)), this.y *= Math.pow(this.percentChangeY, t2 / d2);
    }
    this.timeSinceRelease += t2, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), e2 && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
  }
  reset() {
    this.x = this.y = null;
  }
}
var D = {
  direction: "all",
  pressDrag: true,
  wheel: true,
  wheelScroll: 1,
  reverse: false,
  clampWheel: false,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: false,
  lineHeight: 20,
  wheelSwapAxes: false
};

class U extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.windowEventHandlers = [], this.options = Object.assign({}, D, e2), this.moved = false, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = false, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  handleKeyPresses(t2) {
    const e2 = (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = true);
    }, n2 = (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = false);
    };
    this.addWindowEventHandler("keyup", n2), this.addWindowEventHandler("keydown", e2);
  }
  addWindowEventHandler(t2, e2) {
    typeof window > "u" || (window.addEventListener(t2, e2), this.windowEventHandlers.push({ event: t2, handler: e2 }));
  }
  destroy() {
    typeof window > "u" || this.windowEventHandlers.forEach(({ event: t2, handler: e2 }) => {
      window.removeEventListener(t2, e2);
    });
  }
  mouseButtons(t2) {
    !t2 || t2 === "all" ? this.mouse = [true, true, true] : this.mouse = [
      t2.indexOf("left") !== -1,
      t2.indexOf("middle") !== -1,
      t2.indexOf("right") !== -1
    ];
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t2.includes("left") ? this.underflowX = -1 : t2.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t2.includes("top") ? this.underflowY = -1 : t2.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0);
  }
  checkButtons(t2) {
    const e2 = t2.pointerType === "mouse", n2 = this.parent.input.count();
    return !!((n2 === 1 || n2 > 1 && !this.parent.plugins.get("pinch", true)) && (!e2 || this.mouse[t2.button]));
  }
  checkKeyPress(t2) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t2.data.pointerType === "touch";
  }
  down(t2) {
    return this.paused || !this.options.pressDrag ? false : this.checkButtons(t2) && this.checkKeyPress(t2) ? (this.last = { x: t2.global.x, y: t2.global.y }, (this.parent.parent || this.parent).toLocal(this.last, undefined, this.last), this.current = t2.pointerId, true) : (this.last = null, false);
  }
  get active() {
    return this.moved;
  }
  move(t2) {
    if (this.paused || !this.options.pressDrag)
      return false;
    if (this.last && this.current === t2.data.pointerId) {
      const e2 = t2.global.x, n2 = t2.global.y, i2 = this.parent.input.count();
      if (i2 === 1 || i2 > 1 && !this.parent.plugins.get("pinch", true)) {
        const s2 = { x: e2, y: n2 };
        (this.parent.parent || this.parent).toLocal(s2, undefined, s2);
        const h2 = s2.x - this.last.x, o2 = s2.y - this.last.y;
        if (this.moved || this.xDirection && this.parent.input.checkThreshold(h2) || this.yDirection && this.parent.input.checkThreshold(o2))
          return this.xDirection && (this.parent.x += (s2.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (s2.y - this.last.y) * this.options.factor), this.last = s2, this.moved || this.parent.emit("drag-start", {
            event: t2,
            screen: new Point(this.last.x, this.last.y),
            world: this.parent.toWorld(new Point(this.last.x, this.last.y)),
            viewport: this.parent
          }), this.moved = true, this.parent.emit("moved", { viewport: this.parent, type: "drag" }), true;
      } else
        this.moved = false;
    }
    return false;
  }
  up(t2) {
    if (this.paused)
      return false;
    const e2 = this.parent.input.touches;
    if (e2.length === 1) {
      const n2 = e2[0];
      return n2.last && (this.last = { x: n2.last.x, y: n2.last.y }, this.current = n2.id), this.moved = false, true;
    } else if (this.last && this.moved) {
      const n2 = new Point(this.last.x, this.last.y);
      return (this.parent.parent || this.parent).toGlobal(n2, n2, true), this.parent.emit("drag-end", {
        event: t2,
        screen: n2,
        world: this.parent.toWorld(n2),
        viewport: this.parent
      }), this.last = null, this.moved = false, true;
    }
    return false;
  }
  wheel(t2) {
    if (this.paused)
      return false;
    if (this.options.wheel) {
      const e2 = this.parent.plugins.get("wheel", true);
      if (!e2 || !e2.options.wheelZoom && !t2.ctrlKey) {
        const n2 = t2.deltaMode ? this.options.lineHeight : 1, i2 = [t2.deltaX, t2.deltaY], [s2, h2] = this.options.wheelSwapAxes ? i2.reverse() : i2;
        return this.xDirection && (this.parent.x += s2 * n2 * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += h2 * n2 * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.options.passiveWheel || t2.preventDefault(), this.parent.options.stopPropagation && t2.stopPropagation(), true;
      }
    }
    return false;
  }
  resume() {
    this.last = null, this.paused = false;
  }
  clamp() {
    const t2 = this.parent.plugins.get("decelerate", true) || {};
    if (this.options.clampWheel !== "y")
      if (this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      else
        this.parent.left < 0 ? (this.parent.x = 0, t2.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t2.x = 0);
    if (this.options.clampWheel !== "x")
      if (this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      else
        this.parent.top < 0 && (this.parent.y = 0, t2.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t2.y = 0);
  }
}
var F = {
  speed: 0,
  acceleration: null,
  radius: null
};

class B extends u2 {
  constructor(t2, e2, n2 = {}) {
    super(t2), this.target = e2, this.options = Object.assign({}, F, n2), this.velocity = { x: 0, y: 0 };
  }
  update(t2) {
    if (this.paused)
      return;
    const e2 = this.parent.center;
    let n2 = this.target.x, i2 = this.target.y;
    if (this.options.radius)
      if (Math.sqrt(Math.pow(this.target.y - e2.y, 2) + Math.pow(this.target.x - e2.x, 2)) > this.options.radius) {
        const r2 = Math.atan2(this.target.y - e2.y, this.target.x - e2.x);
        n2 = this.target.x - Math.cos(r2) * this.options.radius, i2 = this.target.y - Math.sin(r2) * this.options.radius;
      } else
        return;
    const s2 = n2 - e2.x, h2 = i2 - e2.y;
    if (s2 || h2)
      if (this.options.speed)
        if (this.options.acceleration) {
          const o2 = Math.atan2(i2 - e2.y, n2 - e2.x), r2 = Math.sqrt(Math.pow(s2, 2) + Math.pow(h2, 2));
          if (r2) {
            const a2 = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            r2 > a2 ? this.velocity = {
              x: Math.min(this.velocity.x + (this.options.acceleration * t2, this.options.speed)),
              y: Math.min(this.velocity.y + (this.options.acceleration * t2, this.options.speed))
            } : this.velocity = {
              x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
              y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
            };
            const p2 = Math.cos(o2) * this.velocity.x, f2 = Math.sin(o2) * this.velocity.y, g2 = Math.abs(p2) > Math.abs(s2) ? n2 : e2.x + p2, w2 = Math.abs(f2) > Math.abs(h2) ? i2 : e2.y + f2;
            this.parent.moveCenter(g2, w2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const o2 = Math.atan2(i2 - e2.y, n2 - e2.x), r2 = Math.cos(o2) * this.options.speed, a2 = Math.sin(o2) * this.options.speed, p2 = Math.abs(r2) > Math.abs(s2) ? n2 : e2.x + r2, f2 = Math.abs(a2) > Math.abs(h2) ? i2 : e2.y + a2;
          this.parent.moveCenter(p2, f2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      else
        this.parent.moveCenter(n2, i2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
  }
}
var N2 = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: false,
  noDecelerate: false,
  linear: false,
  allowButtons: false
};

class V extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, N2, e2), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize();
  }
  resize() {
    const t2 = this.options.distance;
    t2 !== null ? (this.left = t2, this.top = t2, this.right = this.parent.screenWidth - t2, this.bottom = this.parent.screenHeight - t2) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom);
  }
  down() {
    return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), false;
  }
  move(t2) {
    if (this.paused || t2.pointerType !== "mouse" && t2.pointerId !== 1 || !this.options.allowButtons && t2.buttons !== 0)
      return false;
    const e2 = t2.global.x, n2 = t2.global.y;
    if (this.radiusSquared) {
      const i2 = this.parent.toScreen(this.parent.center);
      if (Math.pow(i2.x - e2, 2) + Math.pow(i2.y - n2, 2) >= this.radiusSquared) {
        const h2 = Math.atan2(i2.y - n2, i2.x - e2);
        this.options.linear ? (this.horizontal = Math.round(Math.cos(h2)) * this.options.speed * this.reverse * (60 / 1000), this.vertical = Math.round(Math.sin(h2)) * this.options.speed * this.reverse * (60 / 1000)) : (this.horizontal = Math.cos(h2) * this.options.speed * this.reverse * (60 / 1000), this.vertical = Math.sin(h2) * this.options.speed * this.reverse * (60 / 1000));
      } else
        this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0;
    } else
      this.left !== null && e2 < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1000) : this.right !== null && e2 > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1000) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && n2 < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1000) : this.bottom !== null && n2 > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1000) : (this.decelerateVertical(), this.vertical = 0);
    return false;
  }
  decelerateHorizontal() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.horizontal && t2 && !this.options.noDecelerate && t2.activate({ x: this.horizontal * this.options.speed * this.reverse / (1000 / 60) });
  }
  decelerateVertical() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.vertical && t2 && !this.options.noDecelerate && t2.activate({ y: this.vertical * this.options.speed * this.reverse / (1000 / 60) });
  }
  up() {
    return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), false;
  }
  update() {
    if (!this.paused && (this.horizontal || this.vertical)) {
      const t2 = this.parent.center;
      this.horizontal && (t2.x += this.horizontal * this.options.speed), this.vertical && (t2.y += this.vertical * this.options.speed), this.parent.moveCenter(t2), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
}
var Z = {
  noDrag: false,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
};
var R = new Point;

class j2 extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.active = false, this.pinching = false, this.moved = false, this.options = Object.assign({}, Z, e2);
  }
  down() {
    return this.parent.input.count() >= 2 ? (this.active = true, true) : false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(t2) {
    if (this.paused || !this.active)
      return false;
    const { x: e2, y: n2 } = (this.parent.parent || this.parent).toLocal(t2.global, undefined, R), i2 = this.parent.input.touches;
    if (i2.length >= 2) {
      const s2 = i2[0], h2 = i2[1], o2 = s2.last && h2.last ? Math.sqrt(Math.pow(h2.last.x - s2.last.x, 2) + Math.pow(h2.last.y - s2.last.y, 2)) : null;
      if (s2.id === t2.pointerId ? s2.last = { x: e2, y: n2, data: t2 } : h2.id === t2.pointerId && (h2.last = { x: e2, y: n2, data: t2 }), o2) {
        let r2;
        const a2 = new Point(s2.last.x + (h2.last.x - s2.last.x) / 2, s2.last.y + (h2.last.y - s2.last.y) / 2);
        this.options.center || (r2 = this.parent.toLocal(a2, this.parent.parent || this.parent));
        let p2 = Math.sqrt(Math.pow(h2.last.x - s2.last.x, 2) + Math.pow(h2.last.y - s2.last.y, 2));
        p2 = p2 === 0 ? p2 = 0.0000000001 : p2;
        const f2 = (1 - o2 / p2) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        this.isAxisX() && (this.parent.scale.x += f2), this.isAxisY() && (this.parent.scale.y += f2), this.parent.emit("zoomed", {
          viewport: this.parent,
          type: "pinch",
          center: a2
        });
        const g2 = this.parent.plugins.get("clamp-zoom", true);
        if (g2 && g2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const w2 = (this.parent.parent || this.parent).toLocal(r2, this.parent);
          this.parent.x += (a2.x - w2.x) * this.options.factor, this.parent.y += (a2.y - w2.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        !this.options.noDrag && this.lastCenter && (this.parent.x += (a2.x - this.lastCenter.x) * this.options.factor, this.parent.y += (a2.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" })), this.lastCenter = a2, this.moved = true;
      } else
        this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = true);
      return true;
    }
    return false;
  }
  up() {
    return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = false, this.lastCenter = null, this.pinching = false, this.moved = false, this.parent.emit("pinch-end", this.parent), true) : false;
  }
}
var K = {
  topLeft: false,
  friction: 0.8,
  time: 1000,
  ease: "easeInOutSine",
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false
};

class q extends u2 {
  constructor(t2, e2, n2, i2 = {}) {
    super(t2), this.options = Object.assign({}, K, i2), this.ease = x2(i2.ease, "easeInOutSine"), this.x = e2, this.y = n2, this.options.forceStart && this.snapStart();
  }
  snapStart() {
    this.percent = 0, this.snapping = { time: 0 };
    const t2 = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - t2.x, this.deltaY = this.y - t2.y, this.startX = t2.x, this.startY = t2.y, this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), false;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const t2 = this.parent.plugins.get("decelerate", true);
      t2 && (t2.x || t2.y) && (t2.percentChangeX = t2.percentChangeY = this.options.friction);
    }
    return false;
  }
  update(t2) {
    if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
      if (this.snapping) {
        const e2 = this.snapping;
        e2.time += t2;
        let n2, i2, s2;
        const h2 = this.startX, o2 = this.startY, r2 = this.deltaX, a2 = this.deltaY;
        if (e2.time > this.options.time)
          n2 = true, i2 = h2 + r2, s2 = o2 + a2;
        else {
          const p2 = this.ease(e2.time, 0, 1, this.options.time);
          i2 = h2 + r2 * p2, s2 = o2 + a2 * p2;
        }
        this.options.topLeft ? this.parent.moveCorner(i2, s2) : this.parent.moveCenter(i2, s2), this.parent.emit("moved", { viewport: this.parent, type: "snap" }), n2 && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null);
      } else {
        const e2 = this.options.topLeft ? this.parent.corner : this.parent.center;
        (e2.x !== this.x || e2.y !== this.y) && this.snapStart();
      }
  }
}
var Q = {
  width: 0,
  height: 0,
  time: 1000,
  ease: "easeInOutSine",
  center: null,
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false,
  noMove: false
};

class G extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, Q, e2), this.ease = x2(this.options.ease), this.xIndependent = false, this.yIndependent = false, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t2.screenWidth / this.options.width, this.xIndependent = true), this.options.height > 0 && (this.yScale = t2.screenHeight / this.options.height, this.yIndependent = true), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t2.container.scale.x = this.xScale, t2.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : e2.forceStart && this.createSnapping();
  }
  createSnapping() {
    const t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight, n2 = this.parent.screenWidth / this.xScale, i2 = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: t2,
      startY: e2,
      deltaX: n2 - t2,
      deltaY: i2 - e2
    }, this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), false;
  }
  update(t2) {
    if (this.paused || this.options.interrupt && this.parent.input.count() !== 0)
      return;
    let e2;
    if (!this.options.center && !this.options.noMove && (e2 = this.parent.center), !this.snapping)
      (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
    else if (this.snapping) {
      const n2 = this.snapping;
      if (n2.time += t2, n2.time >= this.options.time)
        this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
      else {
        const s2 = this.snapping, h2 = this.ease(s2.time, s2.startX, s2.deltaX, this.options.time), o2 = this.ease(s2.time, s2.startY, s2.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / h2, this.parent.scale.y = this.parent.screenHeight / o2;
      }
      const i2 = this.parent.plugins.get("clamp-zoom", true);
      i2 && i2.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(e2));
    }
  }
  resume() {
    this.snapping = null, super.resume();
  }
}
var J = {
  percent: 0.1,
  smooth: false,
  interrupt: true,
  reverse: false,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: false,
  wheelZoom: true
};

class $2 extends u2 {
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, J, e2), this.keyIsPressed = false, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  handleKeyPresses(t2) {
    typeof window > "u" || (window.addEventListener("keydown", (e2) => {
      t2.includes(e2.code) && (this.keyIsPressed = true);
    }), window.addEventListener("keyup", (e2) => {
      t2.includes(e2.code) && (this.keyIsPressed = false);
    }));
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    return this.options.interrupt && (this.smoothing = null), false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const t2 = this.smoothingCenter, e2 = this.smoothing;
      let n2;
      this.options.center || (n2 = this.parent.toLocal(t2)), this.isAxisX() && (this.parent.scale.x += e2.x), this.isAxisY() && (this.parent.scale.y += e2.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const i2 = this.parent.plugins.get("clamp-zoom", true);
      if (i2 && i2.clamp(), this.options.center)
        this.parent.moveCenter(this.options.center);
      else {
        const s2 = this.parent.parent || this.parent;
        s2.toLocal(n2, this.parent, n2);
        const h2 = s2.toLocal(t2);
        this.parent.x += h2.x - n2.x, this.parent.y += h2.y - n2.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, typeof this.options.smooth == "number" && this.smoothingCount >= this.options.smooth && (this.smoothing = null);
    }
  }
  pinch(t2) {
    if (this.paused)
      return;
    const e2 = this.parent.input.getPointerPosition(t2), n2 = -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 200, i2 = Math.pow(2, (1 + this.options.percent) * n2);
    let s2;
    this.options.center || (s2 = this.parent.toLocal(e2)), this.isAxisX() && (this.parent.scale.x *= i2), this.isAxisY() && (this.parent.scale.y *= i2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const h2 = this.parent.plugins.get("clamp-zoom", true);
    if (h2 && h2.clamp(), this.options.center)
      this.parent.moveCenter(this.options.center);
    else {
      const o2 = this.parent.parent || this.parent;
      o2.toLocal(s2, this.parent, s2);
      const r2 = o2.toLocal(e2);
      this.parent.x += r2.x - s2.x, this.parent.y += r2.y - s2.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit("wheel-start", { event: t2, viewport: this.parent });
  }
  wheel(t2) {
    if (this.paused || !this.checkKeyPress())
      return false;
    if (t2.ctrlKey && this.options.trackpadPinch)
      this.pinch(t2);
    else if (this.options.wheelZoom) {
      const e2 = this.parent.input.getPointerPosition(t2), i2 = (this.options.reverse ? -1 : 1) * -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 500, s2 = Math.pow(2, (1 + this.options.percent) * i2);
      if (this.options.smooth) {
        const h2 = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + h2.x) * s2 - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + h2.y) * s2 - this.parent.scale.y) / this.options.smooth
        }, this.smoothingCount = 0, this.smoothingCenter = e2;
      } else {
        let h2;
        this.options.center || (h2 = this.parent.toLocal(e2)), this.isAxisX() && (this.parent.scale.x *= s2), this.isAxisY() && (this.parent.scale.y *= s2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const o2 = this.parent.plugins.get("clamp-zoom", true);
        if (o2 && o2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const r2 = this.parent.parent || this.parent;
          r2.toLocal(h2, this.parent, h2);
          const a2 = r2.toLocal(e2);
          this.parent.x += a2.x - h2.x, this.parent.y += a2.y - h2.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit("wheel-start", { event: t2, viewport: this.parent });
    }
    return !this.parent.options.passiveWheel;
  }
}
var tt = {
  screenWidth: typeof window > "u" ? 0 : window.innerWidth,
  screenHeight: typeof window > "u" ? 0 : window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: true,
  stopPropagation: false,
  forceHitArea: null,
  noTicker: false,
  disableOnContextMenu: false,
  ticker: Ticker.shared,
  allowPreserveDragOutside: false
};

class it extends Container {
  constructor(t2) {
    super(), this._disableOnContextMenu = (e2) => e2.preventDefault(), this.options = {
      ...tt,
      ...t2
    }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new P(this), this.plugins = new C(this);
  }
  destroy(t2) {
    var e2;
    !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && ((e2 = this.options.events.domElement) == null || e2.removeEventListener("contextmenu", this._disableOnContextMenu)), this.input.destroy(), super.destroy(t2);
  }
  update(t2) {
    this.pause || (this.plugins.update(t2), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = true : this.moving && (this.emit("moved-end", this), this.moving = false), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = true : this.zooming && (this.emit("zoomed-end", this), this.zooming = false)), this.forceHitArea || (this._hitAreaDefault = new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
      x: this.x,
      y: this.y,
      scaleX: this.scale.x,
      scaleY: this.scale.y
    }, this.emit("frame-end", this));
  }
  resize(t2 = typeof window > "u" ? 0 : window.innerWidth, e2 = typeof window > "u" ? 0 : window.innerHeight, n2, i2) {
    this.screenWidth = t2, this.screenHeight = e2, typeof n2 < "u" && (this._worldWidth = n2), typeof i2 < "u" && (this._worldHeight = i2), this.plugins.resize(), this.dirty = true;
  }
  get worldWidth() {
    return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
  }
  set worldWidth(t2) {
    this._worldWidth = t2, this.plugins.resize();
  }
  get worldHeight() {
    return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
  }
  set worldHeight(t2) {
    this._worldHeight = t2, this.plugins.resize();
  }
  getVisibleBounds() {
    return new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  toWorld(t2, e2) {
    return arguments.length === 2 ? this.toLocal(new Point(t2, e2)) : this.toLocal(t2);
  }
  toScreen(t2, e2) {
    return arguments.length === 2 ? this.toGlobal(new Point(t2, e2)) : this.toGlobal(t2);
  }
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  get center() {
    return new Point(this.worldScreenWidth / 2 - this.x / this.scale.x, this.worldScreenHeight / 2 - this.y / this.scale.y);
  }
  set center(t2) {
    this.moveCenter(t2);
  }
  moveCenter(...t2) {
    let e2, n2;
    typeof t2[0] == "number" ? (e2 = t2[0], n2 = t2[1]) : (e2 = t2[0].x, n2 = t2[0].y);
    const i2 = (this.worldScreenWidth / 2 - e2) * this.scale.x, s2 = (this.worldScreenHeight / 2 - n2) * this.scale.y;
    return (this.x !== i2 || this.y !== s2) && (this.position.set(i2, s2), this.plugins.reset(), this.dirty = true), this;
  }
  get corner() {
    return new Point(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(t2) {
    this.moveCorner(t2);
  }
  moveCorner(...t2) {
    let e2, n2;
    return t2.length === 1 ? (e2 = -t2[0].x * this.scale.x, n2 = -t2[0].y * this.scale.y) : (e2 = -t2[0] * this.scale.x, n2 = -t2[1] * this.scale.y), (e2 !== this.x || n2 !== this.y) && (this.position.set(e2, n2), this.plugins.reset(), this.dirty = true), this;
  }
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  findFitWidth(t2) {
    return this.screenWidth / t2;
  }
  findFitHeight(t2) {
    return this.screenHeight / t2;
  }
  findFit(t2, e2) {
    const n2 = this.screenWidth / t2, i2 = this.screenHeight / e2;
    return Math.min(n2, i2);
  }
  findCover(t2, e2) {
    const n2 = this.screenWidth / t2, i2 = this.screenHeight / e2;
    return Math.max(n2, i2);
  }
  fitWidth(t2 = this.worldWidth, e2, n2 = true, i2) {
    let s2;
    e2 && (s2 = this.center), this.scale.x = this.screenWidth / t2, n2 && (this.scale.y = this.scale.x);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !i2 && h2 && h2.clamp(), e2 && s2 && this.moveCenter(s2), this;
  }
  fitHeight(t2 = this.worldHeight, e2, n2 = true, i2) {
    let s2;
    e2 && (s2 = this.center), this.scale.y = this.screenHeight / t2, n2 && (this.scale.x = this.scale.y);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !i2 && h2 && h2.clamp(), e2 && s2 && this.moveCenter(s2), this;
  }
  fitWorld(t2) {
    let e2;
    t2 && (e2 = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const n2 = this.plugins.get("clamp-zoom", true);
    return n2 && n2.clamp(), t2 && e2 && this.moveCenter(e2), this;
  }
  fit(t2, e2 = this.worldWidth, n2 = this.worldHeight) {
    let i2;
    t2 && (i2 = this.center), this.scale.x = this.screenWidth / e2, this.scale.y = this.screenHeight / n2, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const s2 = this.plugins.get("clamp-zoom", true);
    return s2 && s2.clamp(), t2 && i2 && this.moveCenter(i2), this;
  }
  setZoom(t2, e2) {
    let n2;
    e2 && (n2 = this.center), this.scale.set(t2);
    const i2 = this.plugins.get("clamp-zoom", true);
    return i2 && i2.clamp(), e2 && n2 && this.moveCenter(n2), this;
  }
  zoomPercent(t2, e2) {
    return this.setZoom(this.scale.x + this.scale.x * t2, e2);
  }
  zoom(t2, e2) {
    return this.fitWidth(t2 + this.worldScreenWidth, e2), this;
  }
  get scaled() {
    return this.scale.x;
  }
  set scaled(t2) {
    this.setZoom(t2, true);
  }
  snapZoom(t2) {
    return this.plugins.add("snap-zoom", new G(this, t2)), this;
  }
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Point(this.worldWidth * this.scale.x - this.screenWidth, this.worldHeight * this.scale.y - this.screenHeight)
    };
  }
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(t2) {
    this.x = -t2 * this.scale.x + this.screenWidth, this.plugins.reset();
  }
  get left() {
    return -this.x / this.scale.x;
  }
  set left(t2) {
    this.x = -t2 * this.scale.x, this.plugins.reset();
  }
  get top() {
    return -this.y / this.scale.y;
  }
  set top(t2) {
    this.y = -t2 * this.scale.y, this.plugins.reset();
  }
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(t2) {
    this.y = -t2 * this.scale.y + this.screenHeight, this.plugins.reset();
  }
  get dirty() {
    return !!this._dirty;
  }
  set dirty(t2) {
    this._dirty = t2;
  }
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(t2) {
    t2 ? (this._forceHitArea = t2, this.hitArea = t2) : (this._forceHitArea = null, this.hitArea = new Rectangle(0, 0, this.worldWidth, this.worldHeight));
  }
  drag(t2) {
    return this.plugins.add("drag", new U(this, t2)), this;
  }
  clamp(t2) {
    return this.plugins.add("clamp", new A(this, t2)), this;
  }
  decelerate(t2) {
    return this.plugins.add("decelerate", new E(this, t2)), this;
  }
  bounce(t2) {
    return this.plugins.add("bounce", new X(this, t2)), this;
  }
  pinch(t2) {
    return this.plugins.add("pinch", new j2(this, t2)), this;
  }
  snap(t2, e2, n2) {
    return this.plugins.add("snap", new q(this, t2, e2, n2)), this;
  }
  follow(t2, e2) {
    return this.plugins.add("follow", new B(this, t2, e2)), this;
  }
  wheel(t2) {
    return this.plugins.add("wheel", new $2(this, t2)), this;
  }
  animate(t2) {
    return this.plugins.add("animate", new k2(this, t2)), this;
  }
  clampZoom(t2) {
    return this.plugins.add("clamp-zoom", new _(this, t2)), this;
  }
  mouseEdges(t2) {
    return this.plugins.add("mouse-edges", new V(this, t2)), this;
  }
  get pause() {
    return !!this._pause;
  }
  set pause(t2) {
    this._pause = t2, this.lastViewport = null, this.moving = false, this.zooming = false, t2 && this.input.pause();
  }
  ensureVisible(t2, e2, n2, i2, s2) {
    s2 && (n2 > this.worldScreenWidth || i2 > this.worldScreenHeight) && (this.fit(true, n2, i2), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
    let h2 = false;
    t2 < this.left ? (this.left = t2, h2 = true) : t2 + n2 > this.right && (this.right = t2 + n2, h2 = true), e2 < this.top ? (this.top = e2, h2 = true) : e2 + i2 > this.bottom && (this.bottom = e2 + i2, h2 = true), h2 && this.emit("moved", { viewport: this, type: "ensureVisible" });
  }
}

// src/lib/app.ts
var active_viewport = null;
async function app_create() {
  const app = new Application;
  await app.init({
    background: 2969622,
    width: 950,
    height: 600,
    antialias: true,
    autoDensity: true,
    resolution: window.devicePixelRatio,
    sharedTicker: true
  });
  return app;
}
function app_canvas_setup(app) {
  const canvas = app.canvas;
  canvas.addEventListener("wheel", (e2) => {
    e2.preventDefault();
  }, { passive: false });
  canvas.addEventListener("touchmove", (e2) => {
    e2.preventDefault();
  }, { passive: false });
  return canvas;
}
async function app_viewport_create(app) {
  const viewport = new it({
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: window.innerWidth,
    worldHeight: window.innerHeight,
    events: app.renderer.events,
    disableOnContextMenu: true
  });
  viewport.drag().pinch().wheel().decelerate();
  viewport.sortableChildren = true;
  active_viewport = viewport;
  return viewport;
}
function app_viewport_get() {
  return active_viewport;
}

// src/lib/hud.ts
function hud_create() {
  const hud = [];
  hud.push(hud_create_header());
  hud.push(hud_create_side_left());
  hud.push(hud_create_side_right());
  hud.push(hud_create_footer());
  return hud;
}
function hud_create_header() {
  const header = document.createElement("div");
  header.classList.add("hud-header", "has-background-primary-05", "has-text-primary-05-invert");
  header.style.display = "flex";
  header.style.alignItems = "center";
  header.style.justifyContent = "space-between";
  header.style.padding = "0 10px";
  const mission_name = document.createElement("div");
  mission_name.id = "mission-name";
  mission_name.classList.add("is-size-5", "mr-4", "has-text-info");
  header.appendChild(mission_name);
  const wave_info = document.createElement("div");
  wave_info.id = "wave-info";
  wave_info.classList.add("is-size-5");
  header.appendChild(wave_info);
  const lives = document.createElement("div");
  lives.id = "lives";
  lives.classList.add("is-size-5", "ml-auto", "has-text-danger");
  header.appendChild(lives);
  const gold = document.createElement("div");
  gold.id = "gold";
  gold.classList.add("is-size-5", "ml-4", "has-text-warning");
  header.appendChild(gold);
  const pause_div = document.createElement("div");
  pause_div.id = "pause";
  pause_div.classList.add("is-size-5", "ml-4", "is-clickable");
  pause_div.innerHTML = '<i class="fas fa-pause"></i>';
  header.appendChild(pause_div);
  const reset_div = document.createElement("div");
  reset_div.id = "reset";
  reset_div.classList.add("is-size-5", "ml-4", "is-clickable");
  reset_div.innerHTML = '<i class="fas fa-undo"></i>';
  reset_div.title = "Reset saves and restart";
  reset_div.onclick = () => {
    localStorage.removeItem("jdefense");
    location.reload();
  };
  header.appendChild(reset_div);
  return header;
}
function hud_create_footer() {
  const footer = document.createElement("div");
  footer.id = "hud-footer";
  footer.classList.add("hud-footer");
  return footer;
}
function hud_create_side_left() {
  const side_left = document.createElement("div");
  side_left.classList.add("hud-side-left");
  side_left.id = "hud-side-left";
  return side_left;
}
function hud_create_side_right() {
  const side_right = document.createElement("div");
  side_right.classList.add("hud-side-right");
  const log_div = document.createElement("div");
  log_div.id = "message-log";
  log_div.classList.add("content", "has-text-white", "p-2", "has-background-black-bis");
  log_div.style.width = "200px";
  log_div.style.maxHeight = "300px";
  log_div.style.overflowY = "auto";
  side_right.appendChild(log_div);
  return side_right;
}

// node_modules/bitecs/dist/index.mjs
var TYPES_ENUM = {
  i8: "i8",
  ui8: "ui8",
  ui8c: "ui8c",
  i16: "i16",
  ui16: "ui16",
  i32: "i32",
  ui32: "ui32",
  f32: "f32",
  f64: "f64",
  eid: "eid"
};
var TYPES_NAMES = {
  i8: "Int8",
  ui8: "Uint8",
  ui8c: "Uint8Clamped",
  i16: "Int16",
  ui16: "Uint16",
  i32: "Int32",
  ui32: "Uint32",
  eid: "Uint32",
  f32: "Float32",
  f64: "Float64"
};
var TYPES = {
  i8: Int8Array,
  ui8: Uint8Array,
  ui8c: Uint8ClampedArray,
  i16: Int16Array,
  ui16: Uint16Array,
  i32: Int32Array,
  ui32: Uint32Array,
  f32: Float32Array,
  f64: Float64Array,
  eid: Uint32Array
};
var UNSIGNED_MAX = {
  uint8: 2 ** 8,
  uint16: 2 ** 16,
  uint32: 2 ** 32
};
var roundToMultiple = (mul) => (x3) => Math.ceil(x3 / mul) * mul;
var roundToMultiple4 = roundToMultiple(4);
var $storeRef = Symbol("storeRef");
var $storeSize = Symbol("storeSize");
var $storeMaps = Symbol("storeMaps");
var $storeFlattened = Symbol("storeFlattened");
var $storeBase = Symbol("storeBase");
var $storeType = Symbol("storeType");
var $storeArrayElementCounts = Symbol("storeArrayElementCounts");
var $storeSubarrays = Symbol("storeSubarrays");
var $subarrayCursors = Symbol("subarrayCursors");
var $subarray = Symbol("subarray");
var $subarrayFrom = Symbol("subarrayFrom");
var $subarrayTo = Symbol("subarrayTo");
var $parentArray = Symbol("parentArray");
var $tagStore = Symbol("tagStore");
var $queryShadow = Symbol("queryShadow");
var $serializeShadow = Symbol("serializeShadow");
var $indexType = Symbol("indexType");
var $indexBytes = Symbol("indexBytes");
var $isEidType = Symbol("isEidType");
var stores = {};
var createShadow = (store, key) => {
  if (!ArrayBuffer.isView(store)) {
    const shadowStore = store[$parentArray].slice(0);
    store[key] = store.map((_2, eid) => {
      const { length } = store[eid];
      const start = length * eid;
      const end = start + length;
      return shadowStore.subarray(start, end);
    });
  } else {
    store[key] = store.slice(0);
  }
};
var resetStoreFor = (store, eid) => {
  if (store[$storeFlattened]) {
    store[$storeFlattened].forEach((ta) => {
      if (ArrayBuffer.isView(ta))
        ta[eid] = 0;
      else
        ta[eid].fill(0);
    });
  }
};
var createTypeStore = (type, length) => {
  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT;
  const buffer = new ArrayBuffer(totalBytes);
  const store = new TYPES[type](buffer);
  store[$isEidType] = type === TYPES_ENUM.eid;
  return store;
};
var createArrayStore = (metadata, type, length) => {
  const storeSize = metadata[$storeSize];
  const store = Array(storeSize).fill(0);
  store[$storeType] = type;
  store[$isEidType] = type === TYPES_ENUM.eid;
  const cursors = metadata[$subarrayCursors];
  const indexType = length <= UNSIGNED_MAX.uint8 ? TYPES_ENUM.ui8 : length <= UNSIGNED_MAX.uint16 ? TYPES_ENUM.ui16 : TYPES_ENUM.ui32;
  if (!length)
    throw new Error("bitECS - Must define component array length");
  if (!TYPES[type])
    throw new Error(`bitECS - Invalid component array property type ${type}`);
  if (!metadata[$storeSubarrays][type]) {
    const arrayElementCount = metadata[$storeArrayElementCounts][type];
    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize));
    array[$indexType] = TYPES_NAMES[indexType];
    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
    metadata[$storeSubarrays][type] = array;
  }
  const start = cursors[type];
  const end = start + storeSize * length;
  cursors[type] = end;
  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end);
  for (let eid = 0;eid < storeSize; eid++) {
    const start2 = length * eid;
    const end2 = start2 + length;
    store[eid] = store[$parentArray].subarray(start2, end2);
    store[eid][$indexType] = TYPES_NAMES[indexType];
    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
    store[eid][$subarray] = true;
  }
  return store;
};
var isArrayType = (x3) => Array.isArray(x3) && typeof x3[0] === "string" && typeof x3[1] === "number";
var createStore = (schema, size) => {
  const $store = Symbol("store");
  if (!schema || !Object.keys(schema).length) {
    stores[$store] = {
      [$storeSize]: size,
      [$tagStore]: true,
      [$storeBase]: () => stores[$store]
    };
    return stores[$store];
  }
  schema = JSON.parse(JSON.stringify(schema));
  const arrayElementCounts = {};
  const collectArrayElementCounts = (s2) => {
    const keys = Object.keys(s2);
    for (const k3 of keys) {
      if (isArrayType(s2[k3])) {
        if (!arrayElementCounts[s2[k3][0]])
          arrayElementCounts[s2[k3][0]] = 0;
        arrayElementCounts[s2[k3][0]] += s2[k3][1];
      } else if (s2[k3] instanceof Object) {
        collectArrayElementCounts(s2[k3]);
      }
    }
  };
  collectArrayElementCounts(schema);
  const metadata = {
    [$storeSize]: size,
    [$storeMaps]: {},
    [$storeSubarrays]: {},
    [$storeRef]: $store,
    [$subarrayCursors]: Object.keys(TYPES).reduce((a2, type) => ({ ...a2, [type]: 0 }), {}),
    [$storeFlattened]: [],
    [$storeArrayElementCounts]: arrayElementCounts
  };
  if (schema instanceof Object && Object.keys(schema).length) {
    const recursiveTransform = (a2, k3) => {
      if (typeof a2[k3] === "string") {
        a2[k3] = createTypeStore(a2[k3], size);
        a2[k3][$storeBase] = () => stores[$store];
        metadata[$storeFlattened].push(a2[k3]);
      } else if (isArrayType(a2[k3])) {
        const [type, length] = a2[k3];
        a2[k3] = createArrayStore(metadata, type, length);
        a2[k3][$storeBase] = () => stores[$store];
        metadata[$storeFlattened].push(a2[k3]);
      } else if (a2[k3] instanceof Object) {
        a2[k3] = Object.keys(a2[k3]).reduce(recursiveTransform, a2[k3]);
      }
      return a2;
    };
    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata);
    stores[$store][$storeBase] = () => stores[$store];
    return stores[$store];
  }
};
var SparseSet = () => {
  const dense = [];
  const sparse = [];
  dense.sort = function(comparator) {
    const result = Array.prototype.sort.call(this, comparator);
    for (let i2 = 0;i2 < dense.length; i2++) {
      sparse[dense[i2]] = i2;
    }
    return result;
  };
  const has = (val) => dense[sparse[val]] === val;
  const add = (val) => {
    if (has(val))
      return;
    sparse[val] = dense.push(val) - 1;
  };
  const remove = (val) => {
    if (!has(val))
      return;
    const index = sparse[val];
    const swapped = dense.pop();
    if (swapped !== val) {
      dense[index] = swapped;
      sparse[swapped] = index;
    }
  };
  const reset = () => {
    dense.length = 0;
    sparse.length = 0;
  };
  return {
    add,
    remove,
    has,
    sparse,
    dense,
    reset
  };
};
var not = (fn) => (v3) => !fn(v3);
var storeFlattened = (c2) => c2[$storeFlattened];
var isFullComponent = storeFlattened;
var isProperty = not(isFullComponent);
var isModifier = (c2) => typeof c2 === "function" && c2[$modifier];
var isNotModifier = not(isModifier);
var $entityMasks = Symbol("entityMasks");
var $entityComponents = Symbol("entityComponents");
var $entitySparseSet = Symbol("entitySparseSet");
var $entityArray = Symbol("entityArray");
var $entityIndices = Symbol("entityIndices");
var $removedEntities = Symbol("removedEntities");
var defaultSize = 1e5;
var globalEntityCursor = 0;
var globalSize = defaultSize;
var getGlobalSize = () => globalSize;
var removed = [];
var recycled = [];
var defaultRemovedReuseThreshold = 0.01;
var removedReuseThreshold = defaultRemovedReuseThreshold;
var getEntityCursor = () => globalEntityCursor;
var eidToWorld = /* @__PURE__ */ new Map;
var addEntity = (world) => {
  const eid = world[$manualEntityRecycling] ? removed.length ? removed.shift() : globalEntityCursor++ : removed.length > Math.round(globalSize * removedReuseThreshold) ? removed.shift() : globalEntityCursor++;
  if (eid > world[$size])
    throw new Error("bitECS - max entities reached");
  world[$entitySparseSet].add(eid);
  eidToWorld.set(eid, world);
  world[$notQueries].forEach((q2) => {
    const match = queryCheckEntity(world, q2, eid);
    if (match)
      queryAddEntity(q2, eid);
  });
  world[$entityComponents].set(eid, /* @__PURE__ */ new Set);
  return eid;
};
var removeEntity = (world, eid) => {
  if (!world[$entitySparseSet].has(eid))
    return;
  world[$queries].forEach((q2) => {
    queryRemoveEntity(world, q2, eid);
  });
  if (world[$manualEntityRecycling])
    recycled.push(eid);
  else
    removed.push(eid);
  world[$entitySparseSet].remove(eid);
  world[$entityComponents].delete(eid);
  world[$localEntities].delete(world[$localEntityLookup].get(eid));
  world[$localEntityLookup].delete(eid);
  for (let i2 = 0;i2 < world[$entityMasks].length; i2++)
    world[$entityMasks][i2][eid] = 0;
};
var $modifier = Symbol("$modifier");
function Any(...comps) {
  return function QueryAny() {
    return comps;
  };
}
function All(...comps) {
  return function QueryAll() {
    return comps;
  };
}
function None(...comps) {
  return function QueryNone() {
    return comps;
  };
}
var $queries = Symbol("queries");
var $notQueries = Symbol("notQueries");
var $queryAny = Symbol("queryAny");
var $queryAll = Symbol("queryAll");
var $queryNone = Symbol("queryNone");
var $queryMap = Symbol("queryMap");
var $dirtyQueries = Symbol("$dirtyQueries");
var $queryComponents = Symbol("queryComponents");
var $enterQuery = Symbol("enterQuery");
var $exitQuery = Symbol("exitQuery");
var empty = Object.freeze([]);
var registerQuery = (world, query) => {
  const components2 = [];
  const notComponents = [];
  const changedComponents = [];
  query[$queryComponents].forEach((c2) => {
    if (typeof c2 === "function" && c2[$modifier]) {
      const [comp, mod] = c2();
      if (!world[$componentMap].has(comp))
        registerComponent(world, comp);
      if (mod === "not") {
        notComponents.push(comp);
      }
      if (mod === "changed") {
        changedComponents.push(comp);
        components2.push(comp);
      }
    } else {
      if (!world[$componentMap].has(c2))
        registerComponent(world, c2);
      components2.push(c2);
    }
  });
  const mapComponents = (c2) => world[$componentMap].get(c2);
  const allComponents = components2.concat(notComponents).map(mapComponents);
  const sparseSet = SparseSet();
  const archetypes = [];
  const changed = [];
  const toRemove = SparseSet();
  const entered = SparseSet();
  const exited = SparseSet();
  const generations = allComponents.map((c2) => c2.generationId).reduce((a2, v3) => {
    if (a2.includes(v3))
      return a2;
    a2.push(v3);
    return a2;
  }, []);
  const reduceBitflags = (a2, c2) => {
    if (!a2[c2.generationId])
      a2[c2.generationId] = 0;
    a2[c2.generationId] |= c2.bitflag;
    return a2;
  };
  const masks = components2.map(mapComponents).reduce(reduceBitflags, {});
  const notMasks = notComponents.map(mapComponents).reduce(reduceBitflags, {});
  const hasMasks = allComponents.reduce(reduceBitflags, {});
  const flatProps = components2.filter((c2) => !c2[$tagStore]).map((c2) => Object.getOwnPropertySymbols(c2).includes($storeFlattened) ? c2[$storeFlattened] : [c2]).reduce((a2, v3) => a2.concat(v3), []);
  const shadows = [];
  const q2 = Object.assign(sparseSet, {
    archetypes,
    changed,
    components: components2,
    notComponents,
    changedComponents,
    allComponents,
    masks,
    notMasks,
    hasMasks,
    generations,
    flatProps,
    toRemove,
    entered,
    exited,
    shadows
  });
  world[$queryMap].set(query, q2);
  world[$queries].add(q2);
  allComponents.forEach((c2) => {
    c2.queries.add(q2);
  });
  if (notComponents.length)
    world[$notQueries].add(q2);
  for (let eid = 0;eid < getEntityCursor(); eid++) {
    if (!world[$entitySparseSet].has(eid))
      continue;
    const match = queryCheckEntity(world, q2, eid);
    if (match)
      queryAddEntity(q2, eid);
  }
};
var generateShadow = (q2, pid) => {
  const $3 = Symbol();
  const prop = q2.flatProps[pid];
  createShadow(prop, $3);
  q2.shadows[pid] = prop[$3];
  return prop[$3];
};
var diff = (q2, clearDiff) => {
  if (clearDiff)
    q2.changed = [];
  const { flatProps, shadows } = q2;
  for (let i2 = 0;i2 < q2.dense.length; i2++) {
    const eid = q2.dense[i2];
    let dirty = false;
    for (let pid = 0;pid < flatProps.length; pid++) {
      const prop = flatProps[pid];
      const shadow = shadows[pid] || generateShadow(q2, pid);
      if (ArrayBuffer.isView(prop[eid])) {
        for (let i22 = 0;i22 < prop[eid].length; i22++) {
          if (prop[eid][i22] !== shadow[eid][i22]) {
            dirty = true;
            break;
          }
        }
        shadow[eid].set(prop[eid]);
      } else {
        if (prop[eid] !== shadow[eid]) {
          dirty = true;
          shadow[eid] = prop[eid];
        }
      }
    }
    if (dirty)
      q2.changed.push(eid);
  }
  return q2.changed;
};
var flatten = (a2, v3) => a2.concat(v3);
var aggregateComponentsFor = (mod) => (x3) => x3.filter((f2) => f2.name === mod().constructor.name).reduce(flatten);
var getAnyComponents = aggregateComponentsFor(Any);
var getAllComponents = aggregateComponentsFor(All);
var getNoneComponents = aggregateComponentsFor(None);
var defineQuery = (...args) => {
  let components2;
  let any, all, none;
  if (Array.isArray(args[0])) {
    components2 = args[0];
  } else {}
  if (components2 === undefined || components2[$componentMap] !== undefined) {
    return (world) => world ? world[$entityArray] : components2[$entityArray];
  }
  const query = function(world, clearDiff = true) {
    if (!world[$queryMap].has(query))
      registerQuery(world, query);
    const q2 = world[$queryMap].get(query);
    commitRemovals(world);
    if (q2.changedComponents.length)
      return diff(q2, clearDiff);
    return q2.dense;
  };
  query[$queryComponents] = components2;
  query[$queryAny] = any;
  query[$queryAll] = all;
  query[$queryNone] = none;
  return query;
};
var queryCheckEntity = (world, q2, eid) => {
  const { masks, notMasks, generations } = q2;
  let or = 0;
  for (let i2 = 0;i2 < generations.length; i2++) {
    const generationId = generations[i2];
    const qMask = masks[generationId];
    const qNotMask = notMasks[generationId];
    const eMask = world[$entityMasks][generationId][eid];
    if (qNotMask && (eMask & qNotMask) !== 0) {
      return false;
    }
    if (qMask && (eMask & qMask) !== qMask) {
      return false;
    }
  }
  return true;
};
var queryAddEntity = (q2, eid) => {
  q2.toRemove.remove(eid);
  q2.entered.add(eid);
  q2.add(eid);
};
var queryCommitRemovals = (q2) => {
  for (let i2 = q2.toRemove.dense.length - 1;i2 >= 0; i2--) {
    const eid = q2.toRemove.dense[i2];
    q2.toRemove.remove(eid);
    q2.remove(eid);
  }
};
var commitRemovals = (world) => {
  if (!world[$dirtyQueries].size)
    return;
  world[$dirtyQueries].forEach(queryCommitRemovals);
  world[$dirtyQueries].clear();
};
var queryRemoveEntity = (world, q2, eid) => {
  if (!q2.has(eid) || q2.toRemove.has(eid))
    return;
  q2.toRemove.add(eid);
  world[$dirtyQueries].add(q2);
  q2.exited.add(eid);
};
var $componentMap = Symbol("componentMap");
var components = [];
var defineComponent = (schema, size) => {
  const component = createStore(schema, size || getGlobalSize());
  if (schema && Object.keys(schema).length)
    components.push(component);
  return component;
};
var incrementBitflag = (world) => {
  world[$bitflag] *= 2;
  if (world[$bitflag] >= 2 ** 31) {
    world[$bitflag] = 1;
    world[$entityMasks].push(new Uint32Array(world[$size]));
  }
};
var registerComponent = (world, component) => {
  if (!component)
    throw new Error(`bitECS - Cannot register null or undefined component`);
  const queries = /* @__PURE__ */ new Set;
  const notQueries = /* @__PURE__ */ new Set;
  const changedQueries = /* @__PURE__ */ new Set;
  world[$queries].forEach((q2) => {
    if (q2.allComponents.includes(component)) {
      queries.add(q2);
    }
  });
  world[$componentMap].set(component, {
    generationId: world[$entityMasks].length - 1,
    bitflag: world[$bitflag],
    store: component,
    queries,
    notQueries,
    changedQueries
  });
  incrementBitflag(world);
};
var hasComponent = (world, component, eid) => {
  const registeredComponent = world[$componentMap].get(component);
  if (!registeredComponent)
    return false;
  const { generationId, bitflag } = registeredComponent;
  const mask = world[$entityMasks][generationId][eid];
  return (mask & bitflag) === bitflag;
};
var addComponent = (world, component, eid, reset = false) => {
  if (eid === undefined)
    throw new Error("bitECS - entity is undefined.");
  if (!world[$entitySparseSet].has(eid))
    throw new Error("bitECS - entity does not exist in the world.");
  if (!world[$componentMap].has(component))
    registerComponent(world, component);
  if (hasComponent(world, component, eid))
    return;
  const c2 = world[$componentMap].get(component);
  const { generationId, bitflag, queries, notQueries } = c2;
  world[$entityMasks][generationId][eid] |= bitflag;
  queries.forEach((q2) => {
    q2.toRemove.remove(eid);
    const match = queryCheckEntity(world, q2, eid);
    if (match) {
      q2.exited.remove(eid);
      queryAddEntity(q2, eid);
    }
    if (!match) {
      q2.entered.remove(eid);
      queryRemoveEntity(world, q2, eid);
    }
  });
  world[$entityComponents].get(eid).add(component);
  if (reset)
    resetStoreFor(component, eid);
};
var $size = Symbol("size");
var $resizeThreshold = Symbol("resizeThreshold");
var $bitflag = Symbol("bitflag");
var $archetypes = Symbol("archetypes");
var $localEntities = Symbol("localEntities");
var $localEntityLookup = Symbol("localEntityLookup");
var $manualEntityRecycling = Symbol("manualEntityRecycling");
var worlds = [];
var createWorld = (...args) => {
  const world = typeof args[0] === "object" ? args[0] : {};
  const size = typeof args[0] === "number" ? args[0] : typeof args[1] === "number" ? args[1] : getGlobalSize();
  resetWorld(world, size);
  worlds.push(world);
  return world;
};
var resetWorld = (world, size = getGlobalSize()) => {
  world[$size] = size;
  if (world[$entityArray])
    world[$entityArray].forEach((eid) => removeEntity(world, eid));
  world[$entityMasks] = [new Uint32Array(size)];
  world[$entityComponents] = /* @__PURE__ */ new Map;
  world[$archetypes] = [];
  world[$entitySparseSet] = SparseSet();
  world[$entityArray] = world[$entitySparseSet].dense;
  world[$bitflag] = 1;
  world[$componentMap] = /* @__PURE__ */ new Map;
  world[$queryMap] = /* @__PURE__ */ new Map;
  world[$queries] = /* @__PURE__ */ new Set;
  world[$notQueries] = /* @__PURE__ */ new Set;
  world[$dirtyQueries] = /* @__PURE__ */ new Set;
  world[$localEntities] = /* @__PURE__ */ new Map;
  world[$localEntityLookup] = /* @__PURE__ */ new Map;
  world[$manualEntityRecycling] = false;
  return world;
};
var Types = TYPES_ENUM;

// src/lib/containers.ts
var containers_path = null;
var containers_enemy = null;
var containers_tower = null;
var containers_projectile = null;
function containers_init(viewport) {
  containers_path = new Container;
  containers_enemy = new Container;
  containers_tower = new Container;
  containers_projectile = new Container;
  viewport.addChild(containers_path);
  viewport.addChild(containers_enemy);
  viewport.addChild(containers_tower);
  viewport.addChild(containers_projectile);
}

// src/lib/map.ts
function map_draw_path(path_config) {
  const points = path_config.points;
  const starting_point = points[0];
  if (!starting_point)
    return;
  const path_graphics = new Graphics;
  path_graphics.setStrokeStyle({
    width: 30,
    color: 6636321,
    alpha: 0.75
  });
  path_graphics.moveTo(starting_point.x, starting_point.y);
  for (let i2 = 1;i2 < points.length; i2++) {
    const current_point = points[i2];
    if (!current_point)
      continue;
    path_graphics.lineTo(current_point.x, current_point.y);
  }
  path_graphics.stroke();
  if (!containers_path) {
    should_never_happen("Path container not found");
    return;
  }
  containers_path.addChild(path_graphics);
}

// src/lib/path.ts
function path_generate(points) {
  const path_total_length = path_calculate_length(points);
  return {
    points,
    total_length: path_total_length
  };
}
function path_calculate_length(points) {
  let total_length = 0;
  for (let i2 = 0;i2 < points.length - 1; i2++) {
    const next_point = points[i2 + 1];
    const current_point = points[i2];
    if (!next_point || !current_point)
      continue;
    const dx = next_point.x - current_point.x;
    const dy = next_point.y - current_point.y;
    total_length += Math.sqrt(dx * dx + dy * dy);
  }
  return total_length;
}
function path_get_position(config, progress) {
  const initial_point = config.points[0];
  const last_point = config.points[config.points.length - 1];
  if (!initial_point || !last_point) {
    should_never_happen("Invalid path config");
    return { x: 0, y: 0 };
  }
  if (progress <= 0)
    return { ...initial_point };
  if (progress >= 1)
    return { ...last_point };
  const target_distance = progress * config.total_length;
  let accumulated_distance = 0;
  for (let i2 = 0;i2 < config.points.length - 1; i2++) {
    const start = config.points[i2];
    const end = config.points[i2 + 1];
    if (!start || !end)
      continue;
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const segment_length = Math.sqrt(dx * dx + dy * dy);
    if (accumulated_distance + segment_length >= target_distance) {
      const segment_progress = (target_distance - accumulated_distance) / segment_length;
      return {
        x: start.x + dx * segment_progress,
        y: start.y + dy * segment_progress
      };
    }
    accumulated_distance += segment_length;
  }
  return { ...last_point };
}
function path_distance(p1, p2) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function path_get_direction(config, progress) {
  const target_distance = progress * config.total_length;
  let accumulated = 0;
  for (let i2 = 0;i2 < config.points.length - 1; i2++) {
    const start = config.points[i2];
    const end = config.points[i2 + 1];
    if (!start || !end)
      continue;
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const seg_len = Math.sqrt(dx * dx + dy * dy);
    if (accumulated + seg_len >= target_distance) {
      return { dx, dy };
    }
    accumulated += seg_len;
  }
  return { dx: 0, dy: 0 };
}
function path_is_position_on_path(pos, config, buffer = 15) {
  for (let i2 = 0;i2 < config.points.length - 1; i2++) {
    const a2 = config.points[i2];
    const b2 = config.points[i2 + 1];
    if (!a2 || !b2)
      continue;
    const dist = path_distance_to_segment(pos, a2, b2);
    if (dist < buffer)
      return true;
  }
  return false;
}
function path_distance_to_segment(p2, a2, b2) {
  const l2 = path_distance(a2, b2) ** 2;
  if (l2 === 0)
    return path_distance(p2, a2);
  let t2 = ((p2.x - a2.x) * (b2.x - a2.x) + (p2.y - a2.y) * (b2.y - a2.y)) / l2;
  t2 = Math.max(0, Math.min(1, t2));
  const proj = { x: a2.x + t2 * (b2.x - a2.x), y: a2.y + t2 * (b2.y - a2.y) };
  return path_distance(p2, proj);
}

// src/lib/modal.ts
var VERSION2 = "0.0.1";
function modal_show_instructions(text, on_start) {
  const modal_el = document.createElement("div");
  modal_el.classList.add("modal", "is-active");
  const bg_el = document.createElement("div");
  bg_el.classList.add("modal-background");
  modal_el.appendChild(bg_el);
  const card_el = document.createElement("div");
  card_el.classList.add("modal-card");
  modal_el.appendChild(card_el);
  const head_el = document.createElement("header");
  head_el.classList.add("modal-card-head");
  const title_el = document.createElement("p");
  title_el.classList.add("modal-card-title");
  title_el.textContent = "Mission Instructions";
  head_el.appendChild(title_el);
  card_el.appendChild(head_el);
  const body_el = document.createElement("section");
  body_el.classList.add("modal-card-body");
  const content_el = document.createElement("p");
  content_el.textContent = text;
  body_el.appendChild(content_el);
  card_el.appendChild(body_el);
  const foot_el = document.createElement("footer");
  foot_el.classList.add("modal-card-foot");
  const btn_el = document.createElement("button");
  btn_el.classList.add("button", "is-success");
  btn_el.textContent = "Let's Go";
  btn_el.onclick = () => {
    modal_el.remove();
    on_start();
  };
  foot_el.appendChild(btn_el);
  card_el.appendChild(foot_el);
  const root = document.body;
  if (!root) {
    should_never_happen("Document body not found");
    return;
  }
  root.appendChild(modal_el);
}
function modal_show_defeat() {
  const modal_el = document.createElement("div");
  modal_el.classList.add("modal", "is-active");
  const bg_el = document.createElement("div");
  bg_el.classList.add("modal-background");
  modal_el.appendChild(bg_el);
  const card_el = document.createElement("div");
  card_el.classList.add("modal-card");
  modal_el.appendChild(card_el);
  const head_el = document.createElement("header");
  head_el.classList.add("modal-card-head");
  const title_el = document.createElement("p");
  title_el.classList.add("modal-card-title");
  title_el.textContent = "Defeat!";
  head_el.appendChild(title_el);
  card_el.appendChild(head_el);
  const body_el = document.createElement("section");
  body_el.classList.add("modal-card-body");
  const content_el = document.createElement("p");
  content_el.textContent = "You have lost all lives. Game Over.";
  body_el.appendChild(content_el);
  card_el.appendChild(body_el);
  const foot_el = document.createElement("footer");
  foot_el.classList.add("modal-card-foot");
  const btn_el = document.createElement("button");
  btn_el.classList.add("button", "is-success");
  btn_el.textContent = "Restart";
  btn_el.onclick = () => location.reload();
  foot_el.appendChild(btn_el);
  card_el.appendChild(foot_el);
  const root = document.body;
  if (!root) {
    should_never_happen("Document body not found");
    return;
  }
  root.appendChild(modal_el);
}
async function modal_show_victory() {
  const current_save = save_get(VERSION2);
  const bundle_url = `bundles/${current_save.bundle}/bundle.json`;
  const bundle_config = await (await fetch(bundle_url)).json();
  const missions = bundle_config.missions;
  const current_index = missions.indexOf(current_save.mission);
  const has_next = current_index < missions.length - 1;
  const modal_el = document.createElement("div");
  modal_el.classList.add("modal", "is-active");
  const bg_el = document.createElement("div");
  bg_el.classList.add("modal-background");
  modal_el.appendChild(bg_el);
  const card_el = document.createElement("div");
  card_el.classList.add("modal-card");
  modal_el.appendChild(card_el);
  const head_el = document.createElement("header");
  head_el.classList.add("modal-card-head");
  const title_el = document.createElement("p");
  title_el.classList.add("modal-card-title");
  title_el.textContent = "Victory!";
  head_el.appendChild(title_el);
  card_el.appendChild(head_el);
  const body_el = document.createElement("section");
  body_el.classList.add("modal-card-body");
  const content_el = document.createElement("p");
  content_el.textContent = "You have defended against all waves!";
  body_el.appendChild(content_el);
  card_el.appendChild(body_el);
  const foot_el = document.createElement("footer");
  foot_el.classList.add("modal-card-foot");
  const btn_el = document.createElement("button");
  btn_el.classList.add("button", "is-success");
  btn_el.textContent = has_next ? "Next Mission" : "Restart Bundle from Mission 1";
  btn_el.onclick = async () => {
    let new_mission = missions[0];
    if (has_next) {
      new_mission = missions[current_index + 1];
    }
    const new_save = { ...current_save, mission: new_mission };
    localStorage.setItem("jdefense", JSON.stringify(new_save));
    location.reload();
  };
  foot_el.appendChild(btn_el);
  card_el.appendChild(foot_el);
  document.body.appendChild(modal_el);
}
function modal_show_bundle_select(bundles, on_select) {
  const modal_el = document.createElement("div");
  modal_el.classList.add("modal", "is-active");
  const bg_el = document.createElement("div");
  bg_el.classList.add("modal-background");
  modal_el.appendChild(bg_el);
  const card_el = document.createElement("div");
  card_el.classList.add("modal-card");
  modal_el.appendChild(card_el);
  const head_el = document.createElement("header");
  head_el.classList.add("modal-card-head");
  const title_el = document.createElement("p");
  title_el.classList.add("modal-card-title");
  title_el.textContent = "Select Bundle";
  head_el.appendChild(title_el);
  card_el.appendChild(head_el);
  const body_el = document.createElement("section");
  body_el.classList.add("modal-card-body");
  bundles.forEach((bundle) => {
    const btn = document.createElement("button");
    btn.classList.add("button", "is-primary", "mb-2");
    btn.style.width = "100%";
    btn.textContent = bundle.name;
    btn.onclick = () => {
      modal_el.remove();
      on_select(bundle.id);
    };
    body_el.appendChild(btn);
  });
  card_el.appendChild(body_el);
  document.body.appendChild(modal_el);
}

// src/lib/components.ts
var Position = defineComponent({ x: Types.f32, y: Types.f32 });
var Health = defineComponent({ value: Types.f32 });
var Progress = defineComponent({ value: Types.f32 });
var Cooldown = defineComponent({ timer: Types.f32 });
var Projectile = defineComponent({ target: Types.eid, damage: Types.f32 });
var Enemy = defineComponent();
var Tower = defineComponent();
var Destroy = defineComponent();
var components2 = {
  Position,
  Health,
  Progress,
  Cooldown,
  Projectile,
  Enemy,
  Tower,
  Destroy
};

// src/lib/ecs_maps.ts
var graphicsByEntity = new Map;
var entityTypes = new Map;
var projectileDamageTypes = new Map;
var towerUpgrades = new Map;
var towerRangeGraphics = new Map;

// src/lib/tower.ts
var tower_size = 20;
var { Position: Position2, Tower: Tower2, Cooldown: Cooldown2 } = components2;
function tower_create(world, type, pos, elements) {
  const config = elements.towers[type];
  if (!config) {
    should_never_happen(`Invalid tower type: ${type}`);
    return -1;
  }
  const eid = addEntity(world);
  addComponent(world, Tower2, eid);
  addComponent(world, Position2, eid);
  addComponent(world, Cooldown2, eid);
  Position2.x[eid] = pos.x;
  Position2.y[eid] = pos.y;
  Cooldown2.timer[eid] = 0;
  const graphics = new Container;
  const body = new Graphics().rect(-tower_size / 2, -tower_size / 2, tower_size, tower_size).fill(config.color);
  graphics.addChild(body);
  graphics.position.set(pos.x, pos.y);
  graphics.eventMode = "static";
  graphics.on("pointerover", (e2) => {
    const native = e2.nativeEvent;
    tower_show_range(eid, true);
    game_tooltip_show(eid, native.clientX, native.clientY);
  });
  graphics.on("pointerout", () => {
    if (game_state.selected_existing_tower !== eid) {
      tower_show_range(eid, false);
    }
    game_tooltip_hide();
  });
  if (containers_tower) {
    containers_tower.addChild(graphics);
  }
  graphicsByEntity.set(eid, graphics);
  entityTypes.set(eid, type);
  towerUpgrades.set(eid, []);
  const range_graphics = new Graphics;
  graphics.addChild(range_graphics);
  towerRangeGraphics.set(eid, range_graphics);
  return eid;
}
function tower_show_range(eid, show) {
  if (!game_elements)
    return;
  const type = entityTypes.get(eid);
  if (!type)
    return;
  const config = game_elements.towers[type];
  if (!config)
    return;
  const effective_range = tower_get_effective_range(eid, config);
  const range_graphics = towerRangeGraphics.get(eid);
  if (!range_graphics)
    return;
  if (show) {
    range_graphics.clear();
    range_graphics.circle(0, 0, effective_range);
    range_graphics.stroke({ width: 2, color: 16777215, alpha: 0.5 });
  }
  range_graphics.visible = show;
}
function tower_get_effective_damage(eid, config) {
  let damage = config.damage;
  const upgrades = towerUpgrades.get(eid) || [];
  for (const upgrade of upgrades) {
    const up = config.upgrades.find((u3) => u3.name === upgrade);
    if (up?.effect.damage)
      damage += up.effect.damage;
  }
  return damage;
}
function tower_get_effective_range(eid, config) {
  let range = config.range;
  const upgrades = towerUpgrades.get(eid) || [];
  for (const upgrade of upgrades) {
    const up = config.upgrades.find((u3) => u3.name === upgrade);
    if (up?.effect.range)
      range += up.effect.range;
  }
  return range;
}
function tower_get_effective_fire_rate(eid, config) {
  let fire_rate = config.fire_rate;
  const upgrades = towerUpgrades.get(eid) || [];
  for (const upgrade of upgrades) {
    const up = config.upgrades.find((u3) => u3.name === upgrade);
    if (up?.effect.fire_rate)
      fire_rate += up.effect.fire_rate;
  }
  return fire_rate;
}
function tower_add_upgrade_indicator(eid, upgrade_name) {
  const graphics = graphicsByEntity.get(eid);
  if (!graphics)
    return;
  const indicator = new Graphics().circle(0, 0, 5);
  let color = 16777215;
  if (upgrade_name.includes("damage"))
    color = 16711680;
  else if (upgrade_name.includes("range"))
    color = 65280;
  else if (upgrade_name.includes("fire_rate"))
    color = 255;
  indicator.fill(color);
  const upgrades = towerUpgrades.get(eid) || [];
  const index = upgrades.length - 1;
  indicator.position.set(-10 + index * 10, -15);
  graphics.addChild(indicator);
}

// src/lib/enemy.ts
var enemy_radius = 10;
var { Position: Position3, Enemy: Enemy2, Progress: Progress2, Health: Health2 } = components2;
function get_color_for_enemy_type(type) {
  switch (type) {
    case "basic":
      return 65280;
    case "fast":
      return 16776960;
    case "armored":
      return 8421504;
    case "flying":
      return 65535;
    case "boss":
      return 16711935;
    case "undead":
      return 8388736;
    default:
      return 16711680;
  }
}
function enemy_create(world, enemy_type, elements, path_config) {
  const config = elements.enemies[enemy_type];
  if (!config) {
    should_never_happen(`Invalid enemy type: ${enemy_type}`);
    return -1;
  }
  const eid = addEntity(world);
  addComponent(world, Enemy2, eid);
  addComponent(world, Position3, eid);
  addComponent(world, Health2, eid);
  addComponent(world, Progress2, eid);
  Progress2.value[eid] = 0;
  Health2.value[eid] = config.health;
  const start_pos = path_get_position(path_config, 0);
  Position3.x[eid] = start_pos.x;
  Position3.y[eid] = start_pos.y;
  const graphics = new Container;
  const body = new Graphics().circle(0, 0, enemy_radius);
  body.stroke({ width: 1, color: 0 });
  body.fill(get_color_for_enemy_type(enemy_type));
  graphics.addChild(body);
  graphics.position.set(start_pos.x, start_pos.y);
  if (containers_enemy) {
    containers_enemy.addChild(graphics);
  }
  graphicsByEntity.set(eid, graphics);
  entityTypes.set(eid, enemy_type);
  return eid;
}

// src/lib/projectile.ts
var projectile_speed = 300;
var projectile_radius = 5;

// src/lib/systems.ts
var { Position: Position4, Health: Health3, Progress: Progress3, Cooldown: Cooldown3, Projectile: Projectile2, Enemy: Enemy3, Tower: Tower3, Destroy: Destroy2 } = components2;
var enemyQuery = defineQuery([Enemy3, Position4, Progress3, Health3]);
var towerQuery = defineQuery([Tower3, Position4, Cooldown3]);
var projectileQuery = defineQuery([Projectile2, Position4]);
var destroyQuery = defineQuery([Destroy2]);
function systems_enemy_movement(world, delta_seconds, elements, path_config, events) {
  const ents = enemyQuery(world);
  for (let i2 = 0;i2 < ents.length; i2++) {
    const eid = ents[i2];
    if (eid && Health3.value[eid] <= 0) {
      events.push({ type: "enemy_killed", eid });
      addComponent(world, Destroy2, eid);
      continue;
    }
    const type = eid ? entityTypes.get(eid) : undefined;
    if (!type)
      continue;
    const config = elements.enemies[type];
    if (!config)
      continue;
    if (eid) {
      Progress3.value[eid] += config.speed * delta_seconds / path_config.total_length;
      if (Progress3.value[eid] >= 1) {
        events.push({ type: "enemy_reached", eid });
        addComponent(world, Destroy2, eid);
        continue;
      }
    }
    if (!eid)
      continue;
    const pos = path_get_position(path_config, Progress3.value[eid]);
    Position4.x[eid] = pos.x;
    Position4.y[eid] = pos.y;
    const graphics = graphicsByEntity.get(eid);
    if (!graphics)
      continue;
    graphics.position.set(pos.x, pos.y);
    const dir = path_get_direction(path_config, Progress3.value[eid]);
    graphics.rotation = Math.atan2(dir.dy, dir.dx);
  }
}
function systems_tower_attack(world, delta_seconds, elements, enemy_eids) {
  const ents = towerQuery(world);
  for (let i2 = 0;i2 < ents.length; i2++) {
    const eid = ents[i2];
    if (!eid)
      continue;
    Cooldown3.timer[eid] -= delta_seconds;
    if (Cooldown3.timer[eid] > 0)
      continue;
    const type = entityTypes.get(eid);
    if (!type)
      continue;
    const config = elements.towers[type];
    if (!config)
      continue;
    const effective_range = tower_get_effective_range(eid, config);
    let closest_enemy = null;
    let min_dist = Infinity;
    for (const enemy_eid of enemy_eids) {
      if (!hasComponent(world, Position4, enemy_eid))
        continue;
      const dx = Position4.x[enemy_eid] - Position4.x[eid];
      const dy = Position4.y[enemy_eid] - Position4.y[eid];
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < effective_range && dist < min_dist) {
        min_dist = dist;
        closest_enemy = enemy_eid;
      }
    }
    if (closest_enemy !== null) {
      systems_projectile_create(world, eid, closest_enemy, elements);
      const effective_fire_rate = tower_get_effective_fire_rate(eid, config);
      Cooldown3.timer[eid] = 1 / effective_fire_rate;
    }
  }
}
function systems_projectile_update(world, delta_seconds, elements) {
  const ents = projectileQuery(world);
  for (let i2 = 0;i2 < ents.length; i2++) {
    const eid = ents[i2];
    if (!eid)
      continue;
    const target = Projectile2.target[eid];
    if (!hasComponent(world, Position4, target) || !hasComponent(world, Health3, target)) {
      addComponent(world, Destroy2, eid);
      continue;
    }
    const dx = Position4.x[target] - Position4.x[eid];
    const dy = Position4.y[target] - Position4.y[eid];
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < projectile_radius) {
      systems_projectile_apply_damage(world, eid, target, elements);
      addComponent(world, Destroy2, eid);
      continue;
    }
    const move_dist = projectile_speed * delta_seconds;
    const ratio = move_dist / dist;
    if (ratio > 1) {
      Position4.x[eid] = Position4.x[target];
      Position4.y[eid] = Position4.y[target];
    } else {
      Position4.x[eid] += dx * ratio;
      Position4.y[eid] += dy * ratio;
    }
    const graphics = graphicsByEntity.get(eid);
    if (!graphics)
      continue;
    graphics.position.set(Position4.x[eid], Position4.y[eid]);
  }
}
function systems_projectile_create(world, tower_eid, target_eid, elements) {
  const type = entityTypes.get(tower_eid);
  if (!type)
    return;
  const config = elements.towers[type];
  if (!config)
    return;
  const damage = tower_get_effective_damage(tower_eid, config);
  const damage_type = config.damage_type;
  const eid = addEntity(world);
  addComponent(world, Projectile2, eid);
  addComponent(world, Position4, eid);
  Position4.x[eid] = Position4.x[tower_eid];
  Position4.y[eid] = Position4.y[tower_eid];
  Projectile2.target[eid] = target_eid;
  Projectile2.damage[eid] = damage;
  const graphics = new Container;
  const body = new Graphics().circle(0, 0, projectile_radius);
  let color = 16777215;
  switch (damage_type) {
    case "physical":
      color = 8421504;
      break;
    case "fire":
      color = 16711680;
      break;
    case "ice":
      color = 65535;
      break;
    case "poison":
      color = 65280;
      break;
    case "holy":
      color = 16776960;
      break;
  }
  body.fill(color);
  graphics.addChild(body);
  graphics.position.set(Position4.x[eid], Position4.y[eid]);
  if (containers_projectile) {
    containers_projectile.addChild(graphics);
  }
  graphicsByEntity.set(eid, graphics);
  projectileDamageTypes.set(eid, damage_type);
}
function systems_projectile_apply_damage(_2, proj_eid, target_eid, elements) {
  const target_type = entityTypes.get(target_eid);
  if (!target_type)
    return;
  const config = elements.enemies[target_type];
  if (!config)
    return;
  const damage_type = projectileDamageTypes.get(proj_eid);
  if (!damage_type)
    return;
  const resistance = config.resistances[damage_type] ?? 1;
  const effective_damage = Projectile2.damage[proj_eid] * resistance;
  Health3.value[target_eid] -= effective_damage;
  if (Health3.value[target_eid] < 0)
    Health3.value[target_eid] = 0;
}
function systems_cleanup(world) {
  const ents = destroyQuery(world);
  for (let i2 = 0;i2 < ents.length; i2++) {
    const eid = ents[i2];
    if (!eid)
      continue;
    const graphics = graphicsByEntity.get(eid);
    if (graphics) {
      if (graphics.parent)
        graphics.parent.removeChild(graphics);
      graphics.destroy({ children: true });
      graphicsByEntity.delete(eid);
    }
    entityTypes.delete(eid);
    projectileDamageTypes.delete(eid);
    towerUpgrades.delete(eid);
    removeEntity(world, eid);
  }
}

// src/lib/game.ts
var { Position: Position5 } = components2;
var tower_size2 = 20;
var tooltip = null;
var game_state = {
  current_wave: 0,
  wave_timer: 0,
  enemies: [],
  is_started: false,
  initial_timer: 0,
  gold: 0,
  lives: 0,
  towers: [],
  selected_tower_type: null,
  selected_existing_tower: null,
  projectiles: [],
  paused: false,
  recent_messages: [],
  waiting_for_next_wave: false,
  events: []
};
var game_path_config = null;
var game_elements = null;
var world = null;
var ghost_tower = null;
var previous_footer_mode = "none";
var wave_info_el = null;
var lives_el = null;
var gold_el = null;
var footer_el = null;
var side_left_el = null;
function game_init(elements) {
  const viewport = app_viewport_get();
  if (!viewport)
    return;
  game_elements = elements;
  containers_init(viewport);
  game_path_config = path_generate(elements.mission.enemy_path);
  if (game_path_config)
    map_draw_path(game_path_config);
  game_state.gold = elements.mission.starting_gold;
  game_state.lives = elements.mission.starting_lives;
  world = createWorld();
  wave_info_el = document.getElementById("wave-info");
  lives_el = document.getElementById("lives");
  gold_el = document.getElementById("gold");
  footer_el = document.getElementById("hud-footer");
  side_left_el = document.getElementById("hud-side-left");
  const mission_name_el = document.getElementById("mission-name");
  if (mission_name_el)
    mission_name_el.textContent = elements.mission.name;
  tooltip = document.createElement("div");
  tooltip.classList.add("tooltip");
  tooltip.style.position = "absolute";
  tooltip.style.backgroundColor = "rgba(0,0,0,0.8)";
  tooltip.style.color = "white";
  tooltip.style.padding = "5px";
  tooltip.style.borderRadius = "3px";
  tooltip.style.pointerEvents = "none";
  tooltip.style.display = "none";
  document.body.appendChild(tooltip);
  modal_show_instructions(elements.mission.description, () => {
    game_state.is_started = true;
    game_state.initial_timer = 0;
  });
  game_init_tower_buttons();
  const canvas = document.querySelector("canvas");
  if (canvas) {
    canvas.addEventListener("mousedown", game_handle_canvas_click);
  }
  window.addEventListener("mousemove", (e2) => {
    if (!canvas)
      return;
    const rect = canvas.getBoundingClientRect();
    const offsetX = e2.clientX - rect.left;
    const offsetY = e2.clientY - rect.top;
    game_handle_canvas_mousemove({ offsetX, offsetY });
  });
  document.addEventListener("keydown", (e2) => {
    if (e2.key === "Escape") {
      game_deselect_all();
    } else if (!e2.repeat) {
      if (game_elements) {
        for (const type in game_elements.towers) {
          const config = game_elements.towers[type];
          if (!config)
            continue;
          if (config.hotkey && e2.key.toUpperCase() === config.hotkey.toUpperCase()) {
            game_select_tower_type(type);
            break;
          }
        }
      }
    }
  });
  const pause_el = document.getElementById("pause");
  if (pause_el) {
    pause_el.onclick = () => {
      game_state.paused = !game_state.paused;
      pause_el.innerHTML = game_state.paused ? '<i class="fas fa-play"></i>' : '<i class="fas fa-pause"></i>';
    };
  }
  Ticker.shared.add(game_update);
}
function game_update(ticker) {
  if (game_state.paused)
    return;
  if (!game_elements || !game_path_config || !game_state.is_started)
    return;
  const delta_seconds = ticker.deltaMS / 1000;
  if (game_state.current_wave === 0) {
    game_state.initial_timer += delta_seconds;
    if (game_state.initial_timer >= game_elements.mission.initial_pause) {
      game_start_next_wave();
    }
  } else {
    game_state.wave_timer += delta_seconds;
  }
  systems_projectile_update(world, delta_seconds, game_elements);
  systems_enemy_movement(world, delta_seconds, game_elements, game_path_config, game_state.events);
  systems_tower_attack(world, delta_seconds, game_elements, game_state.enemies);
  let gold_changed = false;
  for (const event of game_state.events) {
    const type = entityTypes.get(event.eid);
    if (!type)
      continue;
    const config = game_elements.enemies[type];
    if (!config)
      continue;
    if (event.type === "enemy_killed") {
      add_message(`Killed ${type} +${config.value} gold`);
      game_state.gold += config.value;
      gold_changed = true;
    } else if (event.type === "enemy_reached") {
      add_message(`${type} reached end! -1 life`);
      game_state.lives--;
      if (game_state.lives <= 0) {
        Ticker.shared.remove(game_update);
        modal_show_defeat();
      }
    }
  }
  game_state.events = [];
  systems_cleanup(world);
  const prev_enemies_length = game_state.enemies.length;
  game_state.enemies = game_state.enemies.filter((eid) => entityTypes.has(eid));
  game_state.projectiles = game_state.projectiles.filter((eid) => entityTypes.has(eid));
  const no_enemies = game_state.enemies.length === 0;
  if (no_enemies && prev_enemies_length > 0 && game_state.current_wave > 0 && !game_state.waiting_for_next_wave) {
    game_state.waiting_for_next_wave = true;
    game_state.wave_timer = 0;
    if (game_state.current_wave < game_elements.mission.total_waves) {
      const next_wave = game_state.current_wave + 1;
      const wave_desc = describe_wave(next_wave);
      add_message(`Wave ${game_state.current_wave} cleared! Next wave (${wave_desc}) in ${game_elements.mission.wave_interval} seconds`);
    } else {
      add_message(`Final wave cleared! Victory!`);
      Ticker.shared.remove(game_update);
      modal_show_victory();
    }
  }
  game_hud_update();
  if (gold_changed)
    game_update_footer();
  if (game_state.enemies.length === 0 && game_state.wave_timer >= game_elements.mission.wave_interval && game_state.current_wave > 0 && game_state.current_wave < game_elements.mission.total_waves) {
    game_start_next_wave();
  }
}
function game_hud_update() {
  if (lives_el) {
    lives_el.innerHTML = `<i class="fas fa-heart"></i> ${game_state.lives}`;
  }
  if (gold_el) {
    gold_el.innerHTML = `<i class="fas fa-coins"></i> ${game_state.gold}`;
  }
  if (wave_info_el && game_elements) {
    let text = "";
    if (!game_state.is_started) {
      text = "Prepare for battle!";
    } else if (game_state.current_wave === 0) {
      const remaining = Math.max(0, Math.ceil(game_elements.mission.initial_pause - game_state.initial_timer));
      text = `First wave in: ${remaining} seconds`;
    } else if (game_state.enemies.length > 0) {
      text = `Wave ${game_state.current_wave} / ${game_elements.mission.total_waves} ongoing`;
    } else {
      const remaining = Math.max(0, Math.ceil(game_elements.mission.wave_interval - game_state.wave_timer));
      text = `Next wave in: ${remaining} seconds`;
    }
    wave_info_el.textContent = text;
  }
  const log_el = document.getElementById("message-log");
  if (log_el && game_state.recent_messages.length > 0) {
    log_el.innerHTML = game_state.recent_messages.map((m3) => `<p class="is-size-7">${m3}</p>`).join("");
  }
}
function game_handle_canvas_click(e2) {
  const viewport = app_viewport_get();
  if (!viewport)
    return;
  const pos = viewport.toWorld(e2.offsetX, e2.offsetY);
  if (game_state.selected_tower_type) {
    game_try_place_tower(pos);
  } else {
    let clicked_tower = null;
    for (const tid of game_state.towers) {
      const half_size = tower_size2 / 2;
      if (!Position5.x[tid] || !Position5.y[tid])
        continue;
      if (pos.x >= Position5.x[tid] - half_size && pos.x <= Position5.x[tid] + half_size && pos.y >= Position5.y[tid] - half_size && pos.y <= Position5.y[tid] + half_size) {
        clicked_tower = tid;
        break;
      }
    }
    if (clicked_tower) {
      game_select_existing_tower(clicked_tower);
    } else {
      game_deselect_all();
    }
  }
}
function game_handle_canvas_mousemove(e2) {
  if (!game_state.selected_tower_type || !containers_tower || !game_elements || !game_path_config)
    return;
  const viewport = app_viewport_get();
  if (!viewport)
    return;
  const pos = viewport.toWorld(e2.offsetX, e2.offsetY);
  if (!ghost_tower) {
    ghost_tower = new Graphics;
    const config = game_elements.towers[game_state.selected_tower_type];
    if (!config) {
      should_never_happen(`Invalid tower type: ${game_state.selected_tower_type}`);
      return;
    }
    ghost_tower.rect(-tower_size2 / 2, -tower_size2 / 2, tower_size2, tower_size2);
    ghost_tower.fill(config.color);
    ghost_tower.alpha = 0.7;
    containers_tower.addChild(ghost_tower);
  }
  ghost_tower.position.set(pos.x, pos.y);
  const buffer = tower_size2 / 2 + 15;
  let tint = 16777215;
  if (path_is_position_on_path(pos, game_path_config, buffer) || is_position_overlapping_tower(pos)) {
    tint = 16711680;
  }
  ghost_tower.tint = tint;
}
function is_position_overlapping_tower(pos) {
  for (const tid of game_state.towers) {
    if (!Position5.x[tid] || !Position5.y[tid])
      continue;
    const dx = Math.abs(pos.x - Position5.x[tid]);
    const dy = Math.abs(pos.y - Position5.y[tid]);
    if (dx < tower_size2 && dy < tower_size2)
      return true;
  }
  return false;
}
function game_try_place_tower(pos) {
  if (!game_path_config || !game_elements || !game_state.selected_tower_type)
    return;
  const buffer = tower_size2 / 2 + 15;
  if (path_is_position_on_path(pos, game_path_config, buffer) || is_position_overlapping_tower(pos)) {
    const temp_graphics = new Graphics;
    temp_graphics.rect(pos.x - tower_size2 / 2, pos.y - tower_size2 / 2, tower_size2, tower_size2);
    temp_graphics.fill(16711680);
    if (containers_tower) {
      containers_tower.addChild(temp_graphics);
      setTimeout(() => temp_graphics.destroy(), 500);
    }
    return;
  }
  const type = game_state.selected_tower_type;
  const config = game_elements.towers[type];
  if (!config) {
    should_never_happen(`Invalid tower type: ${type}`);
    return;
  }
  if (game_state.gold < config.cost)
    return;
  game_state.gold -= config.cost;
  const eid = tower_create(world, type, pos, game_elements);
  if (eid === -1)
    return;
  game_state.towers.push(eid);
  add_message(`Placed ${config.name} tower for ${config.cost} gold`);
  game_hud_update();
  game_update_footer();
}
function game_select_tower_type(type) {
  const previous_type = game_state.selected_tower_type;
  game_state.selected_tower_type = previous_type === type ? null : type;
  if (game_state.selected_existing_tower) {
    tower_show_range(game_state.selected_existing_tower, false);
    game_state.selected_existing_tower = null;
  }
  if (game_elements) {
    for (const t2 in game_elements.towers) {
      const btn = document.getElementById(`tower-btn-${t2}`);
      if (btn) {
        btn.classList.toggle("is-active", t2 === game_state.selected_tower_type);
      }
    }
  }
  if (game_state.selected_tower_type && previous_type && previous_type !== type && ghost_tower) {
    ghost_tower.destroy();
    ghost_tower = null;
  }
  if (!game_state.selected_tower_type && ghost_tower) {
    ghost_tower.destroy();
    ghost_tower = null;
  }
  game_update_footer();
}
function game_select_existing_tower(eid) {
  if (game_state.selected_existing_tower) {
    tower_show_range(game_state.selected_existing_tower, false);
  }
  game_state.selected_existing_tower = eid;
  game_state.selected_tower_type = null;
  tower_show_range(eid, true);
  if (game_elements) {
    for (const t2 in game_elements.towers) {
      const btn = document.getElementById(`tower-btn-${t2}`);
      if (btn) {
        btn.classList.remove("is-active");
      }
    }
  }
  game_update_footer();
}
function game_deselect_all() {
  game_state.selected_tower_type = null;
  if (game_state.selected_existing_tower) {
    tower_show_range(game_state.selected_existing_tower, false);
    game_state.selected_existing_tower = null;
  }
  if (ghost_tower) {
    ghost_tower.destroy();
    ghost_tower = null;
  }
  if (game_elements) {
    for (const t2 in game_elements.towers) {
      const btn = document.getElementById(`tower-btn-${t2}`);
      if (btn) {
        btn.classList.remove("is-active");
      }
    }
  }
  game_update_footer();
}
function game_start_next_wave() {
  if (!game_elements) {
    should_never_happen("Game elements not found");
    return;
  }
  if (!game_path_config) {
    should_never_happen("Path config not found");
    return;
  }
  game_state.current_wave++;
  if (game_state.current_wave > game_elements.mission.total_waves) {
    return;
  }
  const wave = game_elements.waves.waves.find((w2) => w2.number === game_state.current_wave);
  if (!wave)
    return;
  add_message(`Wave ${game_state.current_wave} started: ${describe_wave(game_state.current_wave)}`);
  let spawn_index = 0;
  const spawn_next_group = () => {
    if (spawn_index >= wave.enemies.length)
      return;
    const group = wave.enemies[spawn_index];
    if (!group) {
      should_never_happen("Wave group not found");
      return;
    }
    let spawn_time = 0;
    for (let i2 = 0;i2 < group.count; i2++) {
      setTimeout(() => {
        if (!game_elements) {
          should_never_happen("Game elements not found");
          return;
        }
        if (!game_path_config) {
          should_never_happen("Path config not found");
          return;
        }
        const eid = enemy_create(world, group.type, game_elements, game_path_config);
        if (eid === -1)
          return;
        game_state.enemies.push(eid);
      }, spawn_time);
      spawn_time += Math.random() * 3900 + 100;
    }
    spawn_index++;
    if (spawn_index < wave.enemies.length) {
      const current_wave_enemies = wave.enemies[spawn_index - 1];
      if (!current_wave_enemies) {
        should_never_happen("Wave group not found");
        return;
      }
      const next_delay = current_wave_enemies.spawn_delay * 1000;
      setTimeout(spawn_next_group, next_delay);
    }
  };
  spawn_next_group();
  game_state.waiting_for_next_wave = false;
  game_state.wave_timer = 0;
}
function describe_wave(num) {
  if (!game_elements)
    return "";
  const wave = game_elements.waves.waves.find((w2) => w2.number === num);
  if (!wave)
    return "";
  return wave.enemies.map((e2) => `${e2.count} ${e2.type}`).join(", ");
}
function add_message(msg) {
  game_state.recent_messages.push(msg);
  if (game_state.recent_messages.length > 10) {
    game_state.recent_messages.shift();
  }
}
function game_init_tower_buttons() {
  if (!game_elements || !side_left_el)
    return;
  side_left_el.innerHTML = "";
  for (const type in game_elements.towers) {
    const config = game_elements.towers[type];
    if (!config)
      continue;
    const hotkeyText = config.hotkey ? ` [${config.hotkey}]` : "";
    const btn = document.createElement("button");
    btn.id = `tower-btn-${type}`;
    btn.classList.add("button", "is-primary", "mb-2");
    btn.style.backgroundColor = `#${config.color.toString(16).padStart(6, "0")}`;
    btn.style.width = "100%";
    btn.innerHTML = `<i class="fas fa-chess-rook"></i> ${config.name} (${config.cost})${hotkeyText}`;
    btn.onclick = () => game_select_tower_type(type);
    btn.onmouseover = (e2) => {
      if (!game_elements)
        return;
      const conf = game_elements.towers[type];
      if (!conf)
        return;
      let html = `
Damage: ${conf.damage}<br>
Range: ${conf.range}<br>
Fire Rate: ${conf.fire_rate}<br>
Type: ${conf.damage_type}
      `;
      if (conf.upgrades.length > 0) {
        html += "<br>Upgrades:<br>";
        conf.upgrades.forEach((u3) => {
          html += `${u3.display_name} (${u3.cost}): `;
          if (u3.effect.damage)
            html += `+${u3.effect.damage} dmg `;
          if (u3.effect.range)
            html += `+${u3.effect.range} range `;
          if (u3.effect.fire_rate)
            html += `+${u3.effect.fire_rate} rate `;
          html += "<br>";
        });
      }
      if (tooltip) {
        tooltip.innerHTML = html;
        tooltip.style.left = `${e2.clientX + 10}px`;
        tooltip.style.top = `${e2.clientY + 10}px`;
        tooltip.style.display = "block";
      }
    };
    btn.onmouseout = () => {
      if (tooltip) {
        tooltip.style.display = "none";
      }
    };
    side_left_el.appendChild(btn);
  }
}
function game_update_footer() {
  if (!footer_el || !game_elements)
    return;
  let mode = "none";
  if (game_state.selected_existing_tower) {
    mode = "upgrade";
  } else if (game_state.selected_tower_type) {
    mode = "place";
  }
  if (mode !== previous_footer_mode) {
    footer_el.innerHTML = "";
    if (mode === "place") {
      const config = game_elements.towers[game_state.selected_tower_type];
      if (!config)
        return;
      const info_div = document.createElement("div");
      info_div.id = "place-info";
      info_div.classList.add("info-div", "is-size-5");
      info_div.textContent = `Selected: ${config.name} - Click on map to place (Esc to cancel)`;
      footer_el.appendChild(info_div);
    } else if (mode === "upgrade") {
      const selected = game_state.selected_existing_tower;
      const type = entityTypes.get(selected);
      if (!type)
        return;
      const config = game_elements.towers[type];
      if (!config)
        return;
      const stats_div = document.createElement("div");
      stats_div.id = "tower-stats";
      stats_div.classList.add("stats-div", "is-size-5", "mr-4");
      stats_div.textContent = `Damage: ${tower_get_effective_damage(selected, config)} | Range: ${tower_get_effective_range(selected, config)} | Fire Rate: ${tower_get_effective_fire_rate(selected, config).toFixed(1)} | Type: ${config.damage_type}`;
      footer_el.appendChild(stats_div);
      const upgrades = towerUpgrades.get(selected) || [];
      for (const up of config.upgrades) {
        if (upgrades.includes(up.name))
          continue;
        const up_btn = document.createElement("button");
        up_btn.id = `upgrade-${up.name}`;
        up_btn.classList.add("button", "is-info", "mr-2");
        up_btn.textContent = `${up.display_name} (${up.cost})`;
        up_btn.disabled = game_state.gold < up.cost;
        up_btn.onclick = () => {
          if (game_state.gold >= up.cost && !upgrades.includes(up.name)) {
            game_state.gold -= up.cost;
            upgrades.push(up.name);
            towerUpgrades.set(selected, upgrades);
            tower_show_range(selected, true);
            add_message(`Upgraded tower with ${up.display_name} for ${up.cost} gold`);
            game_hud_update();
            previous_footer_mode = "none";
            game_update_footer();
            tower_add_upgrade_indicator(selected, up.name);
          }
        };
        footer_el.appendChild(up_btn);
      }
    }
    previous_footer_mode = mode;
  } else if (mode === "place") {
    const config = game_elements.towers[game_state.selected_tower_type];
    if (!config)
      return;
    const info_el = document.getElementById("place-info");
    if (info_el) {
      info_el.textContent = `Selected: ${config.name} - Click on map to place (Esc to cancel)`;
    }
  } else if (mode === "upgrade") {
    const selected = game_state.selected_existing_tower;
    const type = entityTypes.get(selected);
    if (!type) {
      should_never_happen(`Invalid tower type`);
      return;
    }
    const config = game_elements.towers[type];
    if (!config) {
      should_never_happen(`Invalid tower type: ${type}`);
      return;
    }
    const stats_el = document.getElementById("tower-stats");
    if (stats_el) {
      stats_el.textContent = `Damage: ${tower_get_effective_damage(selected, config)} | Range: ${tower_get_effective_range(selected, config)} | Fire Rate: ${tower_get_effective_fire_rate(selected, config).toFixed(1)} | Type: ${config.damage_type}`;
    }
    const upgrades = towerUpgrades.get(selected) || [];
    for (const up of config.upgrades) {
      if (upgrades.includes(up.name))
        continue;
      const up_btn = document.getElementById(`upgrade-${up.name}`);
      if (up_btn) {
        up_btn.disabled = game_state.gold < up.cost;
      }
    }
  }
}
function game_tooltip_show(eid, clientX, clientY) {
  if (!game_elements || !tooltip)
    return;
  const type = entityTypes.get(eid);
  if (!type)
    return;
  const config = game_elements.towers[type];
  if (!config)
    return;
  const damage = tower_get_effective_damage(eid, config);
  const range = tower_get_effective_range(eid, config);
  const fire_rate = tower_get_effective_fire_rate(eid, config);
  const upgrades = towerUpgrades.get(eid) || [];
  const upgrades_list = upgrades.length > 0 ? upgrades.map((up) => config.upgrades.find((u3) => u3.name === up)?.display_name || up).join(", ") : "None";
  tooltip.innerHTML = `
    Damage: ${damage}<br>
    Range: ${range}<br>
    Fire Rate: ${fire_rate.toFixed(1)}<br>
    Type: ${config.damage_type}<br>
    Upgrades: ${upgrades_list}
  `;
  tooltip.style.left = `${clientX + 10}px`;
  tooltip.style.top = `${clientY + 10}px`;
  tooltip.style.display = "block";
}
function game_tooltip_hide() {
  if (tooltip)
    tooltip.style.display = "none";
}

// node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2?.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3?.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  return store4?.get(reference)?.get(lang);
}
function _stringify(input) {
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  }
  return type;
}
function _addIssue(context2, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = other?.expected ?? context2.expects ?? null;
  const received = other?.received ?? _stringify(input);
  const issue = {
    kind: context2.kind,
    type: context2.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    requirement: context2.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context2.kind === "schema";
  const message2 = other?.message ?? context2.message ?? getSpecificMessage(context2.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
  if (message2 !== undefined) {
    issue.message = typeof message2 === "function" ? message2(issue) : message2;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function _getStandardProps(context2) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value2) {
      return context2["~run"]({ value: value2 }, getGlobalConfig());
    }
  };
}
function _isValidObjectKey(object2, key) {
  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
function _joinExpects(values2, separator) {
  const list = [...new Set(values2)];
  if (list.length > 1) {
    return `(${list.join(` ${separator} `)})`;
  }
  return list[0] ?? "never";
}
var ValiError = class extends Error {
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback === "function" ? schema.fallback(dataset, config2) : schema.fallback;
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? schema.default(dataset, config2) : schema.default;
}
function array(item, message2) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0;key < input.length; key++) {
          const value2 = input[key];
          const itemDataset = this.item["~run"]({ value: value2 }, config2);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function literal(literal_, message2) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(literal_),
    async: false,
    literal: literal_,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === this.literal) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function number(message2) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function object(entries2, message2) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries: entries2,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const valueSchema = this.entries[key];
          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== undefined) {
            const value2 = key in input ? input[key] : getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value2 }, config2);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key,
                value: value2
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value[key] = valueDataset.value;
          } else if (valueSchema.fallback !== undefined) {
            dataset.value[key] = getFallback(valueSchema);
          } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config2, {
              input: undefined,
              expected: `"${key}"`,
              path: [
                {
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  value: input[key]
                }
              ]
            });
            if (config2.abortEarly) {
              break;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function optional(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === undefined) {
        if (this.default !== undefined) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === undefined) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config2);
    }
  };
}
function record(key, value2, message2) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key,
    value: value2,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const entryKey in input) {
          if (_isValidObjectKey(input, entryKey)) {
            const entryValue = input[entryKey];
            const keyDataset = this.key["~run"]({ value: entryKey }, config2);
            if (keyDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "key",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of keyDataset.issues) {
                issue.path = [pathItem];
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            const valueDataset = this.value["~run"]({ value: entryValue }, config2);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            if (keyDataset.typed) {
              dataset.value[keyDataset.value] = valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function string(message2) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function _subIssues(datasets) {
  let issues;
  if (datasets) {
    for (const dataset of datasets) {
      if (issues) {
        issues.push(...dataset.issues);
      } else {
        issues = dataset.issues;
      }
    }
  }
  return issues;
}
function union(options, message2) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(options.map((option) => option.expects), "|"),
    async: false,
    options,
    message: message2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema["~run"]({ value: dataset.value }, config2);
        if (optionDataset.typed) {
          if (optionDataset.issues) {
            if (typedDatasets) {
              typedDatasets.push(optionDataset);
            } else {
              typedDatasets = [optionDataset];
            }
          } else {
            validDataset = optionDataset;
            break;
          }
        } else {
          if (untypedDatasets) {
            untypedDatasets.push(optionDataset);
          } else {
            untypedDatasets = [optionDataset];
          }
        }
      }
      if (validDataset) {
        return validDataset;
      }
      if (typedDatasets) {
        if (typedDatasets.length === 1) {
          return typedDatasets[0];
        }
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(typedDatasets)
        });
        dataset.typed = true;
      } else if (untypedDatasets?.length === 1) {
        return untypedDatasets[0];
      } else {
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(untypedDatasets)
        });
      }
      return dataset;
    }
  };
}
function parse2(schema, input, config2) {
  const dataset = schema["~run"]({ value: input }, getGlobalConfig(config2));
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}

// src/lib/schemas.ts
var NumberSchema = number();
var StringSchema = string();
var OptionalStringSchema = optional(string());
var PathPointSchema = object({
  x: NumberSchema,
  y: NumberSchema
});
var ResistancesSchema = record(StringSchema, NumberSchema);
var EnemySchema = object({
  health: NumberSchema,
  speed: NumberSchema,
  value: NumberSchema,
  resistances: ResistancesSchema
});
var EnemiesSchema = record(StringSchema, EnemySchema);
var UpgradeEffectSchema = object({
  damage: optional(NumberSchema),
  range: optional(NumberSchema),
  fire_rate: optional(NumberSchema)
});
var UpgradeSchema = object({
  name: StringSchema,
  display_name: StringSchema,
  cost: NumberSchema,
  effect: UpgradeEffectSchema
});
var TowerSchema = object({
  name: StringSchema,
  cost: NumberSchema,
  damage: NumberSchema,
  range: NumberSchema,
  fire_rate: NumberSchema,
  damage_type: StringSchema,
  color: NumberSchema,
  texture: OptionalStringSchema,
  upgrades: array(UpgradeSchema),
  hotkey: OptionalStringSchema
});
var TowersSchema = record(StringSchema, TowerSchema);
var WaveEnemySchema = object({
  type: StringSchema,
  count: NumberSchema,
  spawn_delay: NumberSchema
});
var WaveSchema = object({
  number: NumberSchema,
  enemies: array(WaveEnemySchema)
});
var WavesSchema = object({
  waves: array(WaveSchema)
});
var MissionSoundsSchema = object({
  tower_build: StringSchema,
  enemy_spawn: StringSchema,
  damage_taken: StringSchema
});
var MissionSchema = object({
  name: StringSchema,
  description: StringSchema,
  map_texture: StringSchema,
  background_music: StringSchema,
  victory_sound: StringSchema,
  defeat_sound: StringSchema,
  starting_gold: NumberSchema,
  starting_lives: NumberSchema,
  wave_interval: NumberSchema,
  difficulty: union([literal("easy"), literal("medium"), literal("hard")]),
  total_waves: NumberSchema,
  sounds: MissionSoundsSchema,
  enemy_path: array(PathPointSchema),
  initial_pause: NumberSchema
});
var FullMissionSchema = object({
  mission: MissionSchema,
  enemies: EnemiesSchema,
  towers: TowersSchema,
  waves: WavesSchema
});
var BundleSchema = object({
  name: StringSchema,
  missions: array(StringSchema)
});
var BundlesListSchema = object({
  bundles: array(object({
    id: StringSchema,
    name: StringSchema
  }))
});

// src/web.ts
var VERSION3 = "0.0.1";
async function main() {
  const root_element = document.getElementById("app");
  if (!root_element) {
    should_never_happen("Root Element Not Found!");
    return;
  }
  let current_save = save_get(VERSION3);
  if (!current_save.bundle) {
    const bundles_data = await (await fetch(`bundles/bundles.json`)).json();
    const validated_bundles = parse2(BundlesListSchema, bundles_data);
    modal_show_bundle_select(validated_bundles.bundles, async (selected_id) => {
      const bundle_url2 = `bundles/${selected_id}/bundle.json`;
      const bundle_config2 = await (await fetch(bundle_url2)).json();
      const first_mission = bundle_config2.missions[0];
      if (!first_mission) {
        should_never_happen("No missions in bundle");
        return;
      }
      const new_save = { version: VERSION3, bundle: selected_id, mission: first_mission };
      localStorage.setItem("jdefense", JSON.stringify(new_save));
      location.reload();
    });
    return;
  }
  const bundle_url = `bundles/${current_save.bundle}/bundle.json`;
  const bundle_config = await (await fetch(bundle_url)).json();
  if (!bundle_config.missions.includes(current_save.mission)) {
    current_save.mission = bundle_config.missions[0] || "";
    localStorage.setItem("jdefense", JSON.stringify(current_save));
  }
  const mission_url = `bundles/${current_save.bundle}/${current_save.mission}`;
  const mission_data = await (await fetch(mission_url)).json();
  const validated_data = parse2(FullMissionSchema, mission_data);
  const { enemies, towers, waves, mission } = validated_data;
  const hud = hud_create();
  for (const h2 of hud) {
    document.body.appendChild(h2);
  }
  const app = await app_create();
  const canvas = app_canvas_setup(app);
  root_element.appendChild(canvas);
  const viewport = await app_viewport_create(app);
  app.stage.addChild(viewport);
  game_init({ enemies, towers, waves, mission });
}
main();

//# debugId=675E5C88782AE1F264756E2164756E21
